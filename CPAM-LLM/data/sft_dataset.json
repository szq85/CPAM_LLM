[
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require an interval of 10 time units or less, while loose constraints require an interval of 40 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []  \n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0) \n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = [] \nmachine_operations = [[] for m in range(num_machines)] \njob_operations = []  \n\nfor jx, job in enumerate(JOBS):    \n    op_vars = []\n    for ox, op in enumerate(job):       \n        choice_vars = []\n        for cx, (m, d) in enumerate(op):    \n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)  \n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 25 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []  \n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0) \n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = [] \nmachine_operations = [[] for m in range(num_machines)] \njob_operations = []  \n\nfor jx, job in enumerate(JOBS):    \n    op_vars = []\n    for ox, op in enumerate(job):       \n        choice_vars = []\n        for cx, (m, d) in enumerate(op):    \n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)  \n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.\nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.\nMachine assignment: Implicitly determined by which optional interval variable is selected as present.\n\n2. Parameters and Input Data\nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.\nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.\nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.\nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.\nSpecific temporal windows: Job 1 must commence within a restricted time window, specifically between time 15 and time 80.\n\n3. Constraints\nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.\nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.\nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.\nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.\nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.\nSpecific temporal window constraint: Job 1 must start within the time window between time 15 and time 80.\n\n4. Objective Function\nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.\n\n5. Data Specification\nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:\nFirst line: Two integers representing the number of jobs and number of machines.\nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Specific jobs must start within predefined time intervals to meet production scheduling requirements.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted time window constraints: Job 1 must commence within a specific time window, between time 30 and time 100, to adhere to production scheduling requirements.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and must be completed before time 500.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nProduction window constraint for Job 2: All operations of Job 2 must start after time 20 and must be completed before time 500, ensuring the job fits within its designated production window.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\nimport docplex.cp.utils_visu as visu\n\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 40 time units or more.  \nProduction window for Job 2: All operations of Job 2 must start after time 5 and finish before time 400.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nProduction window constraints for Job 2: All operations of Job 2 must start after time 5 and must be completed before time 400.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\nimport docplex.cp.utils_visu as visu\n\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 15 and finish before time 400.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nProduction window constraint: All operations of Job 2 must start after time 15 and finish before time 400, ensuring adherence to the designated production window.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\nimport docplex.cp.utils_visu as visu\n\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 25 time units or more.  \nInter-job precedence relationships: Job 3 can only commence after all operations of Job 2 have been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 35 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed, reflecting dependencies in the manufacturing process.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by selecting which optional interval variable is present for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: The total count of aircraft skin components (jobs) to be processed and the number of available machines in the shop.  \nJob structure: Each job consists of a sequence of operations that must be processed in the specified order.  \nMachine eligibility and processing times: Each operation can be executed on a subset of machines, each with an associated processing time.  \nTemporal constraints: Tight temporal constraints require the time interval between consecutive operations of a job to be at most 12 time units, while loose temporal constraints require the interval to be at least 40 time units.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of eligible candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within each job must be executed sequentially, with each operation starting only after the previous operation has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTight temporal constraints: For consecutive operations within a job, if specified as tight, the time interval between the end of one operation and the start of the next must not exceed 12 time units.  \nLoose temporal constraints: For consecutive operations within a job, if specified as loose, the time interval between the end of one operation and the start of the next must be at least 40 time units.  \n\n4. Objective Function  \nMinimize the makespan, defined as the maximum completion time among all jobs, representing the time at which the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and the number of machines.  \nSubsequent lines (one per job): Number of operations for the job, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 25 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nFine-grained temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 500 and 650.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nFine-grained temporal constraint: The end time of the first operation of Job 5 must fall within the time interval between 500 and 650, ensuring synchronization with downstream processes or quality control checkpoints.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 650)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 25 time units or more.  \nOperation-level temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 550 and 700.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nOperation-level temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 550 and 700.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 700)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nOperation-level temporal window: The end time of the first operation of Job 5 must fall within a time window between 500 and 650.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nOperation-level temporal window: The end time of the first operation of Job 5 must fall within the interval [500, 650].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 650)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 25 time units or more.  \nSequence-dependent setup times: A 15-minute setup time is required whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nSequence-dependent setup constraints: A setup time of 15 minutes must be added whenever a machine transitions from processing one job to processing a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 45 time units or more.  \nSequence-dependent setup times: A setup time of 25 minutes is required whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations within a job, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations within a job, the time interval must be at least 45 time units.  \nSequence-dependent setup time constraint: When a machine transitions from processing one job to processing a different job, a setup time of 25 minutes is required before the next operation can start.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows:  \n- Job 1 must start within the time window [30, 150].  \n- All operations of Job 2 must start after time 10 and be completed before time 500.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted time window constraints:  \n- Job 1 must start within the time window [30, 150].  \n- All operations of Job 2 must start after time 10 and be completed before time 500.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 500)\n            \n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 45 time units or more.  \nRestricted temporal windows for specific jobs:  \n- Job 1 must commence within the time window [30, 120].  \n- Job 2 must have all operations start after time 10 and complete before time 450.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted temporal windows:  \n- Job 1 must start within the time window [30, 120].  \n- Job 2 must have all its operations start after time 10 and finish before time 450.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 450)\n            \n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: Specifies that Job 1 must commence within the interval [15, 100].  \nProduction window for Job 2: Imposes that all operations of Job 2 must start after time 10 and be completed before time 550.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time window for Job 1: All operations of Job 1 must commence within the interval [15, 100].  \nProduction window for Job 2: All operations of Job 2 must start after time 10 and be completed before time 550.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n            \n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSpecific temporal windows: Job 1 must commence within a restricted time window, specifically between time 25 and time 80.  \nInter-job precedence requirements: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nSpecific temporal window constraints: Job 1 must start within the time window [25, 80].  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSpecific temporal windows: Job 1 must commence within a restricted time window between time 25 and time 80.  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nSpecific temporal window constraints: Job 1 must commence within the time range of 25 to 80 units.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and the number of available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Tight constraints require intervals of at most 12 time units between consecutive operations, while loose constraints require intervals of at least 45 time units.  \nTemporal window for Job 1: Job 1 must commence within the time interval [15, 120].  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within each job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nTemporal window constraint: The start time of Job 1 must fall within the interval [15, 120].  \nInter-job precedence constraint: All operations of Job 3 must start only after the completion of all operations in Job 2.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nTime window constraints: Specific time windows for job execution, such as a requirement for Job 1 to commence between time 20 and time 100.  \nFine-grained precedence constraints: Dependencies between operations of different jobs, such as requiring the first operation of Job 4 to start only after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nTime window constraints: Job 1 must start within the time window between time 20 and time 100.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require a time interval of 12 time units or less, while loose constraints require a time interval of 25 time units or more.  \nSpecific temporal windows: Job 1 must commence within a restricted time window, specifically between time 25 and time 150.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nSpecific temporal window constraint: Job 1 must start within the time window [25, 150].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine selected.  \nOptional interval variables for machine choices: For each operation, an optional interval variable is defined for each candidate machine, representing the execution of the operation on that specific machine with its associated processing duration.  \nMachine assignment: Implicitly determined by the presence of the optional interval variable corresponding to a specific machine.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components to be processed (jobs) and the number of available machines in the shop.  \nJob structure: Each job is composed of a predefined sequence of operations that must be performed in a specific order.  \nMachine eligibility and processing times: Each operation has a set of candidate machines, with each machine having a specific processing duration for that operation.  \nTemporal constraints between operations:  \n  - Tight temporal constraints: Consecutive operations of a job must have an interval of 18 time units or less.  \n  - Loose temporal constraints: Consecutive operations of a job must have an interval of 35 time units or more.  \nJob-specific time window constraints:  \n  - Job 1 must start within the time window [15, 100].  \nOperation-specific time window constraints:  \n  - The end time of the first operation of Job 5 must fall within the time window [550, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring that machine usage does not overlap.  \nPrecedence constraints: Operations within a job must be executed in the given order, with each operation starting only after the previous operation in the sequence has completed.  \nTight temporal constraints: If a tight temporal constraint is specified between two consecutive operations of a job, the time interval between the end of the first operation and the start of the next must not exceed 18 time units.  \nLoose temporal constraints: If a loose temporal constraint is specified between two consecutive operations of a job, the time interval between the end of the first operation and the start of the next must be at least 35 time units.  \nJob-specific time window constraints: Job 1 must commence within the time window [15, 100].  \nOperation-specific time window constraints: The end time of the first operation of Job 5 must fall within the time window [550, 600].  \n\n4. Objective Function  \nMinimize the makespan, defined as the maximum completion time among all jobs, representing the time at which the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') for each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Specific time windows are imposed on the start or completion of certain operations for individual jobs.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time window constraints:  \n- Job 1 must commence within the time window between 20 and 100 time units.  \n- The end time of the first operation of Job 5 must fall within the time window between 550 and 650 time units.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 650)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 40 time units or more.  \nJob-level temporal window: Job 1 must commence within a restricted time window, specifically between time 30 and time 100.  \nOperation-level temporal window: The end time of the first operation of Job 5 must fall within the time window between 550 and 700.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-level temporal window: Job 1 must commence within the time window between time 30 and time 100.  \nOperation-level temporal window: The end time of the first operation of Job 5 must fall within the time window between 550 and 700.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 700)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \nSequence-dependent setup times: Additional interval variables representing the setup time between consecutive operations on the same machine when transitioning between different jobs.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Tight constraints require time intervals of 20 time units or less between consecutive operations, while loose constraints require time intervals of 40 time units or more.  \nTemporal windows: Job 1 must commence within a restricted time window between time 30 and time 150.  \nSetup times: A sequence-dependent setup time of 15 time units is required whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nTemporal window constraint: The first operation of Job 1 must start within the time window between time 30 and time 150.  \nSequence-dependent setup time constraint: A setup time of 15 time units must be enforced whenever a machine transitions from processing one job to processing a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 10 time units or less, while loose constraints require intervals of 40 time units or more.  \nSpecific temporal windows: Job 1 must commence within a restricted time window, specifically between time 15 and time 100.  \nSequence-dependent setup times: A 30-minute setup time is required whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nSpecific temporal window constraint: Job 1 must start between time 15 and time 100.  \nSequence-dependent setup times: A 30-minute setup time is required whenever the same machine transitions from processing one job to processing a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Job 1 must commence within a restricted time window, specifically between time 20 and time 80.  \nSequence-dependent setup times: A setup time of 15 time units is incurred whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal window constraints: Job 1 must start within the time window [20, 80].  \nSequence-dependent setup time constraints: A setup time of 15 time units must be accounted for whenever a machine switches from processing one job to processing a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Tight constraints require intervals of 12 time units or less between consecutive operations, while loose constraints require intervals of 40 time units or more.  \nJob-specific temporal windows: Job 2 has a strict production window where all its operations must start after time 20 and finish before time 450.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal window constraints: All operations of Job 2 must start after time 20 and finish before time 450.  \nInter-job precedence constraints: All operations of Job 3 can only start after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x)\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and finish before time 550.  \nInter-job precedence: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nProduction window constraints for Job 2: All operations of Job 2 must start after time 20 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x)\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components (jobs) to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is specified, along with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: For consecutive operations with tight constraints, the time interval between completion of one operation and the start of the next must not exceed 20 time units.  \nLoose temporal constraints: For consecutive operations with loose constraints, the time interval between the completion of one operation and the start of the next must be at least 40 time units.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and finish before time 550, ensuring the job fits within a designated production window.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed, ensuring precise control over operation-level dependencies between jobs.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 5 and complete before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nProduction window for Job 2: All operations of Job 2 must start after time 5 and must be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 must start after time 10 and be completed before time 550.  \nOperation-specific temporal windows: The end time of the first operation of Job 5 must fall within the time interval [450, 650].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 10 and be completed before time 550, ensuring adherence to its designated production window.  \nOperation-specific temporal windows: The end time of the first operation of Job 5 must fall within the time interval [450, 650], allowing for coordination with downstream processes or quality control requirements.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 450)\n            mdl.add(mdl.end_of(jv) <= 650)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific temporal constraints: All operations of Job 2 must start after time 5 and must be completed before time 550, ensuring the job fits within its designated production window.  \nOperation-level temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 550 and 600, ensuring coordination with downstream processes or quality control checkpoints.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 10 time units or less, while loose constraints require intervals of 35 time units or more.  \nProduction window for Job 2: All operations of Job 2 must start after time 10 and must be completed before time 550.  \nSequence-dependent setup times: A setup time of 25 minutes is required whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nProduction window constraints for Job 2: All operations of Job 2 must start no earlier than time 10 and must finish no later than time 550.  \nSequence-dependent setup time constraints: A setup time of 25 minutes must be added whenever a machine transitions from processing one job to processing a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 has a strict production window, requiring all operations to start after time 10 and finish before time 550.  \nSequence-dependent setup times: A 15-minute setup time is required whenever a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal boundary constraints: All operations of Job 2 must start after time 10 and finish before time 550, ensuring compliance with its production window.  \nSequence-dependent setup constraints: A 15-minute setup time is required whenever the same machine transitions from processing one job to processing a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 40 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine selected.  \nOptional interval variables for machine choices: For each operation, an optional interval variable is defined for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components (jobs) to be processed and the available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is defined, each with its respective processing duration.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 35 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring no resource conflicts.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Tight constraints require time intervals of 12 time units or less between consecutive operations, while loose constraints require time intervals of 25 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 25 time units or more.  \nInter-job precedence: Operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nOperation-specific temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 450 and 700.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nOperation-specific temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 450 and 700.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 450)\n            mdl.add(mdl.end_of(jv) <= 700)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence constraints: Specific precedence relationships between jobs, such as all operations of Job 3 starting only after all operations of Job 2 are completed.  \nOperation-level temporal constraints: Specific timing requirements for certain operations, such as the end time of the first operation of Job 5 falling within a specified time window (e.g., between 550 and 600).  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nOperation-level temporal constraints: The end time of the first operation of Job 5 must fall within the time window between 550 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 10 time units or less, while loose constraints require intervals of 35 time units or more.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: A setup time of 25 minutes is required whenever the same machine transitions from processing one job to processing a different job.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: A setup time of 25 minutes must be added whenever a machine transitions from processing an operation of one job to an operation of a different job.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration and setup time.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence: Job 3 operations can only commence after all operations of Job 2 have been completed.  \nSetup times: A sequence-dependent setup time of 30 minutes is required whenever the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nSetup time constraints: A 30-minute setup time is required when the same machine transitions from processing one job to another, reflecting sequence-dependent machine reconfiguration.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 35 time units or more.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-level temporal constraints: The end time of the first operation of Job 5 must fall within the time window between 550 and 700.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nOperation-level temporal constraint: The end time of the first operation of Job 5 must fall within the time window between 550 and 700.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 550)\n            mdl.add(mdl.end_of(jv) <= 700)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine assigned.  \nOptional interval variables for machine choices: For each operation, an optional interval variable is defined for each candidate machine, representing the execution of the operation on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by the selection of a specific optional interval variable for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components (jobs) to be processed and the available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be executed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is provided, each with its respective processing duration.  \nTemporal constraints: Temporal constraints between consecutive operations in a job are specified as either 'tight' (intervals of 18 time units or less), 'loose' (intervals of 45 time units or more), or 'none' (no specific temporal requirement).  \nFine-grained precedence requirement: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nOperation-level temporal window: The end time of the first operation of Job 5 must fall within the time window between 450 and 700 time units.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring no two operations overlap on the same machine.  \nPrecedence constraints: Operations within a job must be executed in the predefined order, with each operation starting only after the previous one has been completed.  \nTight temporal constraints: When specified between consecutive operations in a job, the time interval between the end of one operation and the start of the next must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations in a job, the time interval between the end of one operation and the start of the next must be at least 45 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed, ensuring a specific dependency between these operations.  \nOperation-level temporal window: The end time of the first operation of Job 5 must fall within the time window between 450 and 700 time units, ensuring alignment with downstream processes or quality control requirements.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing the time when the last operation across all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 450)\n            mdl.add(mdl.end_of(jv) <= 700)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-level temporal constraint: The end time of the first operation of Job 5 must fall within the time window [450, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-level temporal constraint: The end time of the first operation of Job 5 must fall within the time window [450, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 450)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 30 time units is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nSequence-dependent setup time constraint: When the same machine processes operations from different jobs consecutively, a setup time of 30 time units must be added between the completion of the previous operation and the start of the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 25 time units or more.  \nSequence-dependent setup times: A setup time of 15 minutes is required when the same machine processes operations from different jobs consecutively.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 15 minutes is required for reconfiguration.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require a maximum interval of 20 time units, while loose constraints require a minimum interval of 40 time units.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 30 minutes is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nTemporal completion window constraint for Job 5: The end time of the first operation of Job 5 must fall within the interval [500, 600].  \nSequence-dependent setup time constraint: If a machine processes two operations from different jobs consecutively, a setup time of 30 minutes must be added between the end of the first operation and the start of the second operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nCompletion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 30 minutes is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nCompletion window constraint: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nSequence-dependent setup times: When a machine processes operations from different jobs consecutively, a setup time of 30 minutes is required before starting the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Job 1 must commence within the time window [15, 100]. Job 2 must start after time 15 and must be completed before time 500.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time window for Job 1: All operations of Job 1 must commence within the time range [15, 100].  \nRestricted temporal boundaries for Job 2: All operations of Job 2 must start after time 15 and must be completed before time 500.  \nInter-job precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 35 time units or more.  \nJob-specific time windows: Job 1 must commence within a restricted time window between time 25 and time 150.  \nGlobal job temporal boundaries: All operations of Job 2 must start after time 15 and must be completed before time 400.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific time window constraint: Job 1 must commence within the time window between time 25 and time 150.  \nGlobal job temporal boundary constraint: All operations of Job 2 must start after time 15 and must be completed before time 400.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Specific temporal boundaries for certain jobs or operations, such as the required start and end times for Job 1 and Job 2.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time window for Job 1: All operations of Job 1 must start and finish within the interval [15, 120].  \nRestricted time window for Job 2: All operations of Job 2 must start after time 10 and must be completed before time 500.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed, ensuring operation-level dependency between jobs.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction scheduling windows: Job 1 must start between time 15 and time 80. Job 2 must start after time 5 and finish before time 450.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted time window constraints:  \n- Job 1 must start within the time interval [15, 80].  \n- Job 2 must start after time 5 and finish before time 450.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution of the operation on that specific machine with its associated processing duration.  \nMachine assignment: Implicitly determined by the presence of the optional interval variable selected for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components (jobs) to be processed and the number of available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in a specific order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is specified, with each machine having a corresponding processing duration for the operation.  \nTemporal constraints: Temporal constraints between consecutive operations are classified as 'tight' (requiring an interval of 18 time units or less) or 'loose' (requiring an interval of 35 time units or more).  \nSpecific temporal windows: Job 1 must start within the time window [30, 100]. Job 2 must begin after time 5 and be completed before time 500, ensuring it fits within a designated production window.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring that machine resources are not shared simultaneously.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: For consecutive operations with a 'tight' temporal constraint, the time interval between the end of one operation and the start of the next must not exceed 18 time units.  \nLoose temporal constraints: For consecutive operations with a 'loose' temporal constraint, the time interval between the end of one operation and the start of the next must be at least 35 time units.  \nJob-specific temporal window constraints: Job 1 must start within the time window [30, 100]. All operations of Job 2 must start after time 5 and must be completed before time 500.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed, ensuring precise control over the dependency between these operations.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing the time when the last operation across all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.\nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.\nMachine assignment: Implicitly determined by which optional interval variable is selected as present.\n\n2. Parameters and Input Data\nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.\nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.\nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.\nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.\nSpecific temporal windows: Defined for certain jobs to align with production scheduling requirements.\n\n3. Constraints\nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.\nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.\nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.\nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.\nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.\nRestricted start time for Job 1: Job 1 must commence within the time window between 20 and 80 time units.\nStrict temporal boundaries for Job 2: All operations of Job 2 must start after time 15 and be completed before time 550.\nCompletion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and 600.\n\n4. Objective Function\nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.\n\n5. Data Specification\nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:\nFirst line: Two integers representing the number of jobs and number of machines.\nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n            \n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Certain jobs or operations must adhere to specific start or completion time windows:  \n  - Job 1 must commence within the time window [20, 100].  \n  - All operations of Job 2 must start after time 20 and finish before time 400.  \n  - The first operation of Job 5 must end within the time window [500, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific start time constraint: Job 1 must start within the time window [20, 100].  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 20 and finish before time 400.  \nOperation-specific completion window: The first operation of Job 5 must end within the time window [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n            \n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.\nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.\nMachine assignment: Implicitly determined by which optional interval variable is selected as present.\n\n2. Parameters and Input Data\nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.\nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.\nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.\nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.\nSetup times: Sequence-dependent setup times of 15 minutes required when the same machine processes operations from different jobs consecutively.\n\n3. Constraints\nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.\nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.\nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.\nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.\nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.\nRestricted time window for Job 1: The first operation of Job 1 must commence between time 25 and time 100.\nStrict temporal boundaries for Job 2: All operations of Job 2 must start after time 5 and be completed before time 550.\nSetup time constraints: A 15-minute setup time is required when a machine switches from processing an operation of one job to another.\n\n4. Objective Function\nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.\n\n5. Data Specification\nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:\nFirst line: Two integers representing the number of jobs and number of machines.\nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine selected.  \nOptional interval variables for machine choices: For each operation, an optional interval variable is defined for each eligible machine, representing the execution of the operation on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by the selection of the optional interval variable that is marked as present for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components (jobs) to be processed and the available machines in the production environment.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is specified, along with their respective processing durations.  \nTemporal constraints: Tight constraints require a maximum interval of 12 time units between consecutive operations, while loose constraints require a minimum interval of 35 time units.  \nJob-specific time windows:  \n- Job 1 must start within the time window [30, 120].  \n- All operations of Job 2 must start after time 15 and must be completed before time 450.  \nSequence-dependent setup times: When the same machine processes consecutive operations from different jobs, a setup time of 15 time units is required for reconfiguration.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring no resource conflicts.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the completion of the previous operation in the same job.  \nTight temporal constraints: For operations connected by a tight temporal constraint, the time interval between the end of one operation and the start of the next must not exceed 12 time units.  \nLoose temporal constraints: For operations connected by a loose temporal constraint, the time interval between the end of one operation and the start of the next must be at least 35 time units.  \nJob-specific time window constraints:  \n- The first operation of Job 1 must start within the time window [30, 120].  \n- All operations of Job 2 must start after time 15 and must be completed before time 450.  \nSequence-dependent setup time constraints: When a machine processes consecutive operations from different jobs, a setup time of 15 time units must be added between the completion of the first operation and the start of the second operation.  \n\n4. Objective Function  \nMinimize the makespan, defined as the maximum completion time among all jobs, representing the time at which the last operation across all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nTime windows for specific jobs: Job 1 must commence within a time window of [25, 120]. Job 2 must start after time 5 and complete before time 500.  \nSequence-dependent setup times: When a machine processes operations from different jobs consecutively, a setup time of 25 time units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific time window constraints: Job 1 must start within the interval [25, 120]. All operations of Job 2 must start after time 5 and complete before time 500.  \nSequence-dependent setup time constraint: When a machine processes operations from different jobs consecutively, a setup time of 25 time units is required to account for equipment reconfiguration.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time window: Job 1 must commence within a restricted time window between time 15 and time 120.  \nInter-job precedence relationships: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence relationships: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific time window: The first operation of Job 1 must start between time 15 and time 120.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of at most 18 time units, while loose constraints require intervals of at least 25 time units.  \nRestricted time window for Job 1: Job 1 must commence within the time window [15, 150].  \nInter-job precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time window for Job 1: The start time of the first operation of Job 1 must lie within the interval [15, 150].  \nInter-job precedence constraint: All operations of Job 3 must start only after the completion of all operations of Job 2.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 45 time units or more.  \nRestricted time window: Job 1 must commence within the time window [15, 150].  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted time window: Job 1 must commence between time 15 and time 150.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.\nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.\nMachine assignment: Implicitly determined by which optional interval variable is selected as present.\n\n2. Parameters and Input Data\nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.\nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.\nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.\nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.\n\n3. Constraints\nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.\nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.\nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.\nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.\nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.\nTime window constraint for Job 1: The first operation of Job 1 must commence between time 30 and time 80.\nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.\nCompletion constraint for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.\n\n4. Objective Function\nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.\n\n5. Data Specification\nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:\nFirst line: Two integers representing the number of jobs and number of machines.\nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific time window constraint: Job 1 must commence within a restricted time window, specifically between time 30 and time 80.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nOperation-specific completion constraint: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is provided, along with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require time intervals of 18 time units or less, while loose constraints require intervals of 25 time units or more.  \nTime window for Job 1: Job 1 must commence within a restricted time window between time 25 and time 120.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 30 minutes is required to reconfigure the machine.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints within jobs: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nTime window constraint for Job 1: The first operation of Job 1 must start within the time window [25, 120].  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup time constraint: A setup time of 30 minutes is required when the same machine processes operations from different jobs consecutively.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: Job 1 must commence within a fixed time window, specifically between time 20 and time 100.  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 25 units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nRestricted time window for Job 1: The start time of the first operation of Job 1 must be within the interval [20, 100].  \nInter-job precedence constraint: All operations of Job 3 must start only after the last operation of Job 2 has been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 25 units must be added between the two operations.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: Job 1 must commence within the time window [25, 150] to meet scheduling requirements.  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: A setup time of 30 units is required when the same machine processes operations from different jobs consecutively.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nRestricted time window constraint: Job 1 must commence within the time window [25, 150].  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nSequence-dependent setup time constraint: When the same machine processes operations from different jobs consecutively, a setup time of 30 units is required to reconfigure the machine.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time interval [30, 120].  \nCompletion window for Job 5: The end time of the first operation of Job 5 must fall within the interval [500, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time interval [30, 120].  \nCompletion window for Job 5: The end time of the first operation of Job 5 must fall within the interval [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted start time window for Job 1: Job 1 must commence within the time interval [30, 100].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall within the interval [500, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted start time window for Job 1: The first operation of Job 1 must start within the time interval [30, 100].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall within the interval [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time window [15, 100].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall within the time window [500, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time window [15, 100].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall within the time window [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window: Job 1 must commence within the time window [15, 80].  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a 15-minute setup time is required for reconfiguration.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted time window: Job 1 must commence within the time window [15, 80].  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a 15-minute setup time is required for reconfiguration.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine assignment.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution of the operation on that specific machine with its associated processing duration.  \nMachine assignment: Implicitly determined by the selection of the optional interval variable that is marked as present for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components (jobs) to be processed and the number of available machines in the manufacturing environment.  \nJob structure: Each job is defined as a sequence of operations that must be executed in the specified order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is provided, along with the specific processing duration required on each machine.  \nTemporal constraints: Tight temporal constraints require the time interval between consecutive operations to be no more than 10 time units, while loose temporal constraints require the interval to be at least 45 time units.  \nJob-specific time window: Job 1 must start within a restricted time window, specifically between time 30 and time 100.  \nFine-grained precedence relationships: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 30 time units is required to reconfigure the machine.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring that machine resources are not overcommitted.  \nPrecedence constraints: Operations within each job must be executed in the specified order, with each operation starting only after the previous operation in the sequence has completed.  \nTight temporal constraints: For consecutive operations specified with tight constraints, the time interval between the completion of one operation and the start of the next must not exceed 10 time units.  \nLoose temporal constraints: For consecutive operations specified with loose constraints, the time interval between the completion of one operation and the start of the next must be at least 45 time units.  \nJob-specific time window: The first operation of Job 1 must start within the time window of 30 to 100 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When a machine processes operations from two different jobs consecutively, a setup time of 30 time units must be added between the end of the first operation and the start of the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is defined as the maximum completion time among all jobs, representing the time at which the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details, including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: Job 1 must commence within the time interval [20, 80].  \nCompletion window for Job 5: The first operation of Job 5 must end within the time interval [500, 600].  \nSequence-dependent setup times: A setup time of 15 time units is required when the same machine processes operations from different jobs consecutively.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted time window constraint: Job 1 must commence within the time interval [20, 80].  \nCompletion window constraint: The first operation of Job 5 must end within the time interval [500, 600].  \nSequence-dependent setup time constraint: When the same machine processes operations from different jobs consecutively, a setup time of 15 time units is required to reconfigure the equipment.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSpecial time windows: Job 1 must start within the time range [30, 80]. The first operation of Job 5 must finish within the time range [500, 600].  \nSequence-dependent setup times: When consecutive operations of different jobs are processed on the same machine, a setup time of 30 time units is required before the next operation begins.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: For consecutive operations with tight constraints, the time interval between the completion of one operation and the start of the next must not exceed 12 time units.  \nLoose temporal constraints: For consecutive operations with loose constraints, the time interval between the completion of one operation and the start of the next must be at least 35 time units.  \nRestricted start time for Job 1: The first operation of Job 1 must start within the time window [30, 80].  \nRestricted completion time for Job 5: The first operation of Job 5 must finish within the time window [500, 600].  \nSequence-dependent setup times: When consecutive operations from different jobs are scheduled on the same machine, a setup time of 30 time units must be added between the completion of the first operation and the start of the next.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nSequence-dependent setup times: A setup time of 30 minutes is required when the same machine processes two operations from different jobs consecutively.  \nTemporal constraints: Tight constraints require intervals of 10 time units or less between consecutive operations within a job. Loose constraints require intervals of 45 time units or more.  \nRestricted time window for Job 1: The first operation of Job 1 must start between time 20 and time 150.  \nCompletion window for Job 5: The first operation of Job 5 must end between time 500 and time 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted time window constraint: The first operation of Job 1 must commence within the time window of [20, 150].  \nCompletion window constraint: The end time of the first operation of Job 5 must fall within the interval [500, 600].  \nSequence-dependent setup time constraint: If the same machine processes operations from two different jobs consecutively, a setup time of 30 minutes is required before starting the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 45 time units or more.  \nJob-specific temporal boundaries: Job 2 must start after time 20 and must be completed before time 450.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 20 and must be completed before time 450, ensuring the job fits within a designated production window.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 45 time units or more.  \nProduction window for Job 2: All operations of Job 2 must start after time 15 and complete before time 450.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nProduction window for Job 2: All operations of Job 2 must start after time 15 and must be completed before time 450, ensuring they fit within the designated production window.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, irrespective of the machine selected.  \nOptional interval variables for machine choices: For each operation, an optional interval variable is defined for each candidate machine, representing the execution of that operation on the specific machine with its associated processing time.  \nMachine assignment: Implicitly determined by the selection of the optional interval variable corresponding to a specific machine for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components (jobs) to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be executed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is provided, each with its respective processing duration.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints enforce a maximum interval of 18 time units, while loose constraints require a minimum interval of 45 time units.  \nSpecific temporal boundaries for Job 2: All operations of Job 2 must start no earlier than time 10 and must be completed no later than time 500.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring that no two operations overlap on the same machine.  \nPrecedence constraints: Operations within each job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval between the start of the subsequent operation and the end of the preceding operation must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval between the start of the subsequent operation and the end of the preceding operation must be at least 45 time units.  \nSpecific temporal boundaries for Job 2: All operations of Job 2 must start no earlier than time 10 and must finish no later than time 500.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time across all jobs, representing the time at which the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time interval during which each operation of each job is executed, regardless of the machine selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and the number of available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations is provided.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints specify intervals of 12 time units or less, while loose constraints require intervals of 40 time units or more.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: If specified between consecutive operations within a job, the time interval between the end of one operation and the start of the next must not exceed 12 time units.  \nLoose temporal constraints: If specified between consecutive operations within a job, the time interval between the end of one operation and the start of the next must be at least 40 time units.  \nJob-specific temporal constraints for Job 2: All operations of Job 2 must start after time 15 and be completed before time 500, ensuring they fit within a designated production window.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed, reflecting a dependency where Job 3 cannot begin until Job 2 is fully processed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600, ensuring alignment with downstream production processes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 10 and finish before time 450.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nProduction window constraints for Job 2: All operations of Job 2 must start after time 10 and must finish before time 450.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTemporal completion window constraint for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 35 time units or more.  \nProduction window for Job 2: All operations of Job 2 must start after time 5 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nProduction window constraints for Job 2: All operations of Job 2 must start after time 5 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 must start no earlier than time 10 and must finish no later than time 550.  \nInter-job precedence: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nSetup times: When the same machine processes operations from different jobs consecutively, a sequence-dependent setup time of 25 time units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start no earlier than time 10 and must finish no later than time 550.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 25 time units is required before starting the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the flexible job shop environment.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 must start after time 20 and finish before time 400, ensuring it fits within a designated production window.  \nInter-job precedence: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 25 time units is required to account for equipment reconfiguration.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 20 and finish before time 400.  \nInter-job precedence constraints: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 25 time units is required.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Tight constraints require intervals of 20 time units or less between consecutive operations. Loose constraints require intervals of 45 time units or more between consecutive operations.  \nJob-specific temporal boundaries: Job 2 must start after time 10 and finish before time 550.  \nSequence-dependent setup times: When the same machine processes consecutive operations from different jobs, a setup time of 15 time units is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific temporal windows: All operations of Job 2 must start after time 10 and be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup time constraint: When the same machine processes consecutive operations from different jobs, a setup time of 15 time units must be added between operations.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 15 and finish before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal completion window for Job 5: The first operation of Job 5 must end between time 500 and time 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nProduction window for Job 2: All operations of Job 2 must start after time 15 and finish before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window for Job 5: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 is constrained to have all its operations start after time 5 and complete before time 550.  \nOperation-specific temporal windows: The first operation of Job 5 must end between time 500 and time 600.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 5 and complete before time 550.  \nOperation-specific temporal windows: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 must start after time 20 and finish before time 450, ensuring its operations fit within a designated production window.  \nOperation-specific temporal windows: The first operation of Job 5 must end between time 500 and time 600, aligning with downstream production processes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 20 and finish before time 450.  \nOperation-specific temporal windows: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and finish before time 500.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 15-minute setup time is required when the same machine processes operations from different jobs consecutively.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and must be completed before time 500.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a 15-minute setup time is required to reconfigure the equipment.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require time intervals of 18 time units or less, while loose constraints require time intervals of 45 time units or more.  \nJob-specific temporal boundaries: Job 2 must start after time 15 and complete before time 550, ensuring it fits within a designated production window.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a 25-minute setup time is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 15 and must be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required whenever the same machine processes operations from different jobs consecutively.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction windows for specific jobs: Job 2 must start no earlier than time 15 and must complete no later than time 450. Job 5 requires its first operation to end between time 500 and time 600.  \nSequence-dependent setup times: When a machine processes operations from different jobs consecutively, a 30-minute setup time is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal window constraints: All operations of Job 2 must start after time 15 and complete before time 450. The first operation of Job 5 must end within the interval [500, 600].  \nSequence-dependent setup time constraints: When the same machine processes operations from different jobs consecutively, a setup time of 30 minutes is required before starting the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 must start after time 10 and finish before time 450. Job 5 has a specific temporal completion window for its first operation, requiring the end time to fall between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 15 minutes is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 10 and finish before time 450.  \nTemporal completion window for Job 5: The first operation of Job 5 must end between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 15 minutes is required for reconfiguration.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 35 time units or more.  \nJob-specific temporal boundaries: Job 2 must start after time 20 and be completed before time 400, ensuring it fits within a designated production window.  \nOperation-specific temporal windows: For Job 5, the end time of its first operation must fall between time 500 and time 600, ensuring alignment with downstream production processes.  \nSequence-dependent setup times: A setup time of 30 time units is required when the same machine processes operations from different jobs consecutively, reflecting reconfiguration requirements.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 20 and be completed before time 400, ensuring adherence to the designated production window.  \nOperation-specific temporal windows: The end time of the first operation of Job 5 must fall between time 500 and time 600, ensuring alignment with downstream production processes.  \nSequence-dependent setup times: A setup time of 30 time units is required when the same machine processes operations from different jobs consecutively, to account for machine reconfiguration.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.\n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 40 time units or more.  \nInter-job precedence relationships: Dependencies between jobs, such as requiring all operations of Job 3 to commence only after all operations of Job 2 have been completed.  \nFine-grained precedence relationships: Specific dependencies between operations in different jobs, such as requiring the first operation of Job 4 to start only after the second operation of Job 3 has been completed.  \nCompletion time windows: Temporal bounds for specific operations, such as requiring the end time of the first operation of Job 5 to fall between time 500 and time 600.\n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: For consecutive operations within a job where a tight constraint is specified, the time interval between the end of one operation and the start of the next must not exceed 18 time units.  \nLoose temporal constraints: For consecutive operations within a job where a loose constraint is specified, the time interval between the end of one operation and the start of the next must be at least 40 time units.  \nInter-job precedence constraints: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nCompletion time window: The end time of the first operation of Job 5 must fall between time 500 and time 600.\n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.\n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 10 time units or less, while loose constraints require intervals of 35 time units or more.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal completion window: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal completion window: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 10 time units or less, and loose constraints require intervals of 25 time units or more.  \nInter-job precedence constraints: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraints: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal completion window: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence constraints: Dependencies between jobs, where specific jobs or operations must wait for the completion of others before starting.  \nSequence-dependent setup times: When a machine processes operations from different jobs consecutively, a setup time of 15 minutes is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When a machine processes operations from different jobs consecutively, a setup time of 15 minutes is required to reconfigure the equipment.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 30 minutes is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup time constraint: When a machine processes operations from different jobs consecutively, a setup time of 30 minutes is required before processing the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence constraint: Specifies that all operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 25 minutes is required when the same machine processes operations from different jobs consecutively.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a 25-minute setup time is required to reconfigure the equipment.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence relationships: Specific dependencies between jobs, such as requiring all operations of Job 3 to commence only after all operations of Job 2 have been completed.  \nCompletion window: Temporal restriction on the end time of the first operation of Job 5, requiring it to finish between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 15 units is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nCompletion window constraint: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nSetup time constraint: When the same machine processes operations from different jobs consecutively, a setup time of 15 units must be added between the operations.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence relationships: Specific dependencies between jobs, such as Job 3 operations starting only after all operations of Job 2 have been completed.  \nTemporal completion window: For Job 5, the end time of its first operation must fall between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a setup time of 25 minutes is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nFine-grained precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTemporal completion window constraint: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nSequence-dependent setup time constraint: When the same machine processes operations from different jobs consecutively, a setup time of 25 minutes is required before starting the next operation.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution of that operation on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components (jobs) to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is specified, along with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 35 time units or more.  \nInter-job precedence constraints: Specific precedence rules between jobs, such as all operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTemporal completion window: For Job 5, the end time of its first operation must fall between time 500 and time 600.  \nSequence-dependent setup times: When the same machine processes operations from different jobs consecutively, a 25-minute setup time is required to reconfigure the equipment.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nTemporal completion window: The end time of the first operation of Job 5 must fall between time 500 and time 600.  \nSequence-dependent setup times: A 25-minute setup time is required when the same machine processes operations from different jobs consecutively, reflecting reconfiguration requirements.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 45 time units or more.  \nSequence-dependent setup times: A setup time of 25 minutes is required when a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window constraint: The first operation of Job 5 must be completed within the time window between 500 and 600.  \nSequence-dependent setup time constraint: A 25-minute setup time is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSequence-dependent setup times: When transitioning between jobs on the same machine, a setup time of 15 time units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraints:  \n- Tight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \n- Loose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup time constraint: When the same machine transitions from processing one job to another, a setup time of 15 time units must be added to account for machine reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components (jobs) to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 10 time units or less, while loose constraints require intervals of 40 time units or more.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window constraint: The completion time of the first operation of Job 5 must fall within a specified time window between 500 and 600 time units.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 25 time units is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: A 25-minute setup time is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Job 1 must commence within the time interval [15, 150]. Job 2 must start after time 15 and complete before time 450.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nRestricted time window constraints: Job 1 must commence within the interval [15, 150]. Job 2 must start after time 15 and complete before time 450.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n        \nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Job 1 must commence within the time interval [25, 120]. Job 2 must start after time 15 and be completed before time 400.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nRestricted time window constraints: Job 1 must commence within the time interval [25, 120]. Job 2 must start after time 15 and be completed before time 400.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n        \nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Job 1 must commence between time 20 and time 150. Job 2 must start after time 20 and finish before time 450.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time windows: Job 1 must commence within the time interval [20, 150]. Job 2 must start after time 20 and must be completed before time 450.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n        \nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time windows: Specific time window constraints for certain jobs or operations, such as start time, completion time, or operation-specific deadlines.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints within jobs: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific start time constraint: Job 1 must start within the time window [15, 120].  \nJob-specific time window constraint: All operations of Job 2 must start after time 10 and finish before time 550.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nOperation-specific completion constraint: The first operation of Job 5 must complete within the time window [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal window constraints:  \n- Job 1 must commence within the time window between 30 and 120 time units.  \n- All operations of Job 2 must start after time 20 and must be completed before time 500.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained temporal constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in the specified order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Specific jobs and operations are subject to restricted time intervals during which they must start or complete.  \nInter-job precedence constraints: Dependencies exist between certain jobs, requiring all operations of one job to complete before any operation of another job can begin.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nRestricted time window for Job 1: The start time of Job 1 must fall within the interval [25, 120].  \nRestricted production window for Job 2: All operations of Job 2 must start after time 10 and complete before time 400.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nRestricted time window for the first operation of Job 5: The completion time of the first operation of Job 5 must fall within the interval [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.\nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.\nMachine assignment: Implicitly determined by which optional interval variable is selected as present.\n\n2. Parameters and Input Data\nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.\nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.\nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.\nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.\n\n3. Constraints\nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.\nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.\nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.\nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.\nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.\nJob-specific temporal window constraint: Job 1 must commence between time 20 and time 100.\nJob-specific temporal boundaries: All operations of Job 2 must start after time 20 and be completed before time 500.\nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.\nSequence-dependent setup times: A 30-minute setup time is required when a machine transitions from processing one job to another.\n\n4. Objective Function\nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.\n\n5. Data Specification\nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:\nFirst line: Two integers representing the number of jobs and number of machines.\nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Job 1 must commence between time 20 and time 120. Job 2 must start after time 10 and finish before time 500.  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time of 15 time units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal windows: Job 1 must commence within the time interval [20, 120]. Job 2 must start after time 10 and finish before time 500.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 15 time units is required to account for reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows for specific jobs: Job 1 must start within the time interval [15, 80]. Job 2 must start after time 15 and be completed before time 450.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 30-minute setup time is required to account for reconfiguration, cleaning, or tool changes.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 are completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nRestricted time window constraints: Job 1 must start within the interval [15, 80]. Job 2 must start after time 15 and finish before time 450.  \nInter-job precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: A setup time of 30 minutes is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific temporal constraints:  \n- Job 1 must commence within the time window between 25 and 150.  \n- All operations of Job 2 must start after time 20 and be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nJob-specific operation completion constraint: The first operation of Job 5 must be completed within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific time window constraint for Job 1: The first operation of Job 1 must start within the time window between 30 and 80.  \nProduction window constraint for Job 2: All operations of Job 2 must start after time 5 and must be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window constraint for Job 5: The first operation of Job 5 must be completed within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSpecial time windows:  \n- Job 1 must start within the time window between 20 and 120 time units.  \n- Job 2 must start no earlier than time 5 and finish no later than time 450.  \n- The first operation of Job 5 must complete within the time window between 500 and 600 time units.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific time windows:  \n- Job 1 must commence within the time window between 20 and 120 time units.  \n- All operations of Job 2 must start no earlier than time 5 and be completed no later than time 450.  \n- The first operation of Job 5 must complete within the time window between 500 and 600 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time windows: Job 1 must commence within the time window [30, 150]. Job 2 must start after time 15 and complete before time 550.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 25 minutes is required whenever the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific time window constraints:  \n- Job 1 must commence within the time window [30, 150].  \n- Job 2 must start after time 15 and must be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 25 minutes is required whenever the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time windows: Job 1 must commence within the time window [20, 100]. Job 2 must start after time 15 and be completed before time 400.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 15 time units is required when a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific time windows: Job 1 must commence within the time window [20, 100]. Job 2 must start after time 15 and be completed before time 400.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 15 time units is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSpecial temporal windows: Job 1 must start within the time window [15, 150]. Job 2 must start after time 20 and be completed before time 550.  \nSequence-dependent setup times: A setup time of 25 minutes is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nSpecial temporal window constraints: Job 1 must start within the time window [15, 150]. Job 2 must start after time 20 and be completed before time 550.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time of 25 minutes is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Job 1 must start between time 15 and time 100. Job 2 must start after time 15 and finish before time 450. The first operation of Job 5 must complete within the time window between 500 and 600.  \nSequence-dependent setup times: A setup time of 25 minutes is required when a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific temporal windows: Job 1 must commence within the time window between time 15 and time 100. All operations of Job 2 must start after time 15 and finish before time 450. The first operation of Job 5 must complete within the time window between 500 and 600.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 25 minutes is required to account for reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows:  \n- Job 1 must start within the time window [25, 100].  \n- All operations of Job 2 must start after time 5 and complete before time 400.  \n- The first operation of Job 5 must complete within the time window [500, 600].  \nSequence-dependent setup times: A setup time of 15 time units is required whenever the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted time windows:  \n- Job 1 must start within the time window [25, 100].  \n- All operations of Job 2 must start after time 5 and complete before time 400.  \n- The first operation of Job 5 must complete within the time window [500, 600].  \nSequence-dependent setup times: A setup time of 15 time units is required whenever the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require a maximum interval of 18 time units, while loose constraints require a minimum interval of 45 time units.  \nTime window constraints: Specific jobs and operations are subject to additional temporal constraints:  \n- Job 1 must commence within the time window [15, 150].  \n- All operations of Job 2 must start after time 15 and finish before time 550.  \n- The first operation of Job 5 must complete within the time window [500, 600].  \nSequence-dependent setup times: A setup time of 25 minutes is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nTime window constraints:  \n- Job 1 must start within the time window [15, 150].  \n- All operations of Job 2 must start after time 15 and finish before time 550.  \n- The first operation of Job 5 must complete within the time window [500, 600].  \nSequence-dependent setup times: A setup time of 25 minutes is required between consecutive operations on the same machine when transitioning from one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time range [15, 150].  \nInter-job precedence constraints: Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window [500, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: For consecutive operations within a job specified as 'tight', the time interval between them must not exceed 20 time units.  \nLoose temporal constraints: For consecutive operations within a job specified as 'loose', the time interval between them must be at least 25 time units.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time window between time 15 and time 150.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nTime window for Job 1: The first operation of Job 1 must start within the time window [15, 100].  \nInter-job precedence constraints: Operations of Job 3 can only commence after all operations of Job 2 are completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window for Job 5: The completion time of the first operation of Job 5 must fall within the time window [500, 600].  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nTime window for Job 1: The first operation of Job 1 must start within the time window [15, 100].  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window for Job 5: The completion time of the first operation of Job 5 must fall within the time window [500, 600].  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Job 1 must commence within a restricted time window, specifically between time 15 and time 100.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal constraints: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal window: Job 1 must start within the time window between time 15 and time 100.  \nInter-job precedence constraint: All operations of Job 3 must begin only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 35 time units or more.  \nJob-specific time window: Job 1 must commence within a restricted time window, specifically between time 30 and time 150.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 15-minute setup time is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific time window constraint: Job 1 must commence within the time window of 30 to 150 time units.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 15 minutes must be added before the next operation begins.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 40 time units or more.  \nTime window for Job 1: Job 1 must commence within the time window between 25 and 80 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 15 time units is required when a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations within a job, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations within a job, the time interval must be at least 40 time units.  \nTime window constraint for Job 1: The start time of the first operation of Job 1 must lie within the interval [25, 80].  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 15 time units must be added between the two operations.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob time window: Job 1 must commence within a restricted time window between time 30 and time 80.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 25-minute setup time is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob time window constraint: Job 1 must commence within the time window of 30 to 80 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time windows: Job 1 must commence within the time window between time 30 and time 80. The first operation of Job 5 must finish within the time window between time 500 and 600.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 30-minute setup time is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nRestricted time window constraints: Job 1 must commence within the time window between time 30 and time 80. The first operation of Job 5 must finish within the time window between time 500 and 600.  \nInter-job precedence constraint: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 30-minute setup time is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nTime windows: Specific time intervals within which certain operations or jobs must commence or finish.  \nSequence-dependent setup times: Transition times of 30 minutes required when a machine switches from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific time window constraints: Job 1 must commence within the time window between 15 and 100 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nOperation-specific time window constraints: The first operation of Job 5 must finish within the time window between 500 and 600 time units.  \nSequence-dependent setup time constraints: A setup time of 30 minutes is required whenever a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time windows: Specific jobs or operations are restricted to start or complete within predefined time windows to meet production scheduling requirements.  \nInter-job precedence: Certain jobs can only commence after the completion of other jobs, reflecting dependencies in the manufacturing process.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time is incurred to account for reconfiguration or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific time window constraints:  \n- Job 1 must start within the time window [15, 100].  \n- The first operation of Job 5 must complete within the time window [500, 600].  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nSequence-dependent setup times: A setup time of 25 time units is required whenever the same machine transitions between operations of different jobs.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution of the operation on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 45 time units or more.  \nRestricted start time window for Job 1: The first operation of Job 1 must start within the time window between 15 and 80 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nCompletion time window for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: A 30-time-unit setup time is required when a machine transitions from processing one job to another, accounting for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted start time window for Job 1: The first operation of Job 1 must start within the time window between 15 and 80 time units.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nCompletion time window for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: A 30-time-unit setup time is required when a machine transitions from processing one job to another, accounting for machine reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \nSequence-dependent setup times: Interval variables representing the setup time required when a machine transitions from processing one job to another.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the interval [25, 80].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nCompletion time window for Job 5: The first operation of Job 5 must be completed within the interval [500, 600].  \nSequence-dependent setup times: A setup time of 30 minutes is required whenever a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the interval [25, 80].  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nCompletion time window for Job 5: The first operation of Job 5 must be completed within the interval [500, 600].  \nSequence-dependent setup times: A setup time of 30 minutes is required whenever a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 25 time units or more.  \nSpecial temporal windows: Job 1 must commence within the restricted time window between time 30 and time 80. Job 5 has a temporal constraint on its initial operation, requiring the completion time of the first operation to fall within the time window between 500 and 600.  \nSequence-dependent setup times: A setup time of 30 time units is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nTemporal windows: Job 1 must commence within the time interval [30, 80]. The completion time of the first operation of Job 5 must fall within the time interval [500, 600].  \nSequence-dependent setup times: A setup time of 30 time units is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nProduction window constraint for Job 2: All operations of Job 2 must start after time 20 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 10 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTime window constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nProduction window for Job 2: All operations of Job 2 must start after time 10 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTime window constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nDesignated production window for Job 2: All operations of Job 2 must start after time 15 and be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nDesignated production window for Job 2: All operations of Job 2 must start after time 15 and be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Job 2 must start after time 15 and complete before time 550.  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 15-minute setup time is required when a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal windows: All operations of Job 2 must start after time 15 and complete before time 550.  \nInter-job precedence: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 15-minute setup time is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal window: Job 2 must start after time 15 and complete before time 550.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time of 25 minutes is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal window: All operations of Job 2 must start after time 15 and complete before time 550.  \nInter-job precedence constraints: All operations of Job 3 can only begin after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required whenever the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nStrict temporal boundaries: Job 2 must start after time 20 and complete before time 450.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nStrict temporal boundaries: All operations of Job 2 must start after time 20 and complete before time 450.  \nInter-job precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window constraints for Job 2: All operations of Job 2 must start after time 10 and be completed before time 550.  \nSequence-dependent setup times: A setup time of 15 minutes is required when the same machine transitions from one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nProduction window constraints for Job 2: All operations of Job 2 must start after time 10 and must be completed before time 550.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \nSequence-dependent setup times: A setup time of 15 minutes is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSpecial temporal windows: Job 2 must start after time 20 and complete before time 400. Additionally, the first operation of Job 5 must complete within the time window of [500, 600].  \nFine-grained precedence relationships: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSetup times: Sequence-dependent setup times of 30 minutes are required whenever a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nSpecial temporal window constraints: All operations of Job 2 must start after time 20 and complete before time 400. The first operation of Job 5 must complete within the time window of [500, 600].  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSetup time constraint: A sequence-dependent setup time of 30 minutes is required whenever a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 400)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and be completed before time 450.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window for Job 5: The completion time of the first operation of Job 5 must fall within the time interval [500, 600].  \nSequence-dependent setup times: A setup time of 15 minutes is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nProduction window constraint for Job 2: All operations of Job 2 must start after time 20 and be completed before time 450.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nTemporal window constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time interval [500, 600].  \nSequence-dependent setup times: A setup time of 15 minutes is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nInter-job precedence dependencies: Specific dependencies between jobs, such as one job's operations being allowed to start only after another jobs operations have completed.  \nFine-grained precedence dependencies: Specific dependencies between operations across jobs, such as one operation of a job starting only after a specific operation of another job has finished.  \nSetup times: Sequence-dependent setup times when transitioning between jobs on the same machine.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations in a job, the time interval between the completion of one operation and the start of the next must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations in a job, the time interval between the completion of one operation and the start of the next must be at least 45 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: When transitioning between jobs on the same machine, a 30-minute setup time is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of machine assignment.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 45 time units or more.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window constraints: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 25-minute setup time is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time of 25 minutes must be added to account for machine reconfiguration, cleaning, or tool changes.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 20 time units or less, while loose constraints require intervals of 25 time units or more.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 are completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window constraints: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \nSequence-dependent setup times: A setup time of 30 minutes is required whenever the same machine transitions from processing one job to another, accounting for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal window constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 30 minutes is required before the next operation can begin.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time windows: Job 1 must commence within a time window between 30 and 80. Job 2 must start after time 5 and be completed before time 550.  \nInter-job precedence relationships: All operations of Job 3 must commence after all operations of Job 2 have been completed.  \nFine-grained precedence relationships: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific time windows: The first operation of Job 5 must be completed within the time window between 500 and 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 25 time units.  \nJob-specific time window constraints: Job 1 must commence within the time window between 30 and 80. Job 2 must start after time 5 and must be completed before time 550.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific time window constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 30)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing its execution on that specific machine with the corresponding processing duration.  \nMachine assignment: Implicitly determined by selecting which optional interval variable is present for each operation.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Specifies the total number of aircraft skin components to be scheduled and the machines available for processing in the shop.  \nJob structure: Each job is composed of a predefined sequence of operations to be executed in order.  \nMachine eligibility and processing times: For every operation, a set of candidate machines and their respective processing durations are specified, allowing flexible machine selection.  \nTemporal constraints: Tight constraints require consecutive operations within a job to start within an interval of 18 time units or less; loose constraints require consecutive operations within a job to start at least 25 time units apart.  \nSpecial job constraints:  \n- Job 1 must commence within the bounded time window of 15 to 120 time units.  \n- Job 2 must operate entirely within the restricted time interval, such that no operation starts before time 5 and all operations must be completed by time 500.  \nInter-job precedence requirement: Job 3 can only begin execution after Job 2 has been fully processed.  \nFine-grained precedence requirement: The second operation of Job 3 must complete before the first operation of Job 4 can begin.  \nJob-specific temporal restriction: The completion time of the first operation of Job 5 must fall within the interval 500 to 600 time units.  \n\n3. Constraints  \nAlternative constraint: Each operation must be processed by exactly one machine from its set of eligible machines.  \nNo-overlap constraint: Each machine can perform at most one operation at any given moment, enforcing exclusive use of resources.  \nPrecedence constraints:  \n- Operations within a job must be executed sequentially, with each operation starting only after the previous operation has finished.  \n- Inter-job precedence constraint: All operations of Job 3 can commence only once all operations of Job 2 have completed.  \nFine-grained precedence constraint: The first operation of Job 4 can only start after the second operation of Job 3 has been completed, precisely controlling dependencies between operations of different jobs.  \nTemporal constraints:  \n- Tight temporal constraints: For consecutive operations in jobs where specified, the start interval between operations must not exceed 18 time units.  \n- Loose temporal constraints: For consecutive operations in jobs where specified, the start interval between operations must be at least 25 time units.  \nSpecial time window constraints:  \n- Job 1 must begin execution within the bounded start interval of 15 and 120 time units.  \n- All operations of Job 2 must start no earlier than time 5 and must be completed no later than time 500.  \nJob-specific completion constraint: The completion time of the first operation of Job 5 must fall between 500 and 600 time units.  \n\n4. Objective Function  \nMinimize the makespan, defined as the maximum completion time across all jobs, representing when the last operation of all scheduled jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Tight constraints require time intervals of 20 time units or less between consecutive operations within a job. Loose constraints require time intervals of 35 time units or more between consecutive operations.  \nJob-specific temporal windows:  \n- Job 1 must commence within the time window between 20 and 150.  \n- Job 2 must start after time 10 and finish before time 450.  \nInter-job precedence constraints: Operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal windows: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: Consecutive operations within a job with tight constraints must have a time interval of 20 time units or less.  \nLoose temporal constraints: Consecutive operations within a job with loose constraints must have a time interval of 35 time units or more.  \nJob-specific temporal constraints:  \n- Job 1 must start within the time window between 20 and 150.  \n- All operations of Job 2 must start after time 10 and finish before time 450.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal constraints: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor lops in machine_operations:\n    mdl.add(mdl.no_overlap(lops))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSequence-dependent setup times: A setup time of 25 minutes is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nRestricted time window for Job 1: The first operation of Job 1 must start between time 20 and time 100.  \nProduction window for Job 2: All operations of Job 2 must start after time 20 and finish before time 500.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 20)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution of that operation on the specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total number of aircraft skin components (jobs) to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines is provided, along with their corresponding processing durations.  \nTemporal constraints: Temporal constraints between consecutive operations within each job are categorized as 'tight' (time interval  10 units), 'loose' (time interval  45 units), or 'none' (no restriction).  \nJob-specific time windows:  \n- Job 1 must commence within the time range [25, 100].  \n- Job 2 must start after time 5 and finish before time 550.  \nInter-job precedence constraints:  \n- All operations of Job 3 can only start after all operations of Job 2 have been completed.  \nFine-grained precedence constraints:  \n- The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time of 25 units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 10 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-specific time windows:  \n- Job 1 must start within the time range [25, 100].  \n- Job 2 must start after time 5 and finish before time 550.  \nInter-job precedence constraints: All operations of Job 3 can only start after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A setup time of 25 units is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint type ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 10)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 100)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 550)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific time windows:  \n- Job 1 must commence within a restricted time window between time 25 and time 150.  \n- Job 2 must start after time 15 and be completed before time 450.  \nInter-job precedence constraints:  \n- All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints:  \n- The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: For consecutive operations with a 'tight' constraint, the time interval must not exceed 18 time units.  \nLoose temporal constraints: For consecutive operations with a 'loose' constraint, the time interval must be at least 45 time units.  \nJob-specific time windows:  \n- Job 1 must start within the time window [25, 150].  \n- All operations of Job 2 must start after time 15 and finish before time 450.  \nInter-job precedence constraint: All operations of Job 3 must start only after the completion of all operations of Job 2.  \nFine-grained precedence constraint: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nSequence-dependent setup times: A 25-minute setup time is required whenever a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nSequence-dependent setup times: When a machine transitions from processing one job to another, a setup time of 30 time units is required to account for machine reconfiguration, cleaning, or tool changes.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 45 time units.  \nJob-level temporal constraint: The first operation of Job 1 must start within the time window between time 25 and time 120.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal constraint: The completion time of the first operation of Job 5 must fall within the time window between time 500 and time 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 45)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time window between 15 and 80 time units.  \nInter-job precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: A 30-minute setup time is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 20 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nRestricted time window for Job 1: The first operation of Job 1 must start within the time window between 15 and 80 time units.  \nInter-job precedence constraint: All operations of Job 3 must commence only after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nTemporal constraint for Job 5: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600 time units.  \nSequence-dependent setup times: A 30-minute setup time is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 20)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 80)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 12 time units or less, while loose constraints require intervals of 40 time units or more.  \nJob-specific temporal windows: Job 2 must start after time 10 and be completed before time 450.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 are completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 is completed.  \nOperation-specific temporal windows: The first operation of Job 5 must complete within the time window between 500 and 600.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a setup time of 30 time units is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal windows: All operations of Job 2 must start after time 10 and be completed before time 450.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 are completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 is completed.  \nOperation-specific temporal windows: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \nSequence-dependent setup times: A setup time of 30 time units is required whenever the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [30 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal boundaries: Job 2 must start after time 5 and complete before time 500.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nInitial operation temporal constraint: The first operation of Job 5 must complete within the time window [500, 600].  \nSequence-dependent setup times: A setup time of 25 minutes is required when a machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations within a job, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations within a job, the time interval must be at least 25 time units.  \nJob-specific temporal boundaries: All operations of Job 2 must start after time 5 and complete before time 500.  \nInter-job precedence constraints: All operations of Job 3 must start only after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start only after the second operation of Job 3 has been completed.  \nInitial operation temporal constraint: The first operation of Job 5 must complete within the time window [500, 600].  \nSequence-dependent setup times: A setup time of 25 minutes is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 25)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals. Tight constraints require intervals of 18 time units or less, while loose constraints require intervals of 35 time units or more.  \nJob-specific temporal windows: Job 2 must start after time 5 and complete before time 500.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal windows: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \nSequence-dependent setup times: When the same machine transitions from processing one job to another, a 25-minute setup time is required.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific temporal windows: All operations of Job 2 must start after time 5 and complete before time 500.  \nInter-job precedence constraints: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraints: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal windows: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \nSequence-dependent setup times: A 25-minute setup time is required when a machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution on that specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nSequence-dependent setup times: A setup time of 25 minutes is required when the same machine transitions from processing one job to another.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 12 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 35 time units.  \nJob-specific time window constraints:  \n- Job 1 must commence within the time window between 25 and 120.  \n- All operations of Job 2 must start after time 10 and be completed before time 500.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific time window constraint: The completion time of the first operation of Job 5 must fall within the time window between 500 and 600.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 12)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 35)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 25)\n            mdl.add(mdl.start_of(jv) <= 120)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 10)\n            mdl.add(mdl.end_of(jv) <= 500)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [25 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nInterval variables for each operation: Represent the time range during which each operation of each job is executed, regardless of which machine is selected.  \nOptional interval variables for machine choices: For each operation, there is an optional interval variable for each candidate machine, representing the execution of that operation on the specific machine with its corresponding processing duration.  \nMachine assignment: Implicitly determined by which optional interval variable is selected as present.  \n\n2. Parameters and Input Data  \nNumber of jobs and machines: Total count of aircraft skin components to be processed and available machines in the shop.  \nJob structure: Each job consists of a predefined sequence of operations that must be processed in order.  \nMachine eligibility and processing times: For each operation, a set of candidate machines with their respective processing durations.  \nTemporal constraints: Constraint types ('tight', 'loose', or 'none') between consecutive operations within each job, defining required time intervals.  \nJob-specific temporal windows: Specific time windows within which certain jobs or operations must start or finish.  \nInter-job precedence constraints: Dependencies between operations in different jobs, dictating the order in which operations can commence.  \nSequence-dependent setup times: Time required for a machine to transition between processing different jobs.  \n\n3. Constraints  \nAlternative constraint: Each operation must be assigned to exactly one machine from its set of candidate machines.  \nNo-overlap constraint: Each machine can process at most one operation at any given time, ensuring disjunctive resource usage.  \nPrecedence constraints: Operations within a job must be executed sequentially, with each operation starting only after the previous one has completed.  \nTight temporal constraints: When specified between consecutive operations, the time interval must not exceed 18 time units.  \nLoose temporal constraints: When specified between consecutive operations, the time interval must be at least 40 time units.  \nJob-specific temporal constraints:  \n- Job 1 must commence within the time window [15, 150].  \n- Job 2 must start after time 5 and must be completed before time 450.  \nInter-job precedence constraint: All operations of Job 3 can only commence after all operations of Job 2 have been completed.  \nFine-grained precedence constraint: The first operation of Job 4 must start after the second operation of Job 3 has been completed.  \nOperation-specific temporal constraint: The completion time of the first operation of Job 5 must fall within the time window [500, 600].  \nSequence-dependent setup times: A 15-minute setup time is required when the same machine transitions from processing one job to another.  \n\n4. Objective Function  \nMinimize the makespan, which is the maximum completion time among all jobs, representing when the last operation of all jobs finishes.  \n\n5. Data Specification  \nThe input file \"/data/fjsp_location_newdataset_1.fjs\" follows this format:  \nFirst line: Two integers representing the number of jobs and number of machines.  \nSubsequent lines (one per job): Number of operations, followed by operation details including the number of candidate machines, machine-duration pairs (machine ID and processing time), and temporal constraint types ('tight', 'loose', or 'none') after each operation.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\nimport os\n\nfilename = os.path.dirname(os.path.abspath(__file__)) + \"/data/fjsp_location_newdataset_1.fjs\"\nwith open(filename, \"r\") as file:\n    num_jobs, num_machines = [int(v) for v in file.readline().split()]\n    job_list = [[v if v in ['tight', 'loose', 'none'] else int(v) for v in file.readline().split()] for i in\n                 range(num_jobs)]\n\nJOBS = []\nCONSTRAINTS = []\n\nfor job_line in job_list:\n    num_steps = job_line.pop(0)\n    job = []\n    constraints = []\n    for stp in range(num_steps):\n        num_choices = job_line.pop(0)\n        choices = []\n        for c in range(num_choices):\n            m = job_line.pop(0)\n            d = job_line.pop(0)\n            choices.append((m - 1, d))\n        constraint = job_line.pop(0)\n        job.append(choices)\n        constraints.append(constraint)\n    JOBS.append(job)\n    CONSTRAINTS.append(constraints)\n\nmdl = CpoModel()\n\njob_number = {}\nall_operations = []\nmachine_operations = [[] for m in range(num_machines)]\njob_operations = []\n\nfor jx, job in enumerate(JOBS):\n    op_vars = []\n    for ox, op in enumerate(job):\n        choice_vars = []\n        for cx, (m, d) in enumerate(op):\n            cv = mdl.interval_var(name=\"J{}_O{}_C{}_M{}\".format(jx, ox, cx, m), optional=True, size=d)\n            job_number[cv.get_name()] = jx\n            choice_vars.append(cv)\n            machine_operations[m].append(cv)\n\n        jv = mdl.interval_var(name=\"J{}_O{}\".format(jx, ox))\n        mdl.add(mdl.alternative(jv, choice_vars))\n        op_vars.append(jv)\n\n        if ox > 0:\n            mdl.add(mdl.end_before_start(op_vars[ox - 1], op_vars[ox]))\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'tight':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) <= 18)\n        if ox > 0 and CONSTRAINTS[jx][ox - 1] == 'loose':\n            mdl.add(mdl.start_of(op_vars[ox]) - mdl.end_of(op_vars[ox - 1]) >= 40)\n\n        if jx == 0 and ox == 0:\n            mdl.add(mdl.start_of(jv) >= 15)\n            mdl.add(mdl.start_of(jv) <= 150)\n\n        if jx == 1:\n            mdl.add(mdl.start_of(jv) >= 5)\n            mdl.add(mdl.end_of(jv) <= 450)\n\n        if jx == 4 and ox == 0:\n            mdl.add(mdl.end_of(jv) >= 500)\n            mdl.add(mdl.end_of(jv) <= 600)\n\n    all_operations.extend(op_vars)\n    job_operations.append(op_vars)\n\nif len(job_operations) > 2:\n    job2_ops = job_operations[1]\n    job3_ops = job_operations[2]\n    if job2_ops and job3_ops:\n        mdl.add(mdl.start_of(job3_ops[0]) >= mdl.end_of(job2_ops[-1]))\n\nif len(job_operations) > 3:\n    job3_ops = job_operations[2]\n    job4_ops = job_operations[3]\n    if len(job3_ops) >= 2 and job4_ops:\n        mdl.add(mdl.end_before_start(job3_ops[1], job4_ops[0]))\n\nfor m in range(num_machines):\n    ops = machine_operations[m]\n    machine_seq = mdl.sequence_var(ops, types=[job_number[op.get_name()] for op in ops], name=f\"M{m}_Seq\")\n    setup_time = [\n        [15 if j1 != j2 else 0 for j2 in range(num_jobs)]\n        for j1 in range(num_jobs)\n    ]\n    transition_matrix = mdl.transition_matrix(setup_time, name=f\"SetupTime_M{m}\")\n    mdl.add(mdl.no_overlap(machine_seq, transition_matrix))\n\nmdl.add(mdl.minimize(mdl.max([mdl.end_of(op) for op in all_operations])))\n\nprint(\"Solving model....\")\nmsol = mdl.solve(TimeLimit=30)\n\nif msol:\n    print(\"Solution found.\")\n    print(\"Objective value (Makespan):\", msol.get_objective_value())\n\n    print(\"=== Machine Schedules ===\")\n    for m in range(num_machines):\n        print(f\"\\nMachine M{m}:\")\n        machine_schedule = []\n        for v in machine_operations[m]:\n            itv = msol.get_var_solution(v)\n            if itv.is_present():\n                jn = job_number[v.get_name()]\n                machine_schedule.append((itv.start, itv.end, f\"J{jn}\"))\n        machine_schedule.sort(key=lambda x: x[0])\n        for s, e, jn in machine_schedule:\n            print(f\"  {jn:<5} Start: {s:<5}  End: {e:<5}  Duration: {e - s}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery pack system during each time period.\n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total count of series branches in the battery pack system.  \nNumber of time periods: Total number of discrete time periods over which the system is optimized.  \nCell nominal voltage: Voltage rating of each individual battery module when activated.  \nMaximum current per module: The upper limit of current that can safely flow through any activated battery module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] containing the capacity values of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] containing the internal resistance values of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] containing the voltage values of each battery module at each time period.\n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack system during each time period must strictly remain within the preset safe range defined by system requirements.  \nCurrent threshold constraint: The current flowing through any activated battery module during each time period must not exceed its maximum safety threshold to prevent overheating and degradation.  \nParallel module consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nActivation-deactivation constraint: A battery module may only contribute to the total output voltage and current if it is activated during the respective time period.  \nEnergy flow constraints: The current and voltage values of activated modules must adhere to electrochemical and electrical laws, ensuring compatibility between module properties (capacity, resistance, and voltage) and system-level requirements.\n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.\n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nModule activation variables: Binary decision variables indicating whether each battery module is activated or deactivated during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery pack during each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of parallel-connected battery modules in the system.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nNominal voltage: The nominal voltage of each battery module.  \nMaximum current: The maximum allowable current for each battery module.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] indicating the capacity of each module during each time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] indicating the internal resistance of each module during each time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] indicating the actual voltage of each module during each time period.  \n\n3. Constraints  \nVoltage output constraint: The total output voltage of the battery pack during each time period must remain within a predefined safe range to prevent damage to connected loads.  \nCurrent limit constraint: The current flowing through each activated battery module during each time period must not exceed the module's maximum allowable current.  \nParallel connection consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nWear-leveling constraint: The total number of activations for any two battery modules across all time periods must differ by no more than 2 to ensure equitable utilization and promote uniform degradation.  \nActivation-consistency constraint: A module can only contribute to the output voltage and current of the system if it is activated during the corresponding time period.  \nEnergy conservation constraint: The total energy loss of each module is determined by its internal resistance and current flow during activation periods, and its recovery effects during deactivation periods.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal voltage of each module, and maximum allowable current per module.  \nSubsequent lines: Three flattened 3D matrices (C for capacity, R for resistance, V for voltage) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary variables indicating whether each battery module in the matrix is activated (1) or deactivated (0) during each time period.  \nCurrent variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage variables: Continuous variables representing the total output voltage of the battery pack system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: The total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: The total number of series-connected branches in the battery matrix.  \nNumber of time periods: The total number of discrete time periods over which the battery pack operation is scheduled.  \nNominal cell voltage: The nominal voltage of each battery module.  \nMaximum current per module: The maximum allowable current for any individual battery module to ensure safe operation.  \nCapacity matrix (C): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the capacity of a specific battery module during a specific time period.  \nResistance matrix (R): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific battery module during a specific time period.  \nVoltage matrix (V): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage of a specific battery module during a specific time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack system during each time period must remain within the predefined safe range to prevent damage to connected loads. This is computed as the sum of the voltages of all series branches, with each branchs voltage determined by the activated modules in that branch.  \n\nCurrent limit constraint: The current flowing through each activated battery module during each time period must not exceed its maximum allowable current to prevent overheating and degradation.  \n\nParallel connection consistency constraint: At any given time period, the number of activated battery modules in parallel across all series branches must be equal to ensure balanced load distribution.  \n\nSpatial activation constraint: Within any 2x2 submatrix of battery modules, no more than 2 modules can be activated simultaneously during any time period to prevent localized thermal hotspots and ensure efficient thermal management.  \n\nEnergy flow constraint: The activation and deactivation of battery modules must respect energy flow dynamics, considering the electrochemical recovery effects during deactivation periods and internal resistance losses during activation periods.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods. This includes both internal resistance losses during activation and electrochemical recovery effects during deactivation, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- The first line contains five integers or floating-point values: number of parallel modules, number of series columns, number of time periods, nominal cell voltage, and maximum current per module.  \n- The subsequent lines contain three flattened matrices (C, R, and V) of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], listed row by row. Each matrix entry corresponds to the respective parameter (capacity, resistance, or voltage) for a specific module at a specific time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each battery module: Binary decision variables indicating whether a specific battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery pack system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods for which the battery pack operation is scheduled.  \nCell nominal voltage: Nominal voltage of each individual battery module.  \nMaximum current per module: Maximum allowable current through each battery module to ensure safe operation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack system must remain within a predefined safe range during all time periods to prevent damage to connected loads.  \nCurrent safety constraints: The current flowing through any activated battery module must not exceed its maximum safety threshold during any time period to avoid overheating and degradation.  \nParallel module consistency constraints: At any given moment, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution across the system.  \nFault exclusion constraints: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated during any time period.  \nEnergy balance constraints: The total energy flow within the system must account for internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules, which includes both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five parameters representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_voltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether a specific battery module is active (1) or inactive (0) during each time period.  \nState change variables: Binary decision variables representing whether the state of a battery module changes (from active to inactive or vice versa) between consecutive time periods.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery system during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nUsage count variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack configuration.  \nNumber of time periods: Total number of discrete time periods over which the system is scheduled.  \nNominal voltage per module: Voltage output of an individual battery module when active.  \nMaximum current per module: Maximum allowable current through any active battery module to ensure safety.  \nCapacity matrix (C): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the energy capacity of each module at each time period.  \nResistance matrix (R): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each module at each time period.  \nVoltage matrix (V): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage output of each module at each time period when active.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system during each time period must remain within the safe operational range defined by the connected load requirements.  \n\\[ \\text{V}_{\\text{min}} \\leq \\sum_{\\text{columns}} \\text{V}_{\\text{total}}^{t} \\leq \\text{V}_{\\text{max}} \\]  \nCurrent safety constraints: The current flowing through any activated battery module during each time period must not exceed the module's maximum allowable current.  \n\\[ \\text{I}_{\\text{module}}^{t} \\leq \\text{I}_{\\text{max}} \\]  \nLoad balancing constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be consistent to ensure balanced load distribution.  \n\\[ \\forall t, \\forall \\text{columns}, \\text{NumParallel}_{\\text{active}}^{t} = \\text{constant} \\]  \nWear-leveling constraints: The total number of activations for any two battery modules across all time periods must differ by no more than 2 to promote uniform degradation and extend system lifespan.  \n\\[ |\\text{Usage}_{i} - \\text{Usage}_{j}| \\leq 2, \\forall i, j \\]  \nOperational stability constraints: The maximum number of state changes (activations or deactivations) across all battery modules between consecutive time periods must not exceed 6 to minimize mechanical stress and reduce system complexity.  \n\\[ \\sum_{\\text{modules}} \\text{StateChange}_{\\text{module}}^{t} \\leq 6 \\]  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation periods and recovery effects during deactivation periods. The objective function is defined as:  \n\\[ \\text{Minimize} \\, \\sum_{t} \\sum_{\\text{modules}} \\left( \\text{R}_{\\text{module}}^{t} \\cdot (\\text{I}_{\\text{module}}^{t})^2 + \\text{RecoveryLoss}_{\\text{module}}^{t} \\right) \\]  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal voltage per module, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided as flattened arrays row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each module: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery pack during each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative number of activations for each module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery matrix configuration.  \nNumber of time periods: Total number of discrete time intervals for which the system is scheduled.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current through each activated module to ensure safety.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each element represents the capacity of a specific module at a given time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each element represents the internal resistance of a specific module at a given time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each element represents the voltage output of a specific module at a given time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack during each time period must remain within a safe preset range to prevent damage to connected loads.  \nCurrent safety constraint: The current flowing through any activated battery module during each time period must not exceed its maximum allowable threshold to prevent overheating and degradation.  \nParallel module consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be identical to ensure balanced load distribution.  \nWear-leveling constraint: Across all time periods, the cumulative number of activations for any two battery modules must differ by no more than 2 to ensure equitable utilization and extend system lifespan.  \nThermal management constraint: Within any 2x2 module matrix region, no more than 2 modules may be activated simultaneously during each time period to prevent localized thermal hotspots and improve thermal efficiency.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated modules over all time periods. This encompasses internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], listed row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module in the matrix configuration is activated (1) or deactivated (0) at each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module at each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the system at each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nSystem configuration:  \n- Number of parallel modules (NUM_PARALLEL_MODULES).  \n- Number of series columns (NUM_SERIES_COLUMNS).  \n- Number of time periods (NUM_PERIODS).  \n\nBattery module properties:  \n- Cell nominal voltage (V_nominal).  \n- Maximum allowable current per module (I_max).  \n\nInput matrices:  \n- Capacity matrix (C): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the capacity of each module in ampere-hours.  \n- Resistance matrix (R): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each module in ohms.  \n- Voltage matrix (V): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage of each module in volts.  \n\nFault condition: The battery module located at the first row and first column position is permanently non-operational and cannot be activated during any time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system at each time period must remain within a predefined safe range to avoid damage to connected loads. This is calculated as the sum of the voltages of all series-connected modules in each parallel branch.  \n\nCurrent safety constraints: The current flowing through any activated battery module at any time period must not exceed its maximum allowable current (I_max) to prevent overheating and degradation.  \n\nParallel consistency constraints: At each time period, the number of parallel-connected modules in all series branches must be equal, ensuring balanced load distribution across the system.  \n\nWear-leveling constraints: The total number of activations for any two battery modules across all time periods must differ by no more than 2 to ensure equitable utilization and promote uniform degradation of all modules.  \n\nFault condition constraint: The battery module located at the first row and first column position is permanently non-functional and must remain deactivated (activation variable set to 0) throughout the entire operational period.  \n\nEnergy loss calculation constraints: The energy loss for each activated module at each time period is determined by its internal resistance and the square of the current flowing through it. Additionally, deactivated modules contribute to recovery effects, which are modeled as a reduction in net energy loss.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes:  \n- Internal resistance losses during activation periods, calculated as \\( R \\cdot I^2 \\), where \\( R \\) is the resistance and \\( I \\) is the current.  \n- Electrochemical recovery effects during deactivation periods, which reduce the overall energy loss and improve system efficiency.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers or floating-point values representing the number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), number of time periods (NUM_PERIODS), cell nominal voltage (V_nominal), and maximum allowable current per module (I_max).  \n- Subsequent lines: Three 3D matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided in flattened row-by-row order. Each matrix entry corresponds to the respective property (capacity, resistance, or voltage) of a specific battery module at a given time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: A binary decision variable for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nSwitch state change variables: A binary decision variable for each battery module at each time period, representing whether the module's activation state changes compared to the previous time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total count of series branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the battery system is scheduled.  \nCell nominal voltage: The nominal voltage of each battery module.  \nMaximum current per module: The maximum allowable current flowing through any activated battery module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the capacity of a specific battery module at a given time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific battery module at a given time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage of a specific battery module at a given time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery system across all series columns must remain strictly within the specified safe power supply range for every time period.  \nCurrent limit constraint: The current flowing through any activated battery module must not exceed its maximum allowable threshold at any time period.  \nParallel connection consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be identical to ensure balanced load distribution.  \nSwitch state change constraint: The total number of battery modules that change their activation state between consecutive time periods must not exceed 6, limiting reconfiguration frequency.  \nSpatial activation constraint: Within any 2x2 matrix region of battery modules, no more than 2 modules may be activated simultaneously at any time period, ensuring efficient thermal management and preventing localized overheating.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods. Energy loss is calculated as the sum of internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitching variables: Binary decision variables representing whether the activation state of a battery module changes between consecutive time periods.  \nParallel group variables: Integer variables representing the number of activated modules in each parallel group at each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules in each parallel group.  \nNumber of series columns: Total count of series-connected columns in the battery matrix.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: Voltage output of each battery module when activated.  \nMaximum current per module: Safety threshold for the current that can flow through any individual module.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the energy capacity of each module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance of each module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the voltage output of each module at each time period when activated.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system, determined by the sum of the voltages of all series-connected columns, must remain within the safe power supply range at all time periods.  \nCurrent safety constraints: The current flowing through any activated battery module at any time period must not exceed the maximum allowable current.  \nParallel group consistency constraints: At any given time period, the number of activated modules in all parallel groups within the series branches must be equal, ensuring balanced load distribution.  \nWear-leveling constraints: Across all time periods, the total number of activations of any two modules must differ by no more than 2 activations, promoting uniform battery degradation.  \nSwitching stability constraints: The total number of modules that change their activation state between two consecutive time periods must not exceed 6, ensuring operational stability and minimizing mechanical stress on switching components.  \nThermal management constraints: Within any 2x2 region of the battery module matrix, no more than 2 modules may be activated simultaneously at any time period, preventing localized thermal hotspots and ensuring efficient heat distribution.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes losses due to internal resistance during activation and energy recovery effects during deactivation, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \n- Subsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 1\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each battery module: Binary decision variables indicating whether each battery module in the matrix is activated (1) or deactivated (0) during each time period.  \nSwitch state variables: Binary decision variables representing whether the state of a battery module changes (from activated to deactivated or vice versa) between consecutive time periods.  \nLoad balancing variables: Integer variables representing the total number of parallel-connected modules in each series branch during each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nMatrix dimensions: Number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), and number of time periods (NUM_PERIODS).  \nBattery module characteristics: Nominal voltage (V_nominal) and maximum allowable current (I_max) for each module.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each battery module during each time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each battery module during each time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the voltage of each battery module during each time period.  \nFault condition: The battery module located at position (1, 1) (first row, first column) is permanently malfunctioning and cannot be activated during any time period.  \nSwitching constraint: The maximum number of modules allowed to change state between consecutive time periods is 6.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system, calculated as the sum of the voltages of all activated modules in each series branch, must remain within a predefined safe range during each time period.  \nCurrent limit constraints: The current flowing through any activated battery module must not exceed the maximum allowable current (I_max) during any time period.  \nLoad balancing constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nWear-leveling constraints: The cumulative number of activations for any two battery modules across all time periods must differ by no more than 2 activations.  \nOperational stability constraints: The number of modules that change state (from activated to deactivated or vice versa) between consecutive time periods must not exceed 6.  \nFault condition constraint: The battery module located at position (1, 1) (first row, first column) must remain deactivated during all time periods.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), number of time periods (NUM_PERIODS), nominal voltage (V_nominal), and maximum current per module (I_max).  \nSubsequent lines: Three flattened 3D matrices (C for capacity, R for resistance, and V for voltage), each with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module in the matrix is activated (1) or deactivated (0) at each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery system at each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module at each time period.  \nUsage count variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nMatrix configuration: The battery system is arranged in a matrix with a specified number of parallel modules (rows) and series columns.  \nNumber of time periods: The total number of discrete time periods over which the system operates.  \nNominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any activated battery module.  \nCapacity matrix (C): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each module at each time period.  \nResistance matrix (R): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each module at each time period.  \nVoltage matrix (V): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage of each module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery system at each time period must remain within a predefined safe range to prevent damage to connected loads.  \nCurrent limit constraints: The current flowing through any activated battery module at any time period must not exceed the modules maximum allowable current.  \nParallel connection consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be identical to ensure balanced load distribution.  \nWear-leveling constraints: The cumulative number of activations for any two battery modules across all time periods must differ by no more than 2, promoting uniform wear and extending system lifespan.  \nSpatial activation constraints: Within any 2x2 sub-matrix of battery modules, no more than 2 modules may be activated simultaneously at any time period to prevent localized thermal hotspots and improve thermal management.  \nFault exclusion constraints: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated during any time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage), each with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION =2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables representing whether each battery module in the matrix is activated (1) or deactivated (0) at each time period.  \nSwitching state variables: Binary decision variables representing whether the state of a module (activated or deactivated) changes between consecutive time periods.  \nOutput voltage: Continuous variables representing the total output voltage of the battery pack at each time period.  \nOutput current: Continuous variables representing the total output current flowing through the activated modules at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel in each series branch.  \nNumber of series columns: Total number of series branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods for which the system is scheduled.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current flowing through any activated module to ensure safe operation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the capacity of each module over time.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance of each module over time.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the voltage of each module over time.  \n\n3. Constraints  \nOutput voltage constraint: The total output voltage of the system at each time period must remain within the safe operating range defined by the series configuration of the activated modules.  \nOutput current constraint: The current flowing through any activated module at any time period must not exceed its maximum allowable threshold.  \nParallel connection balance constraint: At each time period, the number of activated modules in all series branches must be identical to ensure balanced load distribution.  \nSwitching constraint: The total number of modules that change their activation state (from activated to deactivated or vice versa) between consecutive time periods must not exceed 6.  \nSpatial activation constraint: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously at any given time period to prevent localized thermal hotspots.  \nFault condition constraint: The module located at the first row and first column position is permanently deactivated and cannot be activated at any time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. The energy loss includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, aiming to maximize the energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floats representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each module: Binary variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nSwitching state variables: Binary variables representing whether the activation state of a module changes between consecutive time periods.  \nEnergy loss variables: Continuous variables representing the net energy loss for each module during each time period, based on internal resistance losses and recovery effects.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of modules in each row of the battery pack (parallel connections).  \nNumber of series columns: Total number of columns in the battery pack (series connections).  \nNumber of time periods: Total number of discrete time periods in the scheduling horizon.  \nCell nominal voltage: Nominal voltage of each battery module.  \nMaximum current per module: Maximum allowable current that can flow through each module to avoid overheating.  \nCapacity matrix (C): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each module during each time period.  \nResistance matrix (R): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each module during each time period.  \nVoltage matrix (V): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the voltage of each module during each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack across all series columns must remain within the preset safe power supply range during each time period.  \nCurrent limit constraints: The current flowing through any activated module must not exceed its maximum allowable value during each time period.  \nParallel connection balance constraints: At any given time period, the number of activated modules in parallel across all series branches must be consistent to ensure balanced load distribution.  \nWear-leveling constraints: Over the entire scheduling horizon, the total number of activations for any two modules must differ by no more than 2, ensuring equitable utilization of all modules.  \nSwitching stability constraints: The total number of modules that change their activation state between consecutive time periods must not exceed 6, reducing mechanical stress on switching components.  \nSpatial activation constraints: Within any 2x2 submatrix of the battery pack, no more than 2 modules can be activated simultaneously during any time period, ensuring efficient heat distribution and preventing localized thermal hotspots.  \nFault condition constraints: The module located at the first row and first column position cannot be activated during any time period due to a permanent malfunction.  \n\n4. Objective Function  \nMinimize the total net energy loss across all modules and time periods. The energy loss includes internal resistance losses during activation periods and recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \n- Subsequent lines: Three matrices (C, R, V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided as flattened row-by-row entries. Each matrix entry corresponds to the capacity, resistance, or voltage of a specific module at a specific time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and each candidate location, a binary variable represents whether the demand of the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas (e.g., residential zones, commercial centers, transportation hubs) and candidate locations where charging stations can be established.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., travel time or distance) for assigning the demand of a specific area to a specific candidate location.  \nDemand values: A list where each entry represents the predicted charging demand for a specific demand area.  \nFixed construction costs: A list where each entry represents the fixed cost of activating a specific candidate location as a charging station.  \nCapacity limits: A list where each entry represents the maximum service capacity of a specific candidate location, limiting the total demand that can be assigned to it.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully assigned to one or more activated charging station locations.  \nStation activation constraints: A candidate location can only serve demand areas if it is activated as a charging station.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nAssignment constraints: Each demand area can only be assigned to candidate locations where service costs are defined in the input matrix.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service costs for all assigned demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and the number of candidate locations.  \nSubsequent lines: A [number of demand areas  number of candidate locations] matrix representing the service costs for assigning demand areas to candidate locations.  \nNext line: A list of integers representing the demand values for each demand area.  \nNext line: A list of integers representing the fixed construction costs for each candidate location.  \nFinal line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand fulfillment: For each demand area and candidate location, a binary variable represents whether the demand of the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and potential locations for charging stations.  \nCost matrix: A matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) for assigning a demand area to a specific location.  \nDemand values: A vector specifying the charging demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost of constructing a charging station at each candidate location.  \nCapacity limits: A vector specifying the maximum service capacity for each candidate location, representing the maximum demand that can be fulfilled by the location.  \n\n3. Constraints  \nDemand fulfillment constraints: The total demand assigned to charging stations must fully satisfy the demand of each demand area.  \nCapacity constraints: The total demand assigned to a candidate location must not exceed its maximum service capacity.  \nActivation constraints: A candidate location can only fulfill demand if it is activated as a charging station.  \nAssignment constraints: Each demand area can only be assigned to activated locations, ensuring service is provided by operational stations.  \n\n4. Objective Function  \nMinimize the combined cost function, which consists of the sum of fixed construction costs for all activated stations and the total service cost for all demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Second section: A cost matrix [number of demand areas  number of candidate locations], where each entry specifies the service cost for assigning a demand area to a location.  \n- Third section: A vector of demand values, specifying the charging demand for each demand area.  \n- Fourth section: A vector of fixed construction costs for each candidate location.  \n- Fifth section: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand fulfillment: For each demand area and candidate location pair, a continuous variable representing the fraction of the demand from the area that is served by the location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas with predicted charging demand and total number of candidate locations where charging stations can potentially be built.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations] representing the service cost (e.g., travel time or distance) for each demand area-location pair.  \nDemand values: A vector specifying the predicted charging demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost of building a charging station at each candidate location.  \nService capacity limits: A vector specifying the maximum service capacity (e.g., number of users or charging events) that each candidate location can accommodate.  \nBudgetary range: The total fixed cost of activated charging stations must be strictly within the range of 20,000 to 25,000 monetary units.  \n\n3. Constraints  \nDemand fulfillment constraint: The total demand of each demand area must be fully served by one or more activated charging stations.  \nCapacity constraint: The total demand assigned to a candidate location must not exceed its maximum service capacity.  \nStation activation constraint: A candidate location can only serve demand if it is activated as a charging station.  \nBudgetary constraint: The sum of fixed construction costs for all activated charging stations must be strictly within the range of 20,000 to 25,000 monetary units.  \nNon-negativity constraint: The fraction of demand served by each candidate location must be non-negative.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- The fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated as the weighted sum of service costs based on the fraction of demand served by each location.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A cost matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost for a specific demand area-location pair.  \nThird line: A vector of demand values, one for each demand area.  \nFourth line: A vector of fixed construction costs, one for each candidate location.  \nFifth line: A vector of capacity limits, one for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for service allocation: For each demand area and candidate location pair, a continuous variable represents the fraction of the demand from the area that is served by the specific location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of predefined demand areas and candidate charging station locations.  \nDemand values: Predicted charging demand for each demand area, representing the number of users or charging events requiring service.  \nFixed construction costs: Cost associated with activating each candidate charging station location.  \nService cost matrix: A [nbCustomer  nbLocation] matrix representing the cost (e.g., distance or travel time) of serving a demand area from each candidate location.  \nCapacity limits: Maximum service capacity for each candidate charging station location, indicating the maximum number of users or charging events it can accommodate.  \nOperational capacity constraint: Activated stations must operate within 90% of their total design capacity to ensure reliability during peak usage periods.  \n\n3. Constraints  \nDemand fulfillment constraints: The total service allocated to each demand area must fully satisfy its predicted charging demand.  \nCapacity constraints: The total service allocated to a candidate charging station location across all demand areas must not exceed its maximum service capacity.  \nOperational capacity constraints: The total load capacity of all activated charging stations must not exceed 90% of their combined design capacity.  \nService allocation constraints: Service can only be allocated to a candidate location if the location is activated as a charging station.  \nBinary activation constraints: Each candidate location must either be activated as a charging station or remain inactive.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of fixed construction costs for all activated charging stations and the total service cost for all users based on the service cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A [nbCustomer  nbLocation] matrix representing service costs for each demand area-location pair.  \nThird block: A list of demand values for each demand area.  \nFourth block: A list of fixed construction costs for each candidate location.  \nFifth block: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether the station is activated (1) or not (0).  \nAssignment variables for demand areas: For each demand area and each candidate location, a binary variable indicating whether the demand area is assigned to the specific location (1) or not (0).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas that require charging services and candidate locations where charging stations can potentially be built.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost (e.g., distance or travel time) for serving a demand area from a specific candidate location.  \nDemand values: A list of demand values, where each entry specifies the predicted charging demand for a corresponding demand area.  \nFixed construction costs: A list of fixed costs associated with activating each candidate location as a charging station.  \nCapacity limits: A list of maximum service capacities for each candidate location, representing the total charging demand that the station can accommodate.  \n\n3. Constraints  \nDemand satisfaction constraints: Each demand area must be fully assigned to exactly one activated charging station, ensuring that all charging demand is met.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nActivation constraints: A candidate location can only serve demand areas if it is activated as a charging station.  \nTransportation cost constraint: The transportation cost between any demand area and its assigned charging station must not exceed 20 units, ensuring reasonable access for all users.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated stations and the total service costs for all assigned demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next [number of demand areas] lines: Each line contains [number of candidate locations] integers representing the service cost matrix, where each entry corresponds to the cost of serving a demand area from a specific location.  \n- Following line: A list of integers representing the demand values for each demand area.  \n- Next line: A list of integers representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand area is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and candidate locations available for charging station placement.  \nDemand values: Predicted charging demand for each demand area, expressed as the number of charging events or users that must be served.  \nService cost matrix: A matrix where each entry represents the service cost (e.g., travel time or distance) between a specific demand area and a candidate location.  \nFixed construction costs: Fixed costs associated with activating each candidate location as a charging station.  \nCapacity limits: Maximum number of charging events or users that each location can accommodate if activated.  \nBudget range: The total fixed construction cost for all activated stations must fall within the range of 20,000 to 25,000 monetary units.  \n\n3. Constraints  \nDemand fulfillment constraints: Each demand area must be fully assigned to one or more activated charging stations, ensuring its predicted charging demand is completely served.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nActivation constraints: A demand area can only be assigned to a candidate location if that location is activated as a charging station.  \nBudget constraints: The sum of fixed construction costs for all activated charging stations must be strictly within the budget range of 20,000 to 25,000 monetary units.  \nAssignment constraints: Each demand area must be assigned to at least one candidate location, ensuring every area is served.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction costs for all activated charging stations.  \n- The total service cost for all demand areas, based on the service cost matrix and the assignment of demand areas to candidate locations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and the number of candidate locations.  \nNext lines: A cost matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost between a specific demand area and candidate location.  \nFollowing line: A list of demand values for each demand area, indicating the predicted charging demand.  \nNext line: A list of fixed construction costs for each candidate location.  \nFinal line: A list of capacity limits for each candidate location, specifying the maximum number of users or charging events that can be served.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous decision variables for service allocation: For each demand area and candidate station location, a continuous variable represents the fraction of the demand served by the station.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas to be served and candidate locations for potential charging stations.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the cost of serving a unit of demand from a demand area to a candidate station (e.g., based on distance or travel time).  \nDemand values: A vector specifying the predicted charging demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate station location.  \nCapacity limits: A vector specifying the maximum service capacity for each candidate station location.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully served by one or more activated charging stations.  \nCapacity constraints: The total load assigned to any activated charging station must not exceed 90% of its design capacity, ensuring operational resilience and reliability.  \nStation activation constraints: A charging station can only serve demand if it is activated (i.e., the binary activation variable for the station must be set to 1).  \nNon-negativity constraints: Service allocation variables must be non-negative, ensuring no negative service allocation to demand areas.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes the sum of fixed construction costs for all activated charging stations and the total service cost for all users based on the service cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost between a demand area and a candidate station.  \nThird block: A vector specifying the demand values for each demand area.  \nFourth block: A vector specifying the fixed construction costs for each candidate station location.  \nFifth block: A vector specifying the capacity limits for each candidate station location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area, a set of binary variables represents the assignment of the demand to one of the candidate charging stations, ensuring that each area is fully served by exactly one station.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas to be served and potential locations for charging stations.  \nService cost matrix: A matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) for assigning a demand area to a specific candidate location.  \nDemand values: A list of predicted charging demands for each demand area, representing the total number of users or charging events to be served.  \nFixed construction costs: A list of fixed costs associated with activating each candidate location as a charging station.  \nCapacity limits: A list of maximum service capacities for each candidate location, specifying the total demand that can be accommodated by each station.  \nCost similarity threshold: A parameter defining the top 10% of site pairs with the most similar cost characteristics, used to enforce diversity in station selection.  \n\n3. Constraints  \nDemand assignment constraint: Each demand area must be assigned to exactly one activated charging station, ensuring full service coverage for all areas.  \nCapacity constraint: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nStation activation constraint: A candidate location can only serve demand if it is activated as a charging station.  \nCost similarity constraint: For any two candidate locations identified as having the most similar cost characteristics (within the top 10% of all site pairs based on cost similarity), at most one of the two locations can be activated as a charging station.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- Fixed construction costs for all activated charging stations.  \n- Total service costs for all assigned demand areas, based on the service cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" is structured as follows:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next [number of demand areas] lines: Each line contains [number of candidate locations] integers or floats, representing the service cost matrix.  \n- Following line: A list of integers or floats representing the demand values for each demand area.  \n- Following line: A list of integers or floats representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate station location pair, a binary variable represents whether the demand area is assigned to the specific station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and candidate locations where charging stations can be built.  \nService cost matrix: A matrix specifying the transportation cost between each demand area and each candidate location.  \nDemand values: Predicted charging demand for each demand area, representing the total number of users or charging events that must be served.  \nFixed construction costs: The cost of building a charging station at each candidate location.  \nCapacity limits: Maximum service capacity for each candidate location, defining the upper limit on the number of users or charging events a station can handle.  \nBudget range: The allowable total fixed construction cost for activated charging stations, constrained to be between 20,000 and 25,000 monetary units.  \nMaximum transportation cost: The maximum allowable transportation cost between any demand area and its assigned charging station, set to 20 units.\n\n3. Constraints  \nStation activation constraints: Each candidate location can either be activated or remain inactive, as determined by the binary activation variables.  \nDemand assignment constraints: Each demand area must be assigned to exactly one activated charging station.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nTransportation cost constraints: The transportation cost between any demand area and its assigned charging station must not exceed 20 units, ensuring accessibility and service quality.  \nBudget constraints: The sum of fixed construction costs for all activated charging stations must lie strictly within the budget range of 20,000 to 25,000 monetary units.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- Fixed construction costs for all activated charging stations.  \n- Total service costs for all users, calculated based on the transportation cost between demand areas and their assigned charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSubsequent lines:  \n- A cost matrix of size [nbCustomer  nbLocation], specifying transportation costs between each demand area and candidate location.  \n- A list of demand values for each demand area.  \n- A list of fixed construction costs for each candidate location.  \n- A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand area is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and potential locations for charging stations.  \nService cost matrix: A [number of demand areas  number of candidate locations] matrix representing the transportation cost between each demand area and each candidate location.  \nDemand values: A vector specifying the predicted charging demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum number of users or charging events that each candidate location can accommodate.  \nProximity threshold: A scalar value (20 units) defining the maximum allowable transportation cost between any demand area and its assigned charging station.  \nSimilarity threshold: A scalar percentage (10%) defining the closest cost similarity range between pairs of candidate locations, within which at most one location can be activated.  \n\n3. Constraints  \nDemand satisfaction constraints: Each demand area must be fully assigned to exactly one activated charging station.  \nCapacity constraints: The total demand assigned to a candidate location must not exceed its maximum service capacity.  \nProximity constraints: The transportation cost between any demand area and its assigned charging station must not exceed the proximity threshold of 20 units.  \nMutual exclusivity constraints: For any two candidate locations with cost characteristics ranking in the nearest 10% of similarity, at most one of them can be activated as a charging station.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- The fixed construction costs for all activated charging stations.  \n- The total service cost for all demand areas, calculated as the sum of transportation costs between each demand area and its assigned charging station.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next [number of demand areas] lines: Each line contains [number of candidate locations] integers representing the service cost matrix, where the entry at row i and column j represents the transportation cost between demand area i and candidate location j.  \n- Next line: A vector of integers representing the demand values for each demand area.  \n- Next line: A vector of integers representing the fixed construction costs for each candidate location.  \n- Next line: A vector of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicating whether the station is activated (1) or not (0).  \nContinuous variables for service allocation: For each demand area and candidate location, a continuous variable representing the quantity of charging demand served by the location to the area.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of distinct demand areas and candidate station locations.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., travel time or distance) for a demand area to be served by a specific candidate location.  \nDemand values: A vector representing the charging demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate station location.  \nCapacity limits: A vector indicating the maximum service capacity of each candidate station location.  \nBudget range: A lower and upper bound for the total fixed construction cost, set at 20,000 and 25,000 monetary units, respectively.  \nCapacity utilization limit: A maximum utilization threshold of 90% for the total design capacity of all activated charging stations.  \n\n3. Constraints  \nDemand satisfaction constraints: The total charging demand for each demand area must be fully satisfied by the activated charging stations.  \nCapacity constraints: The total quantity of demand served by each activated station must not exceed its maximum service capacity.  \nActivation constraints: A candidate station location can only serve demand if it is activated.  \nBudget constraints: The total fixed construction cost of all activated stations must lie within the budget range of 20,000 to 25,000 monetary units.  \nCapacity utilization constraints: The total quantity of demand served by all activated stations must not exceed 90% of their combined design capacity.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated stations.  \n- The total service cost for all users, calculated as the sum of service costs across all demand areas and candidate locations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A cost matrix of size [number of demand areas  number of candidate locations], where each entry specifies the service cost between a demand area and a candidate location.  \nThird line: A vector of demand values for each demand area.  \nFourth line: A vector of fixed construction costs for each candidate location.  \nFifth line: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nContinuous variables for service allocation: For each demand area and candidate location pair, a continuous variable represents the amount of charging demand served by the station at that location for the respective area.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of areas requiring charging services and potential sites for station construction.  \nCost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost for meeting the demand of a specific area from a specific station location.  \nDemand values: A vector specifying the charging demand for each demand area.  \nFixed construction costs: A vector indicating the fixed cost associated with constructing a charging station at each candidate location.  \nCapacity limits: A vector specifying the maximum service capacity of each candidate station location.  \nBudget range: Fixed construction costs for all activated stations must fall within the range of 20,000 to 25,000 units.  \n\n3. Constraints  \nDemand satisfaction constraints: Each demand areas total charging demand must be fully satisfied by the sum of services provided by all constructed stations.  \nCapacity constraints: The total service allocated to a station cannot exceed its maximum service capacity.  \nBudget constraints: The sum of fixed construction costs for all activated stations must lie strictly within the budget range of 20,000 to 25,000 units.  \nMutual exclusion constraints: For any two candidate station locations with the most similar cost characteristics (ranking within the nearest 10% among all site pairs), at most one of them can be constructed.  \nNon-negativity constraints: Service allocation variables must be non-negative, ensuring no negative service is assigned.  \nStation activation constraints: Service can only be allocated from locations where a charging station is constructed (i.e., service variables are zero for inactive locations).  \n\n4. Objective Function  \nMinimize the combined cost comprising the fixed construction costs of all activated charging stations and the total service cost for meeting the demand of all areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A cost matrix [number of demand areas  number of candidate locations], where each entry specifies the service cost for a specific area-location pair.  \nThird block: A vector of demand values, with one entry per demand area.  \nFourth block: A vector of fixed construction costs, with one entry per candidate location.  \nFifth block: A vector of capacity limits, with one entry per candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nContinuous variables for service allocation: For each demand area and candidate location pair, a continuous variable represents the amount of charging service provided by the candidate location to the demand area.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of metropolitan demand areas requiring service and candidate locations available for constructing charging stations.  \nDemand values: Predicted charging demand for each demand area, expressed in service units.  \nFixed construction costs: The fixed cost associated with constructing a charging station at each candidate location.  \nService cost matrix: A matrix specifying the cost of providing charging service from each candidate location to each demand area.  \nCapacity limits: Maximum service capacity for each candidate location, reflecting physical and operational constraints.  \nSafety buffer: A load capacity constraint stipulating that the total load on all operational stations must not exceed 90% of their combined design capacities.  \nGeographic similarity threshold: For any two candidate locations ranking within the nearest 10% in cost characteristics, at most one station can be constructed.  \n\n3. Constraints  \nDemand satisfaction constraints: The total charging service provided to each demand area must meet or exceed its predicted demand value, ensuring full coverage.  \nCapacity constraints: The total service allocated by each candidate location to all demand areas must not exceed its maximum service capacity.  \nSafety buffer constraint: The total load across all operational charging stations must not exceed 90% of their combined design capacities, maintaining operational reliability during peak demand periods.  \nGeographic diversity constraint: For any two candidate locations within the nearest 10% in cost characteristics, at most one of them can be activated for station construction.  \nService allocation constraints: Service can only be allocated from candidate locations that are activated, ensuring consistency between station activation and service distribution decisions.  \n\n4. Objective Function  \nMinimize the total cost, comprising the sum of fixed construction costs for all activated charging stations and the total service cost for all demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond section: A cost matrix [nbCustomer  nbLocation] representing service costs from each candidate location to each demand area.  \nThird section: A list of demand values for each demand area.  \nFourth section: Fixed construction costs for each candidate location.  \nFifth section: Capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether a charging station is constructed at that location (1 if activated, 0 otherwise).  \nAssignment variables for demand coverage: For each demand area and each candidate location, a binary variable indicates whether the demand area is assigned to the specific charging station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas to be served and the number of candidate locations for potential charging station construction.  \nDemand values: For each demand area, the predicted charging demand that must be fully served.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost for serving a demand area from a specific candidate location.  \nFixed construction costs: For each candidate location, the fixed cost of constructing a charging station.  \nCapacity limits: For each candidate location, the maximum service capacity that the station can handle if constructed.  \nBudget range: A specified range (20,000 to 30,000 units) for the total fixed construction cost of all activated charging stations.  \nMaximum service distance: A limit of 20 units on the transportation cost between a demand area and its assigned charging station to ensure accessibility.  \n\n3. Constraints  \nDemand coverage constraints: Each demand area must be assigned to exactly one charging station, ensuring that all demand is fully served.  \nCapacity constraints: The total demand assigned to a charging station must not exceed its maximum service capacity.  \nService distance constraints: A demand area can only be assigned to a charging station if the transportation cost between the two does not exceed 20 units.  \nStation activation constraints: A demand area can only be assigned to a candidate location if a charging station is constructed at that location.  \nBudget constraints: The total fixed construction cost of all activated charging stations must lie within the budget range of 20,000 to 30,000 units.  \n\n4. Objective Function  \nMinimize the combined cost, which is the sum of the total fixed construction costs of all activated charging stations and the total service costs for all demand areas assigned to their respective charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Second section: A cost matrix of size [number of demand areas  number of candidate locations], where each entry specifies the service cost for assigning a demand area to a candidate location.  \n- Third section: A list of demand values, one per demand area.  \n- Fourth section: A list of fixed construction costs, one per candidate location.  \n- Fifth section: A list of capacity limits, one per candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(30000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nAllocation variables for demand satisfaction: For each demand area and each candidate location, a binary variable indicates whether the demand of that area is served by the given location (1 if served, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and potential locations for charging stations.  \nDemand values: Predicted charging demand for each demand area, expressed as a positive integer.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost for serving a specific demand area from a specific candidate location.  \nFixed construction costs: For each candidate location, the fixed cost of constructing a charging station at that location.  \nCapacity limits: For each candidate location, the maximum service capacity of the charging station if constructed.  \nService quality threshold: Maximum allowable transportation cost between any demand area and its assigned charging station, set at 20 units.  \nLoad capacity constraint: The actual total load of a constructed charging station must not exceed 90% of its design capacity.  \n\n3. Constraints  \nDemand satisfaction constraints: Each demand area must be fully served by exactly one charging station.  \nCapacity constraints: The total demand assigned to a charging station must not exceed its maximum service capacity.  \nLoad safety constraints: The total demand assigned to a charging station must not exceed 90% of its design capacity to maintain a safety buffer.  \nStation activation constraints: A demand area can only be served by a charging station if that station is constructed at the corresponding location.  \nService quality constraints: The transportation cost between a demand area and its assigned charging station must not exceed 20 units.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of fixed construction costs for all activated charging stations and the total service cost for all demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Next [number of demand areas] lines: A matrix of size [number of demand areas  number of candidate locations], where each entry specifies the service cost for serving a given demand area from a specific candidate location.  \n- Next line: A list of integers representing the demand values for each demand area.  \n- Next line: A list of integers representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nAssignment variables: For each demand area and candidate location pair, a binary variable indicates whether the demand of the area is assigned to the station at that location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas to be served and candidate locations for potential charging stations.  \nDemand values: Predicted charging demand for each demand area, expressed in consistent units.  \nFixed construction costs: Cost of building a charging station at each candidate location.  \nService costs: Cost matrix representing the cost of serving each demand area from each candidate location.  \nCapacity limits: Maximum service capacity for each candidate location, representing physical and operational constraints.  \nService quality constraints: Maximum allowable transportation cost between a demand area and its assigned charging station, set at 20 units.  \nGeographic diversity constraints: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can be constructed.  \n\n3. Constraints  \nDemand coverage constraints: Each demand area must be fully served, meaning the total demand assigned from a demand area to all candidate locations must equal the demand value for that area.  \nCapacity constraints: The total demand assigned to any candidate location must not exceed its maximum service capacity.  \nService quality constraints: For each demand area, the transportation cost to its assigned charging station must not exceed 20 units.  \nGeographic diversity constraints: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can be constructed.  \nStation activation constraints: A demand area can only be assigned to a candidate location if a charging station is constructed at that location.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated stations and the total service cost for all demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nNext [nbCustomer  nbLocation] lines: A cost matrix listing the service costs for each demand area and candidate location pair.  \nSubsequent line: A list of demand values for each demand area.  \nNext line: A list of fixed construction costs for each candidate location.  \nFinal line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 5)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether a charging station is built at that location (1 if built, 0 otherwise).  \nContinuous decision variables for service allocation: For each demand area and candidate location pair, a continuous variable represents the amount of charging demand allocated from the demand area to the candidate location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and candidate locations for potential station placement.  \nDemand values: Predicted charging demand for each demand area, expressed as a numeric value.  \nService cost matrix: A [nbCustomer  nbLocation] matrix where each entry represents the cost of serving one unit of demand from a specific demand area to a specific candidate location.  \nFixed construction costs: A numeric value for each candidate location, representing the cost of building a charging station at that location.  \nCapacity limits: Maximum service capacity for each candidate location, representing physical and operational constraints of the station.  \nBudget range: A defined range [20,000, 30,000] within which the sum of fixed construction costs for all activated stations must fall.  \nSafety buffer for load capacity: A constraint limiting the actual load capacity of activated charging stations to no more than 90% of their total design capacity.  \n\n3. Constraints  \nDemand coverage constraints: Each demand areas charging demand must be fully served by one or more candidate locations, ensuring adequate coverage of all areas.  \nCapacity constraints: The total service allocated to any candidate location must not exceed its maximum service capacity.  \nBudgetary constraints: The sum of fixed construction costs for all activated charging stations must lie within the budget range of 20,000 to 30,000 units.  \nLoad capacity constraints: The total actual load capacity of all activated charging stations must not exceed 90% of their combined design capacity, ensuring a safety buffer for peak demand periods.  \nActivation constraints: Service allocation to a candidate location is only allowed if the location is activated (i.e., a charging station is built at that location).  \nNon-negativity constraints: Service allocation variables must be non-negative, ensuring valid demand allocation.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of fixed construction costs for all activated charging stations and the total service cost for all users across all demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond section: A [nbCustomer  nbLocation] matrix representing service costs for each demand area and candidate location pair.  \nThird section: A list of demand values for each demand area.  \nFourth section: A list of fixed construction costs for each candidate location.  \nFifth section: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(30000 >= obj)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether a charging station is built at that location (1 if built, 0 otherwise).  \nContinuous variables for demand allocation: For each demand area and candidate location pair, a continuous variable represents the amount of demand served by the station at that location for the specific demand area.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and total number of candidate locations where charging stations can potentially be built.  \nDemand values: Predicted charging demand for each demand area, representing the total service requirement.  \nService cost matrix: A matrix where each entry indicates the cost of serving one unit of demand from a specific candidate location to a specific demand area.  \nFixed construction costs: The fixed cost associated with building a charging station at each candidate location.  \nCapacity limits: The maximum service capacity for each candidate location, reflecting the physical and operational constraints of the station.  \nBudget range: The total fixed construction cost of all built stations must fall within the specified range of 20,000 to 30,000 units.  \nSimilarity threshold: For any two candidate locations with cost characteristics ranked in the nearest 5% of similarity, at most one of them can be selected for construction.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully satisfied by the selected charging stations.  \nCapacity constraints: The total demand allocated to a candidate location cannot exceed its maximum service capacity.  \nBudgetary constraints: The sum of the fixed construction costs of all built charging stations must be within the specified budget range of 20,000 to 30,000 units.  \nService allocation constraints: Demand from a demand area can only be allocated to a candidate location if a station is built at that location.  \nGeographic diversity constraints: For any two candidate locations with cost characteristics ranked in the nearest 5% of similarity, at most one of them can be selected for construction to ensure diversity in station placement.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all built stations and the total service cost for all allocated demand.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next nbCustomer  nbLocation lines: A cost matrix where each entry represents the service cost of allocating one unit of demand from a specific candidate location to a specific demand area.  \n- Next line: A list of demand values for each demand area.  \n- Next line: A list of fixed construction costs for each candidate location.  \n- Final line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(30000 >= obj)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 5)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nContinuous variables for service allocation: For each demand area and candidate location pair, a continuous variable representing the amount of charging demand from the demand area that is served by the candidate location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring coverage and candidate locations where charging stations can potentially be built.  \nDemand values: Charging demand for each demand area, representing the total amount of energy required to serve the electric vehicles in that area.  \nFixed construction costs: Cost of constructing a charging station at each candidate location.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the cost of serving a unit of demand from a specific demand area at a specific candidate location.  \nCapacity limits: Maximum service capacity for each candidate location, reflecting physical and operational constraints of the charging stations.  \nLoad capacity limit: A global constraint requiring that the total load across all activated charging stations does not exceed 90% of their combined design capacities.  \nGeographic diversity constraint: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can have a charging station constructed.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand from each demand area must be fully served by the activated charging stations.  \nCapacity constraints: The total demand served by any charging station cannot exceed its maximum service capacity.  \nLoad capacity constraint: The combined load of all activated charging stations must not exceed 90% of their total design capacity.  \nGeographic diversity constraint: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can have a charging station constructed.  \nService allocation constraints: A demand area can only be served by a candidate location if a charging station is constructed at that location.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service costs for all demand areas.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and the number of candidate locations.  \nSecond section: A cost matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost for a unit of demand from a specific demand area to a specific candidate location.  \nThird section: A list of demand values, one for each demand area, representing the total energy required for that area.  \nFourth section: A list of fixed construction costs, one for each candidate location.  \nFifth section: A list of capacity limits, one for each candidate location, indicating the maximum service capacity of each potential charging station.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 5)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nAssignment variables for demand coverage: For each demand area and candidate location pair, a binary variable indicating whether the demand area is assigned to the charging station at that location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and the number of candidate locations where charging stations can potentially be built.  \nDemand values: Predicted charging demand for each demand area, measured in appropriate units.  \nService cost matrix: A matrix representing the transportation cost between each demand area and each candidate location.  \nFixed construction costs: The fixed cost of constructing a charging station at each candidate location.  \nCapacity limits: The maximum service capacity of each candidate location, reflecting physical and operational constraints.  \nBudget range: The total allowable budget for constructing charging stations, constrained between 20,000 and 30,000 units.  \nService quality threshold: A maximum transportation cost of 20 units between any demand area and its assigned charging station.  \nLoad capacity buffer: A constraint ensuring that the actual load on any constructed charging station does not exceed 90% of its total design capacity.  \n\n3. Constraints  \nStation activation constraint: A charging station must be activated at a candidate location before any demand area can be assigned to it.  \nDemand coverage constraint: Each demand area must be fully served, meaning it must be assigned to exactly one charging station.  \nCapacity constraint: The total demand assigned to any charging station must not exceed its maximum service capacity.  \nLoad capacity buffer constraint: The actual load on any constructed charging station must not exceed 90% of its total design capacity, ensuring a safety margin for peak demand.  \nService quality constraint: The transportation cost between any demand area and its assigned charging station must not exceed 20 units.  \nBudget constraint: The total fixed construction cost of all activated charging stations must be within the budget range of 20,000 to 30,000 units.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs of all activated charging stations and the total service costs for all demand areas assigned to these stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Subsequent lines (one for each demand area): A row of integers representing the service cost matrix [nbCustomer  nbLocation], where each entry indicates the transportation cost between a demand area and a candidate location.  \n- Next line: A list of integers representing the demand values for each demand area.  \n- Next line: A list of integers representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(30000 >= obj)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicating whether the demand area is assigned to the charging station at that location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and candidate locations available for station construction.  \nService cost matrix: A matrix specifying the transportation cost between each demand area and each candidate location.  \nDemand values: Predicted charging demand for each demand area, expressed as a numerical value.  \nFixed construction costs: Fixed costs associated with constructing a charging station at each candidate location.  \nCapacity limits: Maximum service capacity for each candidate location, representing the maximum demand that can be served by a station at that location.  \nBudget range: A defined range (20,000 to 30,000 units) within which the total fixed construction cost for activated stations must fall.  \n\n3. Constraints  \nDemand coverage constraints: Each demand area must be fully assigned to exactly one charging station, ensuring that all predicted demand is served.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nTransportation cost constraints: The transportation cost between any demand area and its assigned charging station must not exceed 20 units, ensuring accessibility for users.  \nBudget constraints: The sum of fixed construction costs for all activated charging stations must fall strictly within the budget range of 20,000 to 30,000 units.  \nGeographic diversity constraints: For any two candidate locations identified as having the most similar cost characteristics (ranking in the nearest 10% among all site pairs), at most one of them can be selected for construction, promoting diversity in station placement.  \n\n4. Objective Function  \nMinimize the combined cost, which consists of the total fixed construction costs for activated charging stations and the total service costs for all demand areas assigned to these stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A service cost matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the transportation cost between a demand area and a candidate location.  \nThird line: A list of demand values for each demand area.  \nFourth line: A list of fixed construction costs for each candidate location.  \nFifth line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(30000 >= obj)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nContinuous variables for service allocation: For each demand area and candidate location pair, a continuous variable representing the amount of charging demand served by the station at that location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and candidate locations where charging stations can potentially be built.  \nDemand values: Predicted charging demand for each demand area, expressed in consistent units.  \nService cost matrix: A matrix where each entry represents the service cost of satisfying one unit of demand for a specific demand area from a specific candidate location.  \nFixed construction costs: The fixed cost associated with constructing a charging station at each candidate location.  \nCapacity limits: The maximum charging capacity that can be provided by a station at each candidate location, reflecting physical and operational constraints.  \nBudget range: The allowable range for total fixed construction costs, strictly between 20,000 and 30,000 units.  \nLoad safety buffer: A requirement that the actual load on any operational charging station must not exceed 90% of its design capacity.  \nSimilarity threshold: A measure of cost similarity between candidate locations. For any two locations with cost characteristics ranked within the nearest 10% of all site pairs, at most one of them can be selected for construction.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand served for each demand area must be equal to its predicted demand.  \nService allocation constraints: Charging demand can only be allocated to a candidate location if a station is constructed at that location.  \nCapacity constraints: The total charging demand served by a station at any location must not exceed its maximum capacity. Additionally, the actual load on any operational station must not exceed 90% of its design capacity, ensuring a safety buffer for peak demand periods.  \nBudget constraints: The total fixed construction cost of all activated charging stations must be strictly within the budget range of 20,000 to 30,000 units.  \nGeographic diversity constraints: For any two candidate locations with cost characteristics ranked within the nearest 10% of all site pairs, at most one of them can be selected for construction.  \n\n4. Objective Function  \nMinimize the combined cost, which is the sum of the fixed construction costs for all activated stations and the total service cost for all charging demand allocations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Second section: A cost matrix with dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost for satisfying one unit of demand for a specific demand area from a specific candidate location.  \n- Third section: A single line with demand values for each demand area.  \n- Fourth section: A single line with fixed construction costs for each candidate location.  \n- Fifth section: A single line with capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(30000 >= obj)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether a charging station is built at that location (1 if built, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand area is assigned to the charging station at that location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and the total number of candidate locations for potential charging station construction.  \nDemand values: For each demand area, the predicted charging demand that must be fully satisfied.  \nService cost matrix: A matrix where each entry represents the transportation cost between a demand area and a candidate station location.  \nFixed construction costs: For each candidate location, the fixed cost of building a charging station.  \nCapacity limits: For each candidate location, the maximum service capacity of the charging station.  \nBudget range: A lower and upper bound on the total fixed construction costs for all activated charging stations.  \nService quality constraint: The maximum allowable transportation cost between any demand area and its assigned charging station, set to 20 units.  \nGeographic diversity constraint: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can be selected for construction.  \n\n3. Constraints  \nDemand satisfaction constraints: Each demand area must be assigned to exactly one charging station.  \nCapacity constraints: The total demand assigned to a charging station cannot exceed its maximum service capacity.  \nService quality constraints: The transportation cost between a demand area and its assigned charging station must not exceed 20 units.  \nStation activation constraints: A demand area can only be assigned to a candidate location if a charging station is built at that location.  \nBudget constraints: The total fixed construction costs of all activated charging stations must lie within the budget range of 20,000 to 35,000 units.  \nGeographic diversity constraints: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can be selected for construction.  \n\n4. Objective Function  \nMinimize the combined cost, which is the sum of the total fixed construction costs for all activated charging stations and the total service cost for all demand areas assigned to these stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Second line: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost between a demand area and a candidate station location.  \n- Third line: A list of integers representing the demand values for each demand area.  \n- Fourth line: A list of integers representing the fixed construction costs for each candidate location.  \n- Fifth line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(35000 >= obj)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 5)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nFlow variables for demand allocation: For each demand area and candidate location pair, a continuous variable representing the amount of charging demand from the demand area allocated to the candidate location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and candidate locations where charging stations can potentially be constructed.  \nDemand values: Predicted charging demand for each demand area, expressed as a numerical value.  \nService cost matrix: A matrix representing the cost of serving each demand area from each candidate location.  \nFixed construction costs: The fixed cost associated with constructing a charging station at each candidate location.  \nCapacity limits: The maximum service capacity for each candidate location, reflecting physical and operational constraints.  \nBudget range: A lower and upper bound on the total fixed construction cost, strictly enforced between 20,000 and 40,000 units.  \nLoad capacity constraint: A safety buffer requiring the actual load at any constructed station to not exceed 90% of its design capacity.  \nSimilarity threshold: For any two candidate locations with cost characteristics ranked in the nearest 5% among all pairs, at most one of them can be selected for construction.  \n\n3. Constraints  \nDemand fulfillment constraint: The total demand from each demand area must be fully allocated to one or more constructed charging stations.  \nCapacity constraint: The total demand allocated to any candidate location must not exceed its maximum service capacity if a charging station is constructed there.  \nBudget constraint: The sum of fixed construction costs for all activated charging stations must lie strictly within the range of 20,000 to 40,000 units.  \nLoad capacity constraint: The total allocated demand at any constructed charging station must not exceed 90% of its design capacity, ensuring operational reliability during peak periods.  \nExclusivity constraint for similar locations: For any pair of candidate locations with cost characteristics ranked in the nearest 5% among all pairs, at most one of them can be selected for construction to ensure geographic diversity.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service cost for all allocated demand.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Second section: A cost matrix [nbCustomer  nbLocation] representing the service costs between each demand area and each candidate location.  \n- Third section: A list of demand values for each demand area.  \n- Fourth section: A list of fixed construction costs for each candidate location.  \n- Fifth section: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(40000 >= obj)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 5)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether a charging station is constructed at that location (1 if constructed, 0 otherwise).  \nContinuous variables for demand assignment: For each demand area and candidate location, a continuous variable represents the amount of demand assigned from the demand area to the charging station at the candidate location.  \nAuxiliary continuous variables for station load: For each constructed station, a continuous variable represents the total load served by the station, derived from the assigned demand.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and candidate locations for station construction.  \nDemand values: Predicted charging demand for each demand area, expressed as positive numerical values.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost of assigning demand from a specific area to a specific location.  \nFixed construction costs: A list of fixed costs associated with constructing a charging station at each candidate location.  \nCapacity limits: Maximum service capacity for each candidate location, reflecting physical and operational constraints.  \nBudget range: Fixed construction costs for all activated stations must fall within the range of 20,000 to 35,000 units.  \nService quality constraint: Transportation cost between any demand area and its assigned charging station must not exceed 20 units.  \nLoad safety buffer: Operational load capacity of all constructed stations must not exceed 90% of their total design capacity.  \nRedundancy control: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can be constructed.  \n\n3. Constraints  \nDemand satisfaction constraints: The total assigned demand from each demand area must equal its predicted charging demand, ensuring full service coverage.  \nService quality constraints: The transportation cost for assigning demand from any demand area to a charging station must not exceed 20 units, ensuring accessibility for users.  \nCapacity constraints: The total assigned demand to any constructed station must not exceed its maximum service capacity, maintaining operational reliability.  \nLoad safety buffer constraints: The total load served by each constructed station must not exceed 90% of its design capacity, preserving a safety margin for peak demand periods.  \nBudget constraints: The sum of fixed construction costs for all activated stations must fall within the budget range of 20,000 to 35,000 units.  \nRedundancy control constraints: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 5% among all site pairs), at most one of them can be constructed, promoting geographic diversity in the station network.  \n\n4. Objective Function  \nMinimize the combined cost comprising the fixed construction costs of all activated stations and the total service cost for all users, ensuring cost-effective deployment of charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nNext [number of demand areas  number of candidate locations] lines: A matrix representing service costs, where each row corresponds to a demand area and each column corresponds to a candidate location.  \nNext line: A list of demand values for each demand area.  \nNext line: A list of fixed construction costs for each candidate location.  \nNext line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_demand = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(35000 >= obj)\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 5)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables representing whether each valid DNA sequence from the predefined word list is selected for the solution set.  \nSequence assignment variables: Binary decision variables indicating which specific DNA sequences are assigned to each position in the solution set of 6 sequences.  \n\n2. Parameters and Input Data  \nPredefined word list: A set of valid DNA sequences, each 8 bases in length, provided in the input file. Each base is represented as an integer (0=A, 1=T, 2=C, 3=G).  \nNumber of sequences to design: A total of 6 DNA sequences must be selected from the word list.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \n\n3. Constraints  \nGC content constraint: The proportion of guanine (G) and cytosine (C) bases in each selected DNA sequence must be exactly 50%, ensuring thermodynamic stability.  \nHamming distance constraint between sequences: The Hamming distance between any two distinct DNA sequences in the solution set must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nHamming distance constraint for reverse complement: The Hamming distance between any selected DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal stability constraint: The last base of each selected DNA sequence must be either C (2) or G (3), ensuring enhanced binding stability at the sequence termini.  \nSelection constraint: Exactly 6 DNA sequences must be selected from the predefined word list.  \n\n4. Objective Function  \nMaximize sequence diversity by maximizing the minimum Hamming distance between any two selected DNA sequences in the solution set.  \n\n5. Data Specification  \nThe input file \"/data/word.txt\" contains the predefined word list in the following format:  \nEach line represents a valid DNA sequence as a comma-separated list of integers enclosed in brackets.  \nExample:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[2, 3, 0, 1, 2, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for sequence selection: For each candidate DNA sequence in the predefined word list, a binary variable indicates whether the sequence is included in the final design set (1 if selected, 0 otherwise).  \nSequence composition variables: For each selected DNA sequence, variables represent the counts of each nucleotide type (A, T, G, C) within the sequence.  \nHamming distance variables: For each pair of selected DNA sequences, variables represent the Hamming distance between the sequences. Similarly, for each selected DNA sequence, a variable represents the Hamming distance between the sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: The total number of DNA sequences to include in the final set is fixed at 6.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nPredefined word list: A list of valid DNA sequences, where each sequence is represented as a string of length 8 containing the characters {A, T, G, C}.  \nGC content requirement: For each selected DNA sequence, the proportion of guanine (G) and cytosine (C) bases must be exactly 50%.  \nHamming distance thresholds:  \n- Between any two selected DNA sequences, the Hamming distance must be at least 4.  \n- Between any selected DNA sequence and its reverse complement, the Hamming distance must be at least 4.  \nGlobal base composition balance: Across all selected DNA sequences, the difference in the total counts of any two nucleotide types (A, T, G, or C) must not exceed 2.  \n\n3. Constraints  \nSequence selection constraints: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraints: For each selected DNA sequence, the number of guanine (G) and cytosine (C) bases must equal half the sequence length (4 bases for a sequence length of 8).  \nHamming distance constraints:  \n- Pairwise Hamming distance: For any pair of selected DNA sequences, the number of differing positions between the sequences must be at least 4.  \n- Reverse complement Hamming distance: For each selected DNA sequence, the number of differing positions between the sequence and its reverse complement must be at least 4.  \nGlobal base composition balance constraints: Across all selected DNA sequences, the absolute difference in the total counts of any two nucleotide types (A, T, G, or C) must not exceed 2.  \n\n4. Objective Function  \nThere is no explicit optimization objective in this problem; the goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence in the following format: a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n```\n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n...  \n```",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 DNA sequences, each represented as an ordered list of 8 integers, where each integer corresponds to a nucleotide (0=A, 1=T, 2=C, 3=G). Each sequence is selected from a predefined word list of valid nucleotide combinations.  \nPairwise Hamming distance variables: Integer variables representing the pairwise Hamming distances between all pairs of DNA sequences.  \nReverse complement Hamming distance variables: Integer variables representing the Hamming distance between each DNA sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nAlphabet: The nucleotide alphabet is {A, T, C, G}, represented as {0, 1, 2, 3}.  \nWord list: A predefined list of valid DNA sequences, provided in the input file, where each sequence is represented as an ordered list of 8 integers.  \nGC content requirement: The GC content (proportion of guanine and cytosine bases) for each sequence must be exactly 50%.  \nMinimum pairwise Hamming distance: The Hamming distance between any two distinct DNA sequences must be at least 4.  \nMinimum reverse complement Hamming distance: The Hamming distance between each DNA sequence and its reverse complement must be at least 4.  \nDinucleotide repetition constraint: Any dinucleotide (sequence of two consecutive bases) is prohibited from appearing more than once across all positions in all sequences.  \n\n3. Constraints  \nSequence selection constraints: Each DNA sequence must be selected from the predefined word list of valid nucleotide combinations.  \nGC content constraints: The GC content of each DNA sequence must be exactly 50%, meaning that exactly 4 out of the 8 bases in the sequence must be either guanine (G) or cytosine (C).  \nPairwise Hamming distance constraints: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sufficient diversity and discrimination.  \nReverse complement Hamming distance constraints: The Hamming distance between each DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nDinucleotide repetition constraints: Any dinucleotide (sequence of two consecutive bases) is prohibited from appearing more than once across all positions in all sequences, eliminating repeated dinucleotide motifs.  \n\n4. Objective Function  \nThere is no explicit optimization objective. The goal is to find a feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a DNA sequence, formatted as a comma-separated list of integers enclosed in brackets (e.g., [0,1,2,3,0,1,2,3]).",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Define 6 decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base in a sequence is represented as an integer from the set {0, 1, 2, 3}, corresponding to nucleotide bases A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nPredefined word list: A set of valid DNA sequences is provided in the input file. Each sequence in this list consists of exactly 8 bases and adheres to basic biological feasibility criteria.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%, ensuring thermodynamic stability.  \nHamming distance threshold: The minimum Hamming distance between any pair of distinct DNA sequences is 4.  \nReverse complement constraint: The minimum Hamming distance between any DNA sequence and its reverse complement is 4.  \nForbidden motif: The subsequence ACTG is not allowed in any DNA sequence.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring diversity and avoiding cross-hybridization.  \nReverse complement constraint: For each DNA sequence, the Hamming distance to its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nForbidden motif constraint: None of the 6 DNA sequences may contain the subsequence ACTG at any position.  \n\n4. Objective Function  \nThere is no optimization objective in this problem. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets. For example:  \n```\n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n```",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Each DNA sequence is represented as an array of 8 decision variables, where each variable corresponds to a nucleotide at a specific position in the sequence and can take values from {0, 1, 2, 3}, representing A, T, C, and G respectively.  \nSet of sequences: A decision variable set containing 6 DNA sequences, each 8 bases in length, selected from the predefined word list.  \n\n2. Parameters and Input Data  \nSequence length: Each DNA sequence must consist of exactly 8 bases.  \nNumber of sequences: The solution consists of exactly 6 DNA sequences.  \nGC content requirement: Each sequence must have exactly 50% GC content (4 bases out of 8 must be either G or C).  \nWord list: A predefined list of valid DNA sequences, provided in the input file \"word.txt\", containing biologically feasible nucleotide combinations.  \nBase encoding: 0=A, 1=T, 2=C, 3=G.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must contain exactly 4 occurrences of G or C bases to ensure thermodynamic stability.  \nHamming distance constraint between sequences: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nHamming distance constraint with reverse complement: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal base constraint: The last base of each DNA sequence must be either C (2) or G (3) to provide enhanced terminal binding stability.  \nBase composition equilibrium constraint: Across all 6 DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2, ensuring overall compositional balance.  \n\n4. Objective Function  \nNo explicit optimization objective; the problem is a feasibility problem aiming to construct 6 DNA sequences that satisfy all constraints.  \n\n5. Data Specification  \nThe input file \"word.txt\" located in the data subdirectory contains the predefined list of valid DNA sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: A set of 6 decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base is selected from the alphabet {0, 1, 2, 3}, where 0 = A, 1 = T, 2 = C, and 3 = G.  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid DNA sequences, each represented as a sequence of 8 integers from the alphabet {0, 1, 2, 3}. This list ensures that only biologically feasible sequences are considered.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content, meaning 4 of the 8 bases must be either guanine (G) or cytosine (C).  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences in the set must be at least 4.  \nReverse complement distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must also be at least 4.  \nTerminal base requirement: The last base of each DNA sequence must be either C (2) or G (3).  \nDinucleotide repetition prohibition: Any dinucleotide (sequence of two consecutive bases) may appear at most once across all positions in all DNA sequences.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) or cytosine (C) bases to ensure 50% GC content.  \nHamming distance constraint: For any two distinct DNA sequences in the set, the number of differing positions (Hamming distance) must be at least 4.  \nReverse complement constraint: For each DNA sequence, the Hamming distance between the sequence and its reverse complement must be at least 4. The reverse complement is defined as the sequence obtained by reversing the order of the bases and replacing each base with its complement (0  1, 2  3).  \nTerminal base constraint: The final base (8th position) of each DNA sequence must be either C (2) or G (3).  \nDinucleotide repetition constraint: No dinucleotide (pair of consecutive bases) may appear more than once across all positions in all DNA sequences. For example, if the dinucleotide (2, 3) appears at position 3-4 in one sequence, it cannot appear again in any position in the same or another sequence.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 DNA sequences, each 8 bases in length, that satisfies all the above constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in square brackets, where 0 = A, 1 = T, 2 = C, and 3 = G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[2, 3, 0, 1, 2, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSelection variables for DNA sequences: Binary decision variables indicating whether each valid DNA sequence from the predefined word list is selected as part of the solution set.  \nDNA sequence composition variables: Binary decision variables for each nucleotide position within each selected DNA sequence, representing whether the position contains adenine (A), thymine (T), cytosine (C), or guanine (G).  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 DNA sequences must be constructed.  \nSequence length: Each DNA sequence must be exactly 8 bases in length.  \nWord list: A predefined set of valid DNA sequences, each represented as a sequence of integers where 0=A, 1=T, 2=C, and 3=G.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two selected DNA sequences must be at least 4.  \nReverse complement: The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal stability: The last base of each DNA sequence must be either cytosine (C) or guanine (G).  \nForbidden subsequence: The subsequence ACTG must not appear in any DNA sequence.  \n\n3. Constraints  \nSelection constraints: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraints: The number of guanine (G) and cytosine (C) bases in each DNA sequence must be equal to half of the sequence length, ensuring a GC content of precisely 50%.  \nHamming distance constraints: The Hamming distance between any pair of selected DNA sequences must be at least 4, ensuring sufficient diversity between sequences.  \nReverse complement constraints: The Hamming distance between any selected DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and unwanted secondary structures.  \nTerminal stability constraints: The last base of each DNA sequence must be either cytosine (C) or guanine (G), ensuring enhanced binding stability at the sequence terminus.  \nForbidden subsequence constraints: The subsequence ACTG must not appear in any DNA sequence, preventing the inclusion of undesirable nucleotide motifs.  \n\n4. Objective Function  \nMaximize the diversity of the selected DNA sequences while satisfying all biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line of the file represents a DNA sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Six decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base in a sequence is represented as an integer from the set {0, 1, 2, 3}, corresponding to the nucleotides A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nNumber of sequences: Six DNA sequences must be designed.  \nSequence length: Each sequence is exactly 8 bases long.  \nWord list: A predefined set of valid DNA sequences, provided as input, from which all designed sequences must be selected.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%, corresponding to 4 out of 8 bases being either G or C.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nBase composition balance: Across all six sequences, the difference in the total number of any two types of bases (A, T, C, or G) must not exceed 2.  \nDinucleotide repetition prohibition: Any base sequence of length 2 (dinucleotide) must not appear more than once within a single DNA sequence.  \n\n3. Constraints  \nSelection constraint: Each DNA sequence must be selected from the predefined word list of valid nucleotide combinations.  \nGC content constraint: Each DNA sequence must have exactly 4 guanine (G) or cytosine (C) bases among its 8 positions, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nBase composition balance constraint: Across all six DNA sequences, the difference in the total number of any two types of bases (A, T, C, or G) must not exceed 2, ensuring compositional equilibrium.  \nDinucleotide repetition constraint: Within each DNA sequence, no dinucleotide (any base sequence of length 2) can appear more than once, eliminating repeated motifs that could cause unintended recognition patterns.  \n\n4. Objective Function  \nThe objective is to construct a set of six DNA sequences that simultaneously satisfies all the biochemical and structural constraints. There is no explicit optimization criterion beyond satisfying the constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0 represents A, 1 represents T, 2 represents C, and 3 represents G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 DNA sequences, each of length 8, where each position in a sequence is represented by an integer variable taking values from {0, 1, 2, 3}, corresponding to the nucleotide bases A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nPredefined word list: A list of valid DNA sequences, each 8 bases long, provided as input. Each sequence in the list is represented as a comma-separated array of integers where 0=A, 1=T, 2=C, and 3=G.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content, meaning exactly 4 out of the 8 positions in the sequence must be either G (3) or C (2).  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences in the solution set must be at least 4.  \nReverse complement distance: The Hamming distance between each DNA sequence and its reverse complement must be at least 4. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base with its complement (A  T, C  G).  \nBase composition balance: Across all 6 DNA sequences, the total number of occurrences of any two nucleotide types (A, T, C, G) must differ by no more than 2.  \nForbidden subsequence: None of the generated DNA sequences may contain the subsequence ACTG.  \n\n3. Constraints  \nValidity constraint: Each DNA sequence must be selected from the predefined word list of valid sequences.  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) or cytosine (C) bases, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct DNA sequences in the solution set must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement constraint: The Hamming distance between each DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nBase composition balance constraint: Across all 6 DNA sequences, the total count of any two nucleotide bases (A, T, C, G) must differ by no more than 2, maintaining compositional equilibrium.  \nForbidden subsequence constraint: None of the DNA sequences may contain the subsequence ACTG.  \n\n4. Objective Function  \nNot applicable. The objective is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[1, 0, 3, 2, 1, 0, 3, 2]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: A set of 6 variables, each representing one DNA sequence to be designed, where each sequence is composed of exactly 8 bases. Each base is selected from the predefined nucleotide set {0=A, 1=T, 2=C, 3=G}.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 DNA sequences are to be designed.  \nSequence length: Each sequence is exactly 8 bases long.  \nValid nucleotide combinations: A predefined word list containing all valid 8-base DNA sequences, provided in the input data file.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two different sequences must be at least 4.  \nSelf-complementarity threshold: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nDinucleotide repetition constraint: No dinucleotide (pair of consecutive bases) may appear more than once across all positions in all sequences.  \nForbidden subsequence: The subsequence ACTG is not allowed to appear in any of the designed sequences.  \n\n3. Constraints  \nSequence validity constraints: Each DNA sequence must be selected from the predefined word list of valid 8-base nucleotide combinations.  \nGC content constraints: Each sequence must have exactly 4 guanine (G) and cytosine (C) bases, ensuring a GC content of 50%.  \nHamming distance constraints: The Hamming distance between any two distinct sequences must be at least 4. This ensures sufficient diversity and avoids cross-hybridization.  \nSelf-complementarity constraints: The Hamming distance between each sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nDinucleotide repetition constraints: No dinucleotide (e.g., AA, AT, CG) may appear more than once across all positions in all sequences, eliminating repeated motifs.  \nForbidden subsequence constraints: The subsequence ACTG is prohibited from appearing in any position of any sequence.  \n\n4. Objective Function  \nThe objective is to construct exactly 6 DNA sequences of length 8 that simultaneously satisfy all biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for sequence composition: For each position in each DNA sequence, a binary variable indicates whether the base at that position is adenine (A), thymine (T), cytosine (C), or guanine (G).  \nSequence selection variables: Binary variables indicating whether a specific DNA sequence from the predefined word list is selected as part of the final set.  \n\n2. Parameters and Input Data  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nBase types: Four possible bases (A, T, C, G), encoded as integers (0, 1, 2, 3).  \nPredefined word list: A set of valid DNA sequences provided in the input file \"word.txt\", where each line contains a sequence represented as a comma-separated list of integers enclosed in brackets.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two different DNA sequences must be at least 4.  \nReverse complement distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal base requirement: The last base of each DNA sequence must be either cytosine (C) or guanine (G).  \nBase composition equilibrium: Across all DNA sequences, the difference in the total number of any two types of bases (A, T, C, G) must not exceed 2.  \nDinucleotide repetition limit: Any base sequence of length 2 (dinucleotide) is prohibited from appearing more than once in any DNA sequence.  \n\n3. Constraints  \nSequence selection constraints: Each of the 6 DNA sequences must be selected from the predefined word list, ensuring biological feasibility.  \nGC content constraints: The number of guanine (G) and cytosine (C) bases in each DNA sequence must account for exactly 50% of the total sequence length (i.e., 4 out of 8 bases).  \nHamming distance constraints: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sufficient diversity and discrimination between sequences.  \nReverse complement constraints: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal base constraints: The last base of each DNA sequence must be either cytosine (C) or guanine (G), ensuring enhanced terminal binding stability.  \nBase composition equilibrium constraints: Across all designed DNA sequences, the difference in the total number of any two types of bases (A, T, C, G) must not exceed 2, maintaining compositional balance.  \nDinucleotide repetition constraints: Any base sequence of length 2 (dinucleotide) must not appear more than once within any DNA sequence, avoiding repeated motifs that could cause unintended molecular interactions.  \n\n4. Objective Function  \nMaximize the feasibility of the designed DNA sequences by ensuring compliance with all biochemical and structural constraints while constructing exactly 6 sequences of 8 bases each.  \n\n5. Data Specification  \nThe input file \"word.txt\" located in the data subdirectory follows this format:  \nEach line contains a single DNA sequence represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: For each DNA sequence to be designed, a variable representing the selection of a valid sequence from the predefined word list. Each sequence is represented as an ordered list of 8 bases, where each base is one of {0=A, 1=T, 2=C, 3=G}.  \n\n2. Parameters and Input Data  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases in length.  \nPredefined word list: A list of valid DNA sequences, each 8 bases long, provided in the input file.  \nBase encoding: Bases are encoded as integers (0=A, 1=T, 2=C, 3=G).  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have a GC content of exactly 50%, meaning it must contain exactly 4 guanine (G) and cytosine (C) bases in total.  \nHamming distance constraint between sequences: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sufficient diversity and discrimination.  \nHamming distance constraint for reverse complements: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal base constraint: The last base of each DNA sequence must be either cytosine (C) or guanine (G) to enhance terminal binding stability.  \nBase composition equilibrium constraint: Across all 6 DNA sequences, the difference in the total count of any two base types (A, T, C, G) must not exceed 2, ensuring overall compositional balance.  \nForbidden subsequence constraint: None of the DNA sequences may contain the specific subsequence ACTG, which must be excluded to avoid undesired functional patterns.  \n\n4. Objective Function  \nNo explicit optimization objective is specified. The goal is to find a feasible set of 6 DNA sequences that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n```\n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n...  \n```",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Represent each DNA sequence to be designed, where each sequence is a fixed-length vector of integers. Each integer corresponds to a nucleotide base (0=A, 1=T, 2=C, 3=G).  \nGC content variables: Binary variables for each position in the sequence, indicating whether the nucleotide is guanine (G) or cytosine (C).  \nHamming distance variables: Integer variables representing the Hamming distance between pairs of DNA sequences and between each sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nNumber of sequences: The total number of DNA sequences to be designed, specified as 6.  \nSequence length: Fixed length of each DNA sequence, specified as 8 bases.  \nValid nucleotide combinations: Predefined word list containing valid sequences of length 8, read from the input file \"word.txt\".  \nGC content threshold: Each sequence must have exactly 50% GC content (4 bases out of 8 must be either G or C).  \nMinimum Hamming distance: Required minimum Hamming distance of 4 between any two distinct DNA sequences and between each sequence and its reverse complement.  \nBase type difference limit: Across all generated sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2.  \nDinucleotide repetition limit: Any base sequence of length 2 (dinucleotide) must not appear more than once in any DNA sequence.  \nProhibited subsequence: The subsequence ACTG must not appear in any DNA sequence.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have exactly 4 guanine (G) or cytosine (C) bases to achieve 50% GC content.  \nHamming distance constraint: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sufficient diversity. Similarly, the Hamming distance between each DNA sequence and its reverse complement must be at least 4, preventing self-hybridization.  \nBase type balance constraint: Across all generated DNA sequences, the total count of any two types of bases (A, T, C, G) must differ by no more than 2, ensuring compositional equilibrium.  \nDinucleotide repetition constraint: Any dinucleotide sequence (e.g., AA, AT, GC, etc.) must not appear more than once within any DNA sequence.  \nProhibited subsequence constraint: The subsequence ACTG must not appear in any DNA sequence.  \n\n4. Objective Function  \nMaximize sequence diversity by ensuring all constraints are satisfied while generating the specified number of sequences.  \n\n5. Data Specification  \nThe input file \"word.txt\" is located in the data subdirectory and contains a list of valid DNA sequences. Each sequence is represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. Each line in the file corresponds to one valid sequence.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 sequences, each of length 8, where each position in a sequence is represented by an integer variable taking values from the set {0, 1, 2, 3}, corresponding to the nucleotide bases A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid DNA sequences, provided as input, containing nucleotide combinations that are biologically feasible.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two distinct sequences must be at least 4.  \nReverse complement distance: The minimum Hamming distance between any sequence and its reverse complement must be at least 4.  \nTerminal stability: The last base in each sequence must be either C or G.  \nBase type balance: Across all sequences, the difference in the total count of any two base types (A, T, C, G) must not exceed 2.  \nDinucleotide repetition constraint: No dinucleotide (subsequence of length 2) may appear more than once within any sequence.  \nExclusion of specific motifs: The tetranucleotide subsequence ACTG is prohibited from appearing in any sequence.  \nNumber of sequences: Exactly 6 sequences are to be generated.  \nSequence length: Each sequence must be exactly 8 bases long.  \n\n3. Constraints  \nGC content constraint: Each sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct sequences in the set must be at least 4. This ensures sufficient dissimilarity between sequences to avoid cross-hybridization.  \nReverse complement constraint: The Hamming distance between any sequence and its reverse complement must be at least 4. This prevents self-hybridization and the formation of secondary structures.  \nTerminal stability constraint: The last base of each sequence must be either C (2) or G (3).  \nBase type balance constraint: Across all 6 sequences, the difference in the total count of any two base types (A, T, C, G) must not exceed 2, maintaining compositional equilibrium.  \nDinucleotide repetition constraint: No dinucleotide (e.g., AA, AT, GC) may appear more than once within any single sequence, eliminating repeated motifs.  \nExcluded motif constraint: The subsequence ACTG is not permitted in any sequence, ensuring exclusion of this specific tetranucleotide motif.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 DNA sequences, each of length 8, that satisfies all biochemical and structural constraints. There is no explicit optimization criterion beyond satisfying the constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence in the format of a comma-separated list of integers enclosed in brackets, where 0 = A, 1 = T, 2 = C, and 3 = G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a vehicle travels directly from one customer location to another. For each pair of customer locations (i, j) and each vehicle k, a variable is defined to represent whether the vehicle k travels from i to j.  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer location. One variable is defined for each customer and each vehicle.  \n\n2. Parameters and Input Data  \nNumber of customers and vehicles: Total number of customer locations to be served and the number of unmanned vehicles available for deliveries.  \nDepot location: The central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, their coordinates (x, y), demand (not used in this variant), service time, ready time (earliest time the customer can be served), and due time (latest time the customer can be served).  \nDistance matrix: A precomputed symmetric matrix where each entry represents the Euclidean distance between two locations (customers or depot).  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nSubtour elimination constraints: The generated set of delivery paths must be logically conflict-free, ensuring no disjoint cycles exist in the solution.  \nTime window constraints: Each vehicle must arrive at a customer location within the specified ready time and due time for that customer. Additionally, the service time at each customer must be respected before the vehicle can proceed to the next location.  \nTravel time constraints: The arrival time at a customer location must account for the travel time from the preceding location in the route.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled by each vehicle along its route.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of customers and the number of vehicles.  \n- Second line: Two integers representing the x-coordinate and y-coordinate of the depot.  \n- Subsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand (ignored in this variant), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle travels directly between two customer locations (or between the depot and a customer location).  \nArrival time variables: Continuous variables representing the time at which each unmanned vehicle arrives at each customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by each unmanned vehicle upon arriving at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customers: Total count of customer locations to be served.  \nDepot location: Coordinates of the central depot where all unmanned vehicles begin and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates (x, y): The geographical location of the customer.  \n  - Demand: The quantity of goods required by the customer.  \n  - Time window: The ready time and due time defining the interval during which the customer must be visited.  \n  - Service time: The duration required to unload goods at the customer location.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, representing the upper limit of goods it can carry.  \nTravel distances: Matrix of pairwise distances between all locations (customers and depot), calculated based on their coordinates.  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one unmanned vehicle, ensuring complete service coverage without duplication.  \nCapacity constraints: The total load carried by each unmanned vehicle must not exceed its maximum load capacity at any point during its route.  \nDepot constraints: Each unmanned vehicle must depart from the central depot at the start of its route and return to the same depot at the end of its route.  \nTime window constraints: Each customer must be visited within its specified time window, meaning the arrival time at the customer location must fall between the ready time and due time.  \nService time constraints: After arriving at a customer location, each unmanned vehicle must remain at the location for the duration of the specified service time before proceeding to the next location.  \nNon-overlapping constraints: Delivery paths must be conflict-free, ensuring no overlapping assignments or infeasible route configurations.  \nFlow conservation constraints: For each unmanned vehicle, the number of incoming routes to a customer location must equal the number of outgoing routes, ensuring logical continuity of the delivery path.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of unmanned vehicles, defined as the sum of distances traveled across all routes, to reduce operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the depot location.  \nSubsequent lines (one per customer): Seven columns containing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle and each pair of customer points (including the depot), a binary decision variable indicating whether the vehicle travels directly between the two points.  \nArrival time variables: For each customer point, a continuous variable representing the time at which a vehicle arrives to begin servicing the customer.  \nLoad variables: For each vehicle and each customer point, a continuous variable representing the cumulative load carried by the vehicle upon arrival at that point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nNumber of customer points: Total number of customer locations to be served, excluding the depot.  \nDepot location: Coordinates of the central depot, where all vehicles start and end their routes.  \nCustomer data: For each customer point, the following information is provided:  \n- Coordinates: (x, y) position of the customer point in the distribution network.  \n- Demand: Amount of goods required by the customer.  \n- Time window: Ready time (earliest time the customer can be served) and due time (latest time the customer must be served).  \n- Service time: Duration required to complete delivery at the customer location.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, specifying the upper limit of goods it can carry.  \nDistance matrix: Precomputed pairwise distances between all points (depot and customer locations) in the network.  \n\n3. Constraints  \nVehicle capacity constraints: The total goods delivered by any vehicle at any point in its route must not exceed the vehicle's maximum load capacity.  \nCustomer assignment constraints: Each customer point must be visited exactly once by one unmanned vehicle, and the entire demand of the customer must be fulfilled in a single visit.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nRoute continuity constraints: If a vehicle travels from point A to point B, it must depart from point A and arrive at point B without skipping intermediate locations.  \nService point exclusion constraint: Service Point No. 5 is excluded from the distribution network and must not appear in any delivery route.  \nTime window constraints: Each vehicle must arrive at a customer location within the specified time window (between ready time and due time). If the vehicle arrives early, it must wait until the ready time to begin service.  \nService time constraints: The time spent at each customer location must include the specified service duration before proceeding to the next location.  \nNon-overlapping route constraints: The routes assigned to different vehicles must not overlap in a way that results in conflicting or infeasible assignments.  \nMinimization of travel distance: The total distance traveled by all vehicles must be minimized, ensuring efficient routing and reducing operational costs.  \n\n4. Objective Function  \nMinimize the total travel distance of all unmanned vehicles, defined as the sum of the distances traveled along all selected routes in the solution.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of customer points and the number of vehicles.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the depot.  \nSubsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nDistance matrix: A separate precomputed file or inline section providing pairwise distances between all points in the network.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a vehicle travels directly from one customer location to another.  \nVisit variables: Binary decision variables representing whether a customer location is visited by a specific vehicle.  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nNumber of customer locations: Total count of customer points to be served, including the central depot.  \nCustomer data: Each customer location is defined by its coordinates (x, y), demand, ready time, due time, and service time.  \nDepot location: Coordinates of the central depot, from which all vehicles depart and return.  \nMaximum load capacity: Each vehicle has a load capacity limit of 180 units, although this limit is relaxed in this problem variant.  \n\n3. Constraints  \nVisit constraints: Each customer location must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nConflict-free route constraints: The set of delivery paths generated must be logically executable, meaning no overlapping assignments or impossible route configurations.  \nTime window constraints: Vehicles must arrive at each customer location within the specified ready time and due time intervals.  \nService time constraints: After arriving at a customer location, each vehicle must remain for the duration of the specified service time before continuing to the next location.  \nTravel constraints: Vehicles must follow a feasible sequence of customer visits, forming continuous routes without any breaks or disconnections.  \n\n4. Objective Function  \nMinimize the total travel distance of the fleet, defined as the sum of distances traveled by all vehicles across their respective routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer locations (including the depot).  \nSubsequent lines (one per customer location): Seven columns representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nThe depot is included as the first customer location in the file, with demand set to zero and service time set to zero.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nArrival time variables at each customer point: Represent the time at which each vehicle arrives at a specific customer location, respecting time window constraints.  \nBinary assignment variables: Indicate whether a specific customer point is assigned to a specific vehicle, ensuring each customer is visited exactly once.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customer points: Total count of customer locations to be visited, excluding Service Point No. 5.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer information: For each customer point, the following data is provided:  \n- Coordinates (x, y) representing the location of the customer point.  \n- Ready time and due time defining the time window within which the delivery must occur.  \n- Service time required to complete the delivery at the customer location.  \n\n3. Constraints  \nRoute assignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the depot after completing all assigned deliveries.  \nTime window constraints: Each customer point must be visited within its specified ready time and due time, ensuring timely deliveries.  \nService point exclusion constraint: Service Point No. 5 must not be included in any delivery route or planning consideration.  \nLogical route feasibility constraints: The generated set of delivery routes must be conflict-free and executable, meaning no overlapping assignments or impossible route configurations.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles combined, representing the sum of distances covered across all delivery routes. This objective aims to reduce operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of customer points and number of vehicles.  \nSecond line: Two floating-point numbers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer point): Seven columns containing the customer number, x-coordinate, y-coordinate, demand (unused in this variant), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly from one customer location to another.  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at each customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by each vehicle upon arriving at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nVehicle capacity: Maximum load capacity of each vehicle, fixed at 180 units.  \nNumber of customers: Total number of customer locations to be served, excluding the central depot.  \nDepot location: Coordinates of the central depot, where all vehicles begin and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates (x, y): Spatial location of the customer.  \n  - Demand: Quantity of goods required by the customer.  \n  - Ready time: Earliest time the customer is available to receive the delivery.  \n  - Due time: Latest time by which the delivery must be completed.  \n  - Service time: Time required to unload the goods at the customer location.  \nTravel distances: Euclidean distances between all pairs of locations (including the depot and customer locations), calculated from their coordinates.  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the depot after completing its assigned deliveries.  \nCapacity constraints: The cumulative load carried by a vehicle at any point in its route must not exceed its maximum load capacity of 180 units.  \nTime window constraints: Each customer must be visited within their specified time window, ensuring that the vehicle arrives no earlier than the ready time and no later than the due time.  \nService time constraints: The time spent at each customer location to unload goods must be accounted for in the vehicles schedule.  \nNon-overlap constraints: The routes of different vehicles must not overlap in terms of customer assignments, ensuring that no customer is served by more than one vehicle.  \nSubtour elimination constraints: The solution must not contain any disjoint cycles or sub-routes that do not include the depot, ensuring that each vehicle performs a complete delivery cycle starting and ending at the depot.  \n\n4. Objective Function  \nMinimize the total travel distance of the fleet, defined as the sum of the distances traveled by all vehicles across their respective routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the total number of customers and the number of vehicles.  \n- Second line: Two floating-point numbers representing the x and y coordinates of the central depot.  \n- Subsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly between two customer locations (including the depot).  \nArrival time variables: Continuous decision variables representing the time at which each vehicle arrives at a customer location.  \nLoad variables: Continuous decision variables representing the cumulative load carried by a vehicle when arriving at a specific customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available in the fleet.  \nNumber of customers: Total number of customer locations to be served, excluding the depot.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates (x, y): The location of the customer.  \n  - Demand: The quantity of goods required by the customer.  \n  - Ready time: The earliest time the customer is available to receive the delivery.  \n  - Due time: The latest time the delivery must be completed.  \n  - Service time: The time required to unload goods at the customer location.  \nVehicle capacity: The maximum load capacity of each unmanned vehicle.  \nTravel distances: A matrix containing the distances between all pairs of locations (including the depot and customer locations).  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by exactly one vehicle.  \nDepot return constraints: Each vehicle must start its route at the central depot, visit its assigned customer locations in sequence, and return to the depot.  \nCapacity constraints: The total demand of all customers served by a single vehicle must not exceed the vehicle's maximum load capacity.  \nTime window constraints: Each customer must be visited within their specified time window (between their ready time and due time). The vehicle must arrive at the customer location no earlier than the ready time and no later than the due time.  \nService time constraints: The service time at each customer location must be accounted for in the scheduling of subsequent visits.  \nTravel feasibility constraints: The arrival time at each customer location must respect the travel time required from the previous location.  \nExclusion constraints: Service Point No. 5 must not be included in any delivery route due to its removal from the distribution network.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, defined as the sum of the distances traveled by all vehicles across their respective routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of customers (excluding the depot) and the number of vehicles.  \nSubsequent lines (one per customer, including the depot as the first entry): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each vehicle and each customer, a binary decision variable indicating whether the vehicle visits the customer.  \nSequence variables: For each vehicle, the sequence in which it visits its assigned customer locations.  \nLoad variables: For each vehicle and each customer, a continuous variable representing the cumulative load carried by the vehicle upon leaving the customer.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customers: Total count of customer locations to be served, excluding the depot.  \nVehicle capacity: Maximum load capacity of each vehicle, set to 180 units.  \nDepot location: Central starting and ending point for all vehicles.  \nCustomer data: Each customer is characterized by a unique identifier, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nTravel distances: Euclidean distances between all pairs of locations (customers and depot), computed from their coordinates.  \n\n3. Constraints  \nVehicle capacity constraints: The total load carried by any vehicle at any point in its route must not exceed its maximum capacity of 180 units.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle to satisfy its entire demand.  \nDepot return constraints: Each vehicle must start and end its route at the central depot.  \nRoute feasibility constraints: The sequence of customer visits for each vehicle must be executable, ensuring no overlapping assignments or impossible configurations.  \nService point exclusion constraints: Service Point No. 5 is excluded from all delivery routes and must not be visited by any vehicle.  \nTime window constraints: Each customer must be served within their specified time window (ready time to due time), accounting for travel time and service time.  \nCumulative load constraints: The cumulative load of each vehicle must be updated correctly at each visited customer, reflecting the demand of the customer served.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, computed as the sum of the distances traveled along the assigned routes for all vehicles.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customers (excluding the depot).  \nSubsequent lines (one per customer): Seven columns specifying the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nFinal line: Depot information including its x-coordinate and y-coordinate.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle traverses a particular edge between two customer points or between the depot and a customer point.  \nArrival time variables: Continuous variables representing the time at which each customer point is visited by an unmanned vehicle.  \nVehicle assignment variables: Binary decision variables indicating whether a specific customer point is assigned to a particular unmanned vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nNumber of customer points: Total number of customer locations to be serviced, excluding the central depot.  \nDepot location: Coordinates of the central depot from which all vehicles depart and to which they return.  \nCustomer data: Each customer point is defined by its coordinates, demand, ready time, due time, and service time.  \nTravel distances: Euclidean distances between all pairs of locations (including the depot and customer points), computed using their x and y coordinates.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, fixed at 180 units.  \n\n3. Constraints  \nRoute assignment constraints: Each customer point must be visited exactly once by one unmanned vehicle, ensuring complete service coverage without duplication.  \nDepot connection constraints: Each unmanned vehicle must start its route at the central depot and return to the depot after completing its assigned deliveries.  \nTime window constraints: Each customer point must be visited within its specified time window, defined by the ready time and due time, ensuring adherence to customer availability requirements.  \nService time constraints: The service time at each customer point must be included in the arrival and departure time calculations for the vehicle, ensuring delivery execution.  \nLogical route constraints: The routes assigned to unmanned vehicles must be conflict-free and executable, meaning no overlapping assignments or impossible configurations.  \nCapacity constraints: Although the problem scenario relaxes load capacity limits, the maximum load capacity of each unmanned vehicle is explicitly set to 180 units as a reference parameter.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of unmanned vehicles, representing the sum of distances traveled across all assigned delivery routes. This objective reduces operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer points.  \nSecond line: Two integers representing the x-coordinate and y-coordinate of the depot.  \nSubsequent lines (one per customer point): Seven columns containing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute assignment variables: Binary decision variables indicating whether a specific vehicle traverses a specific route segment (from one customer location to another).  \nArrival time variables: Continuous decision variables representing the time at which each vehicle arrives at a specific customer location.  \nService start time variables: Continuous decision variables representing the time at which each vehicle begins servicing a specific customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nNumber of customer locations: Total number of customer locations requiring service, excluding the central depot.  \nDepot location: Coordinates of the central depot, where all vehicles start and end their routes.  \nCustomer locations: Coordinates of each customer location in the distribution network.  \nTime windows: For each customer location, a time interval [ready time, due time] during which the location must be visited.  \nService times: The duration required to complete the delivery service at each customer location.  \nTravel distances: A matrix specifying the pairwise Euclidean distances between all customer locations and the depot.  \nExcluded locations: Service Point No. 5 is excluded from the distribution network and must not be visited.  \n\n3. Constraints  \nRoute completion constraints: Each vehicle must start and end its route at the central depot.  \nCustomer visit constraints: Each customer location must be visited exactly once by one vehicle.  \nTime window constraints: Each vehicle must arrive at a customer location within the specified time window [ready time, due time] for that location.  \nService sequencing constraints: A vehicle may only begin servicing a customer location after it has arrived at that location.  \nTravel time constraints: The arrival time at a customer location must account for the travel time from the previous location and the service time at the previous location.  \nExcluded location constraint: Service Point No. 5 must not be included in any delivery route.  \nNon-overlapping route constraints: Routes assigned to different vehicles must not overlap in a way that violates logical feasibility or time window requirements.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled along all assigned route segments.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: An integer representing the total number of customer locations (excluding the depot).  \n- Second line: Two integers representing the x and y coordinates of the central depot.  \n- Subsequent lines (one per customer location): Seven columns specifying the customer number, x-coordinate, y-coordinate, demand (not used in this problem), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle travels directly between two customer locations (or between the depot and a customer location).  \nSequence variables: Decision variables representing the order in which customer locations are visited by each unmanned vehicle.  \nArrival time variables: Continuous variables representing the arrival time of each unmanned vehicle at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nNumber of customer locations: Total count of customer points requiring service, excluding the depot and any explicitly excluded locations.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates: x and y coordinates of the customer location.  \n  - Demand: The demand units required by the customer.  \n  - Time window: Ready time (earliest time the customer can be served) and due time (latest time the customer must be served).  \n  - Service time: The time required to complete the delivery at the customer location.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, fixed at 180 units (though not actively constrained in this problem).  \nExcluded locations: Service Point No. 5 is removed from the problem and must not be included in any route or planning.  \n\n3. Constraints  \nRoute assignment constraints: Each customer location must be visited exactly once by one unmanned vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each unmanned vehicle must start and end its route at the central depot.  \nRouting feasibility constraints: The sequence of customer visits by each vehicle must form a valid, non-overlapping route.  \nTime window constraints: Each customer must be visited within their specified time window, ensuring the arrival time falls between the ready time and due time.  \nService exclusion constraint: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \nTravel continuity constraints: If a vehicle travels from location A to location B, the arrival time at location B must account for the travel time from A to B and the service time at A.  \nNon-negative time constraints: Arrival times and service start times must be non-negative for all customer locations.  \nFleet size constraints: The total number of vehicles used must not exceed the available fleet size.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet, calculated as the sum of distances traveled along all routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customer locations (excluding the depot).  \nSecond line: Coordinates of the depot (x-coordinate and y-coordinate).  \nSubsequent lines (one per customer): Seven columns representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nService Point No. 5 is excluded and should not appear in the solution.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each vehicle and each pair of customer locations (including the depot), a binary decision variable indicates whether the vehicle travels directly between these two locations.  \nVisit variables: For each customer and each vehicle, a binary decision variable indicates whether the customer is visited by the vehicle.  \nArrival time variables: For each customer and each vehicle, a continuous variable represents the time at which the vehicle arrives at the customer location.  \nLoad variables: For each vehicle at each customer, a continuous variable represents the cumulative load being carried by the vehicle upon arrival at that customer.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nVehicle capacity: Maximum load capacity of each vehicle, set to 180 units.  \nDepot location: The central depot coordinates from which all vehicles depart and to which they must return.  \nCustomer data: For each customer, the following parameters are defined:  \n- Customer location: x and y coordinates of the customer.  \n- Demand: The amount of goods to be delivered to the customer.  \n- Time window: Ready time and due time defining the permissible time range for delivery.  \n- Service time: Time required to unload goods at the customer location.  \nTravel distances: Euclidean distances between all pairs of locations (depot and customers).  \n\n3. Constraints  \nRoute constraints: Each vehicle must start and end its route at the depot.  \nVisit constraints: Each customer must be visited exactly once by exactly one vehicle.  \nTime window constraints: The arrival time at each customer location must lie within the specified time window for that customer.  \nCapacity constraints: The cumulative load carried by a vehicle at any point in its route must not exceed the vehicle's maximum load capacity of 180 units.  \nExclusion constraint: Service Point No. 5 must be excluded from all routes and planning considerations.  \nSubtour elimination constraints: The routes must form a single connected path for each vehicle, avoiding disconnected or circular subtours.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled along all selected routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customers (excluding the depot).  \nSecond line: Two integers representing the x and y coordinates of the depot.  \nSubsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute assignment variables: Binary decision variables indicating whether a specific vehicle travels between two customer locations (including the depot).  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at a customer location.  \nLoad variables: Continuous variables representing the total load carried by a vehicle immediately after visiting a customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of autonomous vehicles available for routing.  \nNumber of customer locations: Total count of customer points to be served, excluding the central depot.  \nDepot location: Coordinates of the central depot, where all vehicles start and end their routes.  \nCustomer data: For each customer location, the following information is provided:  \n- Coordinates (x, y): Spatial location of the customer.  \n- Demand: Quantity of goods required by the customer.  \n- Time window: Ready time and due time, defining the acceptable time interval for service.  \n- Service time: Time required to complete the delivery at the customer location.  \nVehicle capacity: Maximum load capacity of each vehicle, fixed at 180 units.  \nTravel distances: Precomputed matrix of Euclidean distances between all pairs of locations (including the depot and customer locations).  \nRemoved service points: Customer locations explicitly excluded from the distribution network (e.g., Service Point No. 5).  \n\n3. Constraints  \nRoute assignment constraints: Each customer location must be visited exactly once by one vehicle.  \nDepot visit constraints: Each vehicle must start and end its route at the central depot, forming a closed delivery path.  \nTime window constraints: Each vehicle must arrive at a customer location within the specified time window for that location.  \nCapacity constraints: The total load carried by a vehicle at any point in its route must not exceed the vehicle's maximum load capacity of 180 units.  \nService exclusion constraints: Customer locations explicitly removed from the network (e.g., Service Point No. 5) must not be included in any vehicle's route.  \nLogical consistency constraints: Routes must be conflict-free, ensuring that no vehicle serves two locations simultaneously and that all generated routes are executable.  \nNon-negativity constraints: Arrival times and loads must be non-negative for all locations and vehicles.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled along all selected routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of vehicles and number of customer locations (excluding the depot).  \n- Second line: Two floats representing the x and y coordinates of the central depot.  \n- Subsequent lines (one per customer location): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \n- Precomputed distance matrix: Square matrix provided separately, with each entry representing the Euclidean distance between two locations (including the depot).",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable representing whether the demand of the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of distinct demand areas requiring service and potential sites where charging stations can be constructed.  \nCost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) of assigning a demand area to a specific candidate location.  \nDemand values: A list of predicted energy demand values, one for each demand area, specifying the total amount of energy required to serve that area.  \nFixed construction costs: A list of fixed costs associated with activating each candidate location as a charging station.  \nCapacity limits: A list of maximum power capacities for each candidate location, indicating the total demand that can be served by a single charging station.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any single charging station must not exceed its maximum power capacity.  \nActivation constraints: A candidate location can only serve demand if it is activated as a charging station.  \nAssignment constraints: Each demand area can only be assigned to candidate locations within its feasible set, as defined by the cost matrix or other problem-specific restrictions.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- The fixed construction costs for all activated charging stations.  \n- The total service costs for all assigned demand areas, based on the cost matrix values.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Next [number of demand areas] lines: Each line contains [number of candidate locations] integers, representing the service cost matrix.  \n- Next line: A list of integers representing the demand values for each demand area.  \n- Next line: A list of integers representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable representing whether the demand area is assigned to a specific charging station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring charging services and candidate locations available for station activation.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) of assigning a demand area to a specific candidate location.  \nDemand values: A vector specifying the charging demand for each demand area, representing the total number of users or charging events that must be served.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum number of users or charging events that each candidate location can accommodate.  \n\n3. Constraints  \nDemand satisfaction constraint: Each demand area must be fully served, ensuring that the total demand for each area is assigned to one or more activated charging stations.  \nCapacity constraints: For each activated charging station, the total assigned demand across all demand areas must not exceed the station's maximum service capacity.  \nActivation constraints: A demand area can only be assigned to a candidate location if the location is activated as a charging station.  \nAssignment exclusivity constraint: Each demand area must be assigned to one or more candidate locations, ensuring complete coverage of all demand areas.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service costs incurred by assigning demand areas to charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A cost matrix of size [number of demand areas  number of candidate locations], where each entry specifies the service cost for assigning a demand area to a candidate location.  \nThird block: A vector of demand values, with one entry per demand area indicating the total demand that must be served.  \nFourth block: A vector of fixed construction costs, with one entry per candidate location specifying the activation cost for that location.  \nFifth block: A vector of capacity limits, with one entry per candidate location specifying the maximum service capacity.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for service zones: For each service zone and candidate location, a binary variable represents whether the demand of the service zone is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total count of defined service zones (e.g., residential areas, commercial centers) and potential site locations for charging stations.  \nCost matrix: A matrix of size [number of service zones  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) between a service zone and a candidate location.  \nDemand values: For each service zone, a predicted charging demand that must be fully served.  \nFixed construction costs: For each candidate location, the fixed cost of activating the site as a charging station.  \nCapacity limits: For each candidate location, the maximum number of users or charging events the station can accommodate.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each service zone must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to a candidate location must not exceed its peak load capacity if the location is activated as a charging station.  \nActivation constraints: A candidate location can only serve demand if it is activated as a charging station.  \nService assignment constraints: Each service zone can only assign its demand to candidate locations within the defined set of potential sites.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, based on the cost matrix representing travel time or distance between service zones and activated charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of service zones and candidate locations.  \nSecond block: A cost matrix [number of service zones  number of candidate locations], where each entry specifies the service cost between a service zone and a candidate location.  \nThird block: Demand values for each service zone, listed as a sequence of integers.  \nFourth block: Fixed construction costs for each candidate location, listed as a sequence of integers.  \nFifth block: Capacity limits for each candidate location, listed as a sequence of integers.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary location variables: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables: For each demand area and candidate location, a binary variable indicates whether the demand of the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas (e.g., residential zones, commercial centers, transportation hubs) and candidate locations for charging stations.  \nDemand values: Predicted energy demand for each demand area, representing the total energy requirement that must be fully served.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry specifies the service cost (e.g., travel time or distance) for assigning a demand area to a candidate location.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum power capacity of each candidate location, representing the upper limit on the total demand that can be served by the location.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any candidate location must not exceed its maximum power capacity.  \nAssignment constraints: Demand from a demand area can only be assigned to a candidate location if the location is activated as a charging station.  \nBinary decision constraints: All decision variables (both location activation and demand assignment) must take binary values (0 or 1).  \n\n4. Objective Function  \nMinimize the combined cost function, which consists of two components:  \n- The total fixed construction cost for all activated charging stations.  \n- The total service cost for all demand assignments, based on the service cost matrix.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Subsequent lines: A [number of demand areas  number of candidate locations] matrix specifying the service cost for assigning each demand area to each candidate location.  \n- Next line: A vector of demand values for each demand area.  \n- Next line: A vector of fixed construction costs for each candidate location.  \n- Final line: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether the location is selected as an active charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand allocation: For each demand area and each candidate location, a binary variable representing whether the demand of the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas to be served and candidate charging station locations available for activation.  \nDemand values: For each demand area, the predicted charging demand, expressed as the total number of charging events or users requiring service.  \nService cost matrix: A [number of demand areas  number of candidate locations] matrix representing the service cost (e.g., travel distance or time) of assigning each demand area to each candidate location.  \nFixed construction costs: For each candidate location, the fixed cost associated with activating it as a charging station.  \nCapacity limits: For each candidate location, the maximum number of charging events or users it can accommodate.  \n\n3. Constraints  \nDemand coverage constraints: The total demand of each demand area must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any candidate charging station must not exceed its maximum service capacity.  \nAssignment constraints: Demand from a demand area can only be assigned to a candidate location if that location is activated as a charging station.  \nBinary variable constraints: All decision variables (both station activation and demand assignment) must take binary values (0 or 1).  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- Fixed construction costs for all activated charging stations.  \n- Total service costs for all demand areas, calculated as the sum of service costs for all assigned demand-location pairs.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Subsequent lines (one per demand area): A row of integers representing the service cost matrix, where each value specifies the cost of assigning the demand area to a candidate location.  \n- Next line: A list of integers representing the demand values for each demand area.  \n- Next line: A list of integers representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether the site is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand allocation: For each service zone and each candidate location, a binary variable indicating whether the demand of a specific service zone is assigned to a specific charging station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total number of service zones where charging demand originates and candidate locations where charging stations can potentially be built.  \nDemand values: For each service zone, the total predicted charging demand (e.g., number of users or charging events).  \nService cost matrix: A matrix where each entry represents the cost (e.g., travel time or distance) of assigning the demand from a specific service zone to a specific candidate location.  \nFixed construction costs: For each candidate location, the fixed cost incurred if the site is activated as a charging station.  \nCapacity limits: For each candidate location, the maximum charging demand (e.g., number of users or charging events) the station can accommodate.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand from each service zone must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its peak load capacity.  \nAssignment constraints: Demand from a service zone can only be assigned to a candidate location if that location is activated as a charging station.  \nBinary decision constraints: All decision variables (activation and assignment variables) must take binary values (0 or 1).  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction costs for all activated charging stations.  \n- The total service costs for allocating the demand from all service zones to the activated charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and the number of candidate locations.  \n- Next section: A cost matrix of dimensions [number of service zones  number of candidate locations], where each entry represents the service cost for assigning demand from a specific service zone to a specific candidate location.  \n- Next line: A list of demand values for each service zone, in order.  \n- Next line: A list of fixed construction costs for each candidate location, in order.  \n- Next line: A list of capacity limits for each candidate location, in order.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAllocation variables for demand areas: For each demand area and each candidate location, a binary variable determines whether the demand from that area is assigned to a specific location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas to be served and candidate locations for potential charging station placement.  \nCost matrix: A matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) for assigning a demand area to a specific candidate location.  \nDemand values: A vector representing the energy demand of each demand area, which must be fully satisfied by the activated charging stations.  \nFixed construction costs: A vector representing the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector representing the maximum power capacity of each candidate location, defining the total demand it can serve if activated.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully satisfied by the activated charging stations. This requires that each demand area is assigned to one or more locations such that the sum of assigned capacities meets or exceeds the areas demand.  \nCapacity constraints: For each activated charging station, the total demand assigned to it across all demand areas cannot exceed its maximum power capacity.  \nFacility activation constraints: A candidate location can only serve demand if it is activated as a charging station. This implies that allocation variables for a location are restricted by the corresponding binary activation variable.  \nDemand allocation constraints: Each demand area must be assigned only to candidate locations from the set of available options, ensuring feasible assignments.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service cost for all demand assignments. The objective reflects the goal of achieving an economically efficient charging network layout by balancing infrastructure costs and user service costs.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nNext [number of demand areas] lines: Each line contains [number of candidate locations] integers representing the service cost matrix, where each entry corresponds to the cost of assigning a specific demand area to a specific candidate location.  \nSubsequent line: A vector of integers representing the energy demand of each demand area.  \nNext line: A vector of integers representing the fixed construction costs for each candidate location.  \nFinal line: A vector of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable determines whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate station, a binary variable indicates whether the demand area is assigned to the candidate station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas to be served and the total number of candidate locations available for potential activation.  \nDemand values: The predicted charging demand for each demand area, representing the number of charging events required.  \nFixed construction costs: The cost to activate each candidate location as a charging station.  \nService cost matrix: A matrix representing the service cost (e.g., distance or travel time) between each demand area and each candidate location.  \nCapacity limits: The maximum number of charging events or users that each activated station can accommodate.  \n\n3. Constraints  \nCoverage constraint: Each demand area must be fully assigned to one or more activated charging stations to ensure all predicted demand is served.  \nCapacity constraint: The total demand assigned to any activated charging station cannot exceed its maximum service capacity.  \nActivation constraint: A candidate location can only serve demand areas if it is activated as a charging station.  \nAssignment constraint: Each demand area can only be assigned to candidate locations that are within its service cost matrix.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- The fixed construction costs for all activated charging stations.  \n- The total service cost for all assigned demand areas, based on the cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nNext nbCustomer  nbLocation lines: Service cost matrix, where each line contains the service cost between a demand area and all candidate locations.  \nNext line: A list of integers representing the demand values for each demand area.  \nNext line: A list of integers representing the fixed construction costs for each candidate location.  \nNext line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for service zones: For each service zone and candidate location, a binary variable represents whether the demand of the service zone is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total number of service zones that require charging services and potential locations where charging stations can be built.  \nService cost matrix: A matrix of size [number of service zones  number of candidate locations] representing the cost of serving each service zone from each candidate location. Costs are typically based on distance or travel time.  \nDemand values: A vector containing the predicted charging demand for each service zone.  \nFixed construction costs: A vector containing the fixed cost of building and activating a charging station at each candidate location.  \nCapacity limits: A vector specifying the maximum charging demand (peak load) that each candidate location can accommodate if activated.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each service zone must be fully satisfied by the candidate locations to which it is assigned.  \nCapacity constraints: The total demand assigned to any activated candidate location cannot exceed its peak load capacity.  \nAssignment constraints: A service zone can only be assigned to a candidate location if the location is activated as a charging station.  \nActivation constraints: A candidate location can only serve demand if it is activated as a charging station.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service costs for all assigned demands.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and candidate locations.  \n- Second section: A cost matrix of size [number of service zones  number of candidate locations], where each entry represents the service cost of assigning a service zone to a candidate location.  \n- Third section: A vector of demand values, one per service zone, indicating the predicted charging demand.  \n- Fourth section: A vector of fixed construction costs, one per candidate location, indicating the cost of building and activating a charging station.  \n- Fifth section: A vector of capacity limits, one per candidate location, indicating the maximum demand that can be served if the location is activated.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for candidate locations: Binary decision variables indicating whether each candidate facility site is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: Integer variables representing the assignment of each demand area to a specific activated charging station.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and candidate facility sites available for potential activation.  \nCost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost between a demand area and a candidate location.  \nDemand values: A vector specifying the predicted energy demand for each demand area, measured in units of power or charging events.  \nFixed construction costs: A vector specifying the fixed cost associated with activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum power capacity or number of charging events each activated location can accommodate.  \nService quality threshold: A maximum transportation cost of 20 units between any demand area and its assigned charging station.  \n\n3. Constraints  \nActivation constraints: A candidate location can only serve demand areas if it is activated as a charging station.  \nCapacity constraints: The total demand assigned to each activated charging station must not exceed its maximum capacity limit.  \nService quality constraints: The transportation cost between any demand area and its assigned charging station must not exceed 20 units.  \nDemand fulfillment constraints: Each demand area must be assigned to exactly one activated charging station, ensuring full coverage of all demand areas.  \n\n4. Objective Function  \nMinimize the combined cost function, which consists of:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total transportation cost incurred by all demand areas to access their assigned charging stations.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond section: A cost matrix of size [number of demand areas  number of candidate locations], with each entry specifying the transportation cost between a demand area and a candidate location.  \nThird section: A vector of demand values for each demand area.  \nFourth section: A vector of fixed construction costs for each candidate location.  \nFifth section: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables\nBinary variables for station activation: For each candidate location, a binary variable indicates whether a charging station is activated at that location.\nAssignment variables for demand areas: For each demand area and candidate location, a binary variable represents whether the demand area is assigned to that location.\n\n2. Parameters and Input Data\nNumber of demand areas and candidate locations: Total count of geographic demand zones and potential sites for charging stations.\nService cost matrix: A matrix representing the transportation cost between each demand area and each candidate location.\nDemand values: Predicted charging demand for each demand area, representing the number of users or charging events that must be served.\nFixed construction costs: The cost associated with constructing a charging station at each candidate location.\nCapacity limits: The maximum number of users or charging events each candidate location can accommodate.\n\n3. Constraints\nDemand fulfillment constraint: Each demand area's charging demand must be fully served by the assigned charging station.\nCapacity constraint: The total demand assigned to any activated charging station must not exceed its service capacity.\nService quality constraint: The transportation cost between any demand area and its assigned charging station must not exceed 20 units.\nAssignment constraint: Each demand area must be assigned to exactly one activated charging station to ensure service.\n\n4. Objective Function\nMinimize the combined cost function, which includes the sum of fixed construction costs for all activated stations and the total service cost for all users, ensuring an economically efficient network layout.\n\n5. Data Specification\nThe input file \"plant_location.data\" follows this format:\nFirst line: Two integers representing the number of demand areas and number of candidate locations.\nSubsequent lines: A cost matrix of size [nbCustomer  nbLocation] representing service costs, followed by demand values for each area, fixed construction costs for each location, and capacity limits for each location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    deployment_cost_to_assigned_station = mdl.element(assignment[c], deployment_cost[c])\n    mdl.add(deployment_cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for location activation: For each candidate site, a binary variable determines whether the location is activated as a charging station (1) or not (0).  \nAssignment variables for service zones: For each service zone, a variable specifies the assigned charging station from the set of activated locations.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total count of service zones requiring coverage and potential site locations for charging stations.  \nService cost matrix: A matrix of dimensions [service zones  candidate locations], where each entry represents the transportation cost between a service zone and a candidate location.  \nDemand values: A vector specifying the predicted charging demand for each service zone.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the peak load capacity for each candidate location, representing the maximum demand it can accommodate.  \nService quality threshold: A fixed value of 20 units, representing the maximum allowable transportation cost between a service zone and its assigned charging station.  \n\n3. Constraints  \nLocation activation constraint: A service zone can only be assigned to a charging station that is activated.  \nDemand satisfaction constraint: The total demand of all service zones assigned to a charging station must not exceed the peak load capacity of that location.  \nService quality constraint: The transportation cost between a service zone and its assigned charging station must not exceed 20 units.  \nAssignment constraint: Each service zone must be assigned to exactly one charging station.  \n\n4. Objective Function  \nMinimize the combined cost function, which consists of:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated as the sum of transportation costs between service zones and their assigned charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and candidate locations.  \n- Second section: A matrix of dimensions [service zones  candidate locations], where each entry specifies the transportation cost between a service zone and a candidate location.  \n- Third section: A list of demand values for each service zone, one value per line.  \n- Fourth section: A list of fixed construction costs for each candidate location, one value per line.  \n- Fifth section: A list of capacity limits for each candidate location, one value per line.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate facility site, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for energy allocation: For each demand area and candidate facility site, a continuous variable represents the amount of energy allocated from the facility to meet the demand of the area.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of defined demand areas requiring energy supply and potential facility sites available for activation.  \nCost matrix: A [number of demand areas  number of candidate locations] matrix specifying the service cost (e.g., travel time or distance) for supplying energy from each candidate facility site to each demand area.  \nDemand values: A vector specifying the predicted energy demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost associated with activating each candidate facility site as a charging station.  \nCapacity limits: A vector specifying the maximum power capacity for each candidate facility site, representing the upper bound on the total energy that can be supplied by the facility.  \nBudget range: A constraint specifying the allowable range for the sum of fixed costs of all activated charging stations, set between 20,000 and 25,000 monetary units.  \n\n3. Constraints  \nDemand satisfaction constraint: The total energy supplied to each demand area must meet or exceed its predicted energy demand, ensuring full service coverage.  \nCapacity constraint: The total energy allocated from each activated facility site to all demand areas must not exceed the maximum power capacity of the site.  \nStation activation constraint: Energy can only be allocated from a facility site if the site is activated as a charging station.  \nBudget constraint: The sum of fixed construction costs for all activated charging stations must fall within the specified budget range of 20,000 to 25,000 monetary units.  \nNon-negativity constraint: All energy allocation variables must be non-negative.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes the sum of fixed construction costs for all activated charging stations and the total service cost for all users. The service cost is derived from the cost matrix and represents the economic efficiency of energy allocation across the network.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate facility locations.  \nSecond block: A [number of demand areas  number of candidate locations] matrix specifying service costs for supplying energy from each facility site to each demand area.  \nThird block: A vector listing the predicted energy demand for each demand area.  \nFourth block: A vector specifying the fixed construction cost for each candidate facility site.  \nFifth block: A vector specifying the maximum power capacity of each candidate facility site.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand of the area is served by the specific location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and candidate locations available for potential charging stations.  \nDemand values: Predicted charging demand for each demand area, representing the required number of charging events to be served.  \nService cost matrix: A matrix where each entry represents the service cost (e.g., based on travel distance or time) for assigning a specific demand area to a specific candidate location.  \nFixed construction costs: The fixed cost of building a charging station at each candidate location.  \nCapacity limits: The maximum service capacity of each candidate location, representing the upper limit on the number of charging events that can be served at that location.  \nBudget range: A strict budget constraint for the total fixed construction costs, defined as a range between 20,000 and 25,000 monetary units.  \n\n3. Constraints  \nDemand satisfaction constraints: Each demand area must be fully served, meaning the total assignment of its demand to candidate locations must equal its predicted demand value.  \nCapacity constraints: The total demand assigned to a candidate location must not exceed its service capacity if the location is activated.  \nActivation constraints: A candidate location can only serve demand if it is activated as a charging station.  \nBudget constraint: The total fixed construction cost of all activated charging stations must lie strictly within the budget range of 20,000 to 25,000 monetary units.  \nAssignment constraints: Each demand area can only be assigned to candidate locations that are activated as charging stations.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction costs of all activated charging stations.  \n- The total service costs for all demand areas, based on the service cost matrix and the assignment of demand to candidate locations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next nbCustomer  nbLocation lines: A matrix where each entry represents the service cost for assigning a specific demand area to a specific candidate location.  \n- Following line: A list of integers representing the predicted charging demand for each demand area.  \n- Following line: A list of integers representing the fixed construction costs for each candidate location.  \n- Final line: A list of integers representing the maximum service capacity for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the site is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for user assignments: For each service zone and candidate location, a continuous variable represents the fraction of the demand from the service zone assigned to the location.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total count of service zones requiring charging services and potential sites for charging station placement.  \nService cost matrix: A matrix of size [number of service zones  number of candidate locations], where each entry represents the cost (e.g., distance or travel time) for users in a service zone to access a specific candidate location.  \nDemand values: A vector of size [number of service zones], where each entry specifies the charging demand predicted for a service zone.  \nFixed construction costs: A vector of size [number of candidate locations], where each entry specifies the fixed cost of constructing a charging station at a specific location.  \nCapacity limits: A vector of size [number of candidate locations], where each entry specifies the peak load capacity of the corresponding site, representing the maximum demand it can serve.  \nBudget range: A fixed range of monetary units (20,000 to 25,000) representing the allowable total budget for constructing charging stations.  \n\n3. Constraints  \nDemand coverage constraint: The total demand from each service zone must be fully assigned to one or more activated charging stations, ensuring complete service coverage.  \nCapacity constraint: For each activated charging station, the total assigned demand across all service zones must not exceed the station's peak load capacity.  \nActivation constraint: Demand can only be assigned to candidate locations that are activated as charging stations.  \nBudget constraint: The sum of fixed construction costs for all activated charging stations must fall within the specified budget range of 20,000 to 25,000 monetary units.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of two components:  \n- The fixed construction costs for all activated charging stations.  \n- The total service costs for all users, calculated based on the assignment of demand from service zones to candidate locations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of service zones and the number of candidate locations.  \nSecond block: A cost matrix of size [number of service zones  number of candidate locations], where each entry specifies the service cost for users in a service zone to access a candidate location.  \nThird block: A vector of size [number of service zones], where each entry specifies the demand for a service zone.  \nFourth block: A vector of size [number of candidate locations], where each entry specifies the fixed construction cost for a candidate location.  \nFifth block: A vector of size [number of candidate locations], where each entry specifies the peak load capacity of a candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for demand allocation: For each demand area and candidate location, a continuous variable represents the amount of energy demand allocated from the demand area to the candidate location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of defined demand areas and potential charging station locations.  \nDemand values: Predicted energy demand for each demand area.  \nCost matrix: A matrix representing the service cost (e.g., travel time or distance) for allocating energy demand from each demand area to each candidate location.  \nFixed construction costs: The fixed cost of activating each candidate location as a charging station.  \nCapacity limits: The maximum power capacity of each candidate location, representing the total energy demand it can serve.  \nOperational capacity threshold: A fraction (90%) of the total design capacity of all activated charging stations, representing the maximum allowable total load to ensure a safety buffer.  \n\n3. Constraints  \nDemand fulfillment constraints: The total energy demand of each demand area must be fully allocated to one or more activated charging stations.  \nCapacity constraints: The total energy demand allocated to any activated charging station must not exceed its maximum power capacity.  \nOperational capacity constraint: The total demand allocated across all activated charging stations must not exceed 90% of their combined design capacity.  \nStation activation constraints: Energy demand can only be allocated to a candidate location if it is activated as a charging station.  \n\n4. Objective Function  \nMinimize the combined cost, which includes the sum of fixed construction costs for all activated charging stations and the total service cost for allocating energy demand from all demand areas to activated charging stations.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Second section: A cost matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost for allocating demand from a demand area to a candidate location.  \n- Third section: A list of demand values for each demand area.  \n- Fourth section: A list of fixed construction costs for each candidate location.  \n- Fifth section: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbStations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for demand allocation: For each demand area and candidate location pair, a continuous variable representing the portion of the demand from the area that is allocated to the location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas to be served and the total number of candidate locations available for charging station deployment.  \nDemand values: For each demand area, the predicted charging demand that must be fully satisfied.  \nService cost matrix: A matrix where each entry represents the service cost (e.g., distance or travel time) between a demand area and a candidate location.  \nFixed construction costs: For each candidate location, the fixed cost of activating and constructing a charging station at that location.  \nCapacity limits: For each candidate location, the maximum service capacity (in terms of number of users or charging events) that the station can accommodate.  \nOperational capacity buffer: A constraint specifying that the total load on all activated charging stations must not exceed 90% of their combined design capacities.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand from each demand area must be fully allocated to one or more activated charging stations.  \nCapacity constraints: The total demand allocated to a candidate location must not exceed its maximum service capacity if the location is activated.  \nOperational capacity constraints: The sum of the actual loads on all activated charging stations must not exceed 90% of their combined design capacities, ensuring a safety buffer for demand surges.  \nActivation constraints: A candidate location can serve demand only if it is activated as a charging station.  \nNon-negativity and binary constraints: Demand allocation variables must be non-negative, and station activation variables must be binary (0 or 1).  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- Fixed construction costs for all activated charging stations.  \n- Total service costs for all allocated demand, calculated as the demand-weighted service cost between demand areas and their assigned locations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next lines: A cost matrix with dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost between a demand area and a candidate location.  \n- Subsequent line: A list of demand values for each demand area.  \n- Next line: A list of fixed construction costs for each candidate location.  \n- Final line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= max_capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for service allocation: For each service zone and candidate location pair, a continuous variable represents the fraction of the charging demand from the service zone allocated to the location.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total count of defined service zones and potential sites for charging stations.  \nDemand values: Predicted charging demand for each service zone, representing the total number of users or charging events.  \nService cost matrix: A matrix representing the cost (e.g., travel time or distance) for users in each service zone to access each candidate location.  \nFixed construction costs: The fixed cost associated with activating each candidate location as a charging station.  \nCapacity limits: Peak load capacity for each candidate location, specifying the maximum number of users or charging events the site can accommodate.  \nOperational capacity buffer: A safety margin requiring that the total load capacity of all activated stations does not exceed 90% of the combined design capacity.  \n\n3. Constraints  \nDemand fulfillment constraints: The total charging demand of each service zone must be fully allocated across the activated charging stations.  \nCapacity constraints: The total charging demand allocated to a candidate location must not exceed its peak load capacity if the location is activated.  \nOperational capacity constraint: The combined load capacity of all activated charging stations must not exceed 90% of their total design capacity, ensuring a safety buffer for demand surges.  \nActivation constraints: A candidate location can only serve demand if it is activated as a charging station.  \nService allocation constraints: Service allocation variables must be non-negative and respect the demand and capacity limits for each service zone and location pair.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated based on the service cost matrix and demand allocation.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of service zones and candidate locations.  \nSecond section: A cost matrix of dimensions [nbCustomer  nbLocation], representing service costs for each service zone and candidate location pair.  \nThird section: Demand values for each service zone, listed sequentially.  \nFourth section: Fixed construction costs for each candidate location, listed sequentially.  \nFifth section: Capacity limits for each candidate location, listed sequentially.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable represents whether the site is activated as a charging station (1) or not (0).  \nContinuous variables for energy allocation: For each demand area and candidate location, a continuous variable represents the amount of energy allocated from the station to meet the area's demand.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of defined demand areas and candidate facility sites.  \nDemand values: Predicted energy demand for each demand area, expressed in energy units.  \nFixed construction costs: Cost to activate each candidate location as a charging station.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., distance or travel time) between a demand area and a candidate location.  \nCapacity limits: Maximum power capacity for each candidate location, indicating the maximum energy it can supply.  \nSafety buffer ratio: Operational capacity constraint specified as 90% of the total design capacity for all activated stations.  \n\n3. Constraints  \nDemand satisfaction constraints: The total energy allocated to each demand area from all activated stations must meet or exceed the area's predicted energy demand, ensuring full service coverage.  \nCapacity constraints: The total energy supplied by each activated charging station must not exceed its maximum power capacity.  \nOperational capacity constraint: The combined load of all activated charging stations must not exceed 90% of their total design capacity, ensuring a safety buffer for peak demand surges.  \nActivation constraints: Energy can only be allocated from a candidate location if the site is activated as a charging station.  \nNon-negativity constraints: All energy allocation variables must be non-negative, ensuring physically valid energy flows.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes the sum of fixed construction costs for all activated charging stations and the total service cost for all users, based on the service cost matrix.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond section: Service cost matrix [number of demand areas  number of candidate locations], where each entry represents the service cost between a demand area and a candidate location.  \nThird section: A list of demand values for each demand area, expressed in energy units.  \nFourth section: A list of fixed construction costs for each candidate location.  \nFifth section: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbStations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for candidate locations: Binary decision variables indicating whether each candidate location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: Decision variables representing the allocation of each demand area's charging demand to specific activated charging stations.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring charging services and candidate locations where charging stations may be established.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., travel time or distance) for assigning a demand area to a specific candidate location.  \nDemand values: Predicted charging demand for each demand area, representing the total number of users or charging events to be served.  \nFixed construction costs: The cost of building and activating a charging station at each candidate location.  \nCapacity limits: The maximum service capacity of each candidate location, defining the upper limit of users or charging events that can be accommodated at the location.  \n\n3. Constraints  \nDemand satisfaction constraint: The charging demand of each demand area must be fully served by one or more activated charging stations.  \nLocation capacity constraint: The total assigned demand to any activated charging station must not exceed its maximum service capacity.  \nOperational capacity constraint: The aggregate load across all activated charging stations shall not exceed 90% of their total design capacity, ensuring a safety buffer for demand surges and reliable service during peak usage periods.  \nActivation constraint: A candidate location can only serve demand areas if it is activated as a charging station.  \nAssignment constraint: Demand areas can only be assigned to activated charging stations, ensuring that inactive locations do not serve any demand.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated based on the service cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond section: A matrix of size [number of demand areas  number of candidate locations], where each entry specifies the service cost for assigning a demand area to a candidate location.  \nThird section: A list of integers representing the predicted charging demand for each demand area.  \nFourth section: A list of integers specifying the fixed construction cost for each candidate location.  \nFifth section: A list of integers denoting the maximum service capacity for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= max_capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for site activation: For each candidate location, a binary variable indicating whether the location is selected as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for load allocation: For each service zone and candidate location pair, a continuous variable representing the amount of charging demand from the service zone allocated to the candidate location.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total count of defined service zones and candidate locations for potential charging stations.  \nDemand values: Predicted charging demand for each service zone, representing the total charging requirement to be served.  \nCost matrix: A matrix where each entry represents the service cost (e.g., based on distance or travel time) for assigning demand from a specific service zone to a specific candidate location.  \nFixed construction costs: A list of fixed construction costs for activating each candidate location as a charging station.  \nCapacity limits: The peak load capacity for each candidate location, representing the maximum charging demand it can accommodate.  \nOperational capacity factor: A factor (e.g., 90%) specifying the maximum allowable utilization of the total design capacity across all activated charging stations.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand for each service zone must be fully allocated to one or more activated charging stations.  \nCapacity constraints: The total charging demand allocated to any candidate location must not exceed its peak load capacity.  \nOperational capacity constraint: The total load allocated across all activated charging stations must not exceed 90% of their combined design capacity, ensuring a safety buffer for demand surges.  \nSite activation constraints: Demand can only be allocated to a candidate location if that location is activated as a charging station.  \nNon-negativity constraints: All load allocation variables must be non-negative, ensuring that no negative demand is assigned.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The fixed construction costs for all activated charging stations.  \n- The total service cost for all users, computed as the weighted sum of allocated demand multiplied by the corresponding service cost from the cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and candidate locations.  \n- Second section: A cost matrix of size [number of service zones  number of candidate locations], where each entry represents the service cost for assigning demand from a specific service zone to a specific candidate location.  \n- Third section: A list of demand values for each service zone.  \n- Fourth section: A list of fixed construction costs for each candidate location.  \n- Fifth section: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=10)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate location, a binary variable indicates whether the site is activated as a charging station (1 if constructed, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable represents whether the demand from the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of distinct demand zones and potential charging station sites.  \nDemand values: Each demand area has a specified energy demand that must be fully satisfied.  \nCost matrix: A [number of demand areas  number of candidate locations] matrix representing the service cost for assigning demand from an area to a specific location (e.g., based on travel time or distance).  \nFixed construction costs: Each candidate location has an associated fixed cost for activating it as a charging station.  \nCapacity limits: Each candidate location has a maximum power capacity, indicating the total amount of demand it can serve.  \nStrategic diversity constraint: For any two candidate locations with cost characteristics ranking in the nearest 10% among all site pairs, at most one of them may be activated.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its capacity limit.  \nFacility activation constraints: Demand from a demand area can only be assigned to a candidate location if that location is activated as a charging station.  \nStrategic diversity constraints: For any two candidate locations with cost characteristics ranking in the nearest 10% among all site pairs, at most one of them can be activated to ensure diversity in the network.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of:  \n- The fixed construction costs of all activated charging stations.  \n- The total service cost for assigning demand from all areas to activated stations, as determined by the cost matrix.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nNext [number of demand areas] lines: A row of the cost matrix, with each row containing [number of candidate locations] integers representing the service cost for assigning demand from that area to each location.  \nNext line: A list of integers representing the demand values for each demand area.  \nNext line: A list of integers representing the fixed construction costs for each candidate location.  \nNext line: A list of integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbStations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbStations) for j in range(i + 1, nbStations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the location is selected for constructing a charging station (1 if selected, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand of that area is assigned to a specific location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of distinct demand areas requiring charging services and potential locations where charging stations can be constructed.  \nDemand values: For each demand area, the predicted number of charging events required.  \nCost matrix: A matrix specifying the service cost (e.g., travel time or distance) for each demand area to each candidate location.  \nFixed construction costs: For each candidate location, the fixed cost of constructing a charging station.  \nCapacity limits: For each candidate location, the maximum number of charging events or users it can accommodate.  \nDiversity threshold: A threshold defining the top 10% similarity range among pairs of candidate locations based on cost characteristics.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully assigned to one or more candidate locations.  \nCapacity constraints: The total demand assigned to a candidate location cannot exceed its maximum service capacity.  \nStation activation constraints: A demand area can only be assigned to a candidate location if that location is activated as a charging station.  \nDiversity constraints: For any two candidate locations ranked within the top 10% of cost similarity, at most one of the two locations can be activated as a charging station.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The total fixed construction cost for all activated charging stations.  \n- The total service cost for all assigned demand, calculated as the sum of service costs for all demand area-location assignments.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Second block: A cost matrix with dimensions [number of demand areas  number of candidate locations], where each entry represents the service cost from a demand area to a candidate location.  \n- Third line: A list of demand values, one for each demand area.  \n- Fourth line: A list of fixed construction costs, one for each candidate location.  \n- Fifth line: A list of capacity limits, one for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 30\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nimport numpy as np\ndeployment_cost_profiles = np.array(full_deployment_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(deployment_cost_profiles[i] - deployment_cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for site activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for service zones: For each service zone and each candidate location, a binary variable indicates whether the demand of the service zone is assigned to that location.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total count of defined service zones and potential charging station locations.  \nDemand values: For each service zone, the predicted charging demand that must be fully satisfied.  \nFixed construction costs: For each candidate location, the fixed cost incurred if the location is activated as a charging station.  \nService cost matrix: A matrix representing the service cost between each service zone and each candidate location, typically based on distance or travel time.  \nCapacity limits: For each candidate location, the maximum charging demand that can be accommodated by the location.  \nSimilarity rankings: For all pairs of candidate locations, a similarity ranking based on their cost characteristics, identifying the top 10% most similar pairs.  \n\n3. Constraints  \nDemand satisfaction constraints: The full charging demand of each service zone must be assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any activated charging station cannot exceed its capacity limit.  \nActivation constraints: A service zone can only assign its demand to a location if the location is activated as a charging station.  \nStrategic diversity constraints: For any two candidate locations ranked among the top 10% most similar pairs, at most one of them can be activated as a charging station.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of fixed construction costs for all activated charging stations and the total service cost for all assigned demands.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and candidate locations.  \n- Second section: A matrix of size [number of service zones  number of candidate locations], where each entry represents the service cost between a service zone and a candidate location.  \n- Third section: A list of integers representing the demand values for each service zone.  \n- Fourth section: A list of integers representing the fixed construction costs for each candidate location.  \n- Fifth section: A list of integers representing the capacity limits for each candidate location.  \n- Sixth section: A list of pairs of candidate locations ranked among the top 10% most similar in cost characteristics.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 30\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(site_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand area is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and total number of candidate locations available for potential charging stations.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost (e.g., distance or travel time) between a demand area and a candidate location.  \nDemand values: A vector specifying the predicted energy demand for each demand area.  \nConstruction costs: A vector specifying the fixed construction cost for activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum power capacity (number of users or charging events) that each candidate location can accommodate.  \nTransportation cost limit: A scalar value specifying the maximum allowable transportation cost between a demand area and its assigned charging station.  \n\n3. Constraints  \nFacility activation constraints: A candidate location must be activated as a charging station if at least one demand area is assigned to it.  \nDemand coverage constraints: Each demand area must be fully served by exactly one activated charging station.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum power capacity.  \nTransportation cost constraints: The transportation cost between any demand area and its assigned charging station must not exceed the specified transportation cost limit.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction cost for all activated charging stations.  \n- The total transportation cost for all demand areas based on their assigned charging stations.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and the number of candidate locations.  \nSecond block: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost between a demand area and a candidate location.  \nThird line: A vector of length equal to the number of demand areas, specifying the demand for each area.  \nFourth line: A vector of length equal to the number of candidate locations, specifying the fixed construction cost for each location.  \nFifth line: A vector of length equal to the number of candidate locations, specifying the capacity limit for each location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand area is assigned to that location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of defined demand areas (40) and candidate charging station locations.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost between a demand area and a candidate location.  \nDemand values: A vector containing the predicted charging demand for each demand area.  \nFixed construction costs: A vector containing the fixed cost of activating each candidate charging station.  \nCapacity limits: A vector specifying the maximum service capacity for each candidate charging station.  \nTransportation cost limit: A scalar value (20 units) specifying the maximum allowable transportation cost between a demand area and its assigned charging station.  \n\n3. Constraints  \nStation activation constraint: A candidate location can only serve demand areas if it is activated as a charging station.  \nDemand fulfillment constraint: The predicted charging demand for each demand area must be fully served by one or more activated charging stations.  \nCapacity constraint: The total demand assigned to any activated charging station must not exceed its maximum service capacity.  \nTransportation cost constraint: The transportation cost between any demand area and its assigned charging station must not exceed 20 units.  \nAssignment exclusivity constraint: Each demand area must be assigned to exactly one candidate charging station.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all demand areas, computed as the sum of transportation costs between each demand area and its assigned charging station.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A service cost matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost between a demand area and a candidate location.  \nThird block: A vector of demand values for each demand area.  \nFourth block: A vector of fixed construction costs for each candidate charging station.  \nFifth block: A vector of capacity limits for each candidate charging station.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    deployment_cost_to_assigned_station = mdl.element(assignment[c], deployment_cost[c])\n    mdl.add(deployment_cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1) or not (0).  \nAssignment variables for service zones: For each service zone and candidate location, a binary variable represents whether the service zone is assigned to the charging station at that location (1) or not (0).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Two integers representing the total number of service zones requiring coverage and the number of candidate locations available for charging stations.  \nService cost matrix: A matrix of dimensions [nbServiceZones  nbCandidateLocations], where each entry specifies the transportation cost (distance or travel time) between a service zone and a candidate location.  \nDemand values: A vector of size [nbServiceZones], where each entry represents the predicted charging demand for the corresponding service zone.  \nFixed construction costs: A vector of size [nbCandidateLocations], where each entry specifies the fixed cost of activating a charging station at the corresponding candidate location.  \nCapacity limits: A vector of size [nbCandidateLocations], where each entry defines the maximum charging demand that can be accommodated at the corresponding candidate location.  \n\n3. Constraints  \nService coverage constraint: Each service zone must be assigned to exactly one activated charging station, ensuring full coverage of all demand.  \nCapacity constraint: The total charging demand assigned to each activated charging station must not exceed its peak load capacity.  \nTransportation cost constraint: The transportation cost between any service zone and its assigned charging station must not exceed 20 units, ensuring reasonable access for all users.  \nActivation constraint: A service zone can only be assigned to a candidate location if that location is activated as a charging station.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- Fixed construction costs for all activated charging stations.  \n- Total service costs for all users, calculated based on the transportation cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of service zones and candidate locations.  \nSecond block: A cost matrix of dimensions [nbServiceZones  nbCandidateLocations], where each entry specifies the transportation cost between a service zone and a candidate location.  \nThird block: A vector of demand values for each service zone.  \nFourth block: A vector of fixed construction costs for each candidate location.  \nFifth block: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate facility site, a binary decision variable indicating whether the site is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate facility site, a binary decision variable representing whether the demand area is assigned to the facility (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and potential facility sites available for activation.  \nDemand values: Predicted energy demand for each demand area, expressed in standardized units.  \nFixed construction costs: Cost associated with activating each candidate facility site.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the transportation cost between a demand area and a candidate facility site.  \nCapacity limits: Maximum power capacity for each facility site, limiting the total demand it can serve.  \nTransportation cost threshold: Maximum allowable transportation cost between a demand area and its assigned facility site, set to 20 units.  \n\n3. Constraints  \nFacility activation constraints: A facility site can only serve demand areas if it is activated as a charging station.  \nDemand coverage constraints: Each demand area must be fully served by exactly one activated facility site, ensuring complete service coverage.  \nCapacity constraints: The total energy demand assigned to a facility site must not exceed its maximum power capacity.  \nTransportation cost constraints: The transportation cost between any demand area and its assigned facility site must not exceed 20 units, ensuring reasonable access for all users.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated as the sum of transportation costs between demand areas and their assigned facility sites.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate facility sites.  \nSecond section: A matrix of size [number of demand areas  number of candidate locations], where each entry specifies the transportation cost between a demand area and a candidate facility site.  \nThird section: A list of demand values for each demand area.  \nFourth section: A list of fixed construction costs for each candidate facility site.  \nFifth section: A list of capacity limits for each candidate facility site.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate charging station, a binary variable indicating whether the demand area is assigned to the specific charging station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas (e.g., residential districts, business districts, transit centers) and candidate locations for charging stations.  \nDemand values: For each demand area, a predicted charging demand representing the number of users or charging events that must be served.  \nFixed construction costs: For each candidate location, a fixed cost associated with activating the location as a charging station.  \nService cost matrix: A matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the transportation cost (e.g., distance or travel time) between a demand area and a candidate charging station.  \nCapacity limits: For each candidate location, the maximum number of users or charging events the station can accommodate if activated.  \nTransportation cost limit: A global constraint ensuring that the transportation cost between any demand area and its assigned charging station does not exceed 20 units.  \n\n3. Constraints  \nStation activation constraints: Each demand area must be served by exactly one activated charging station.  \nCapacity constraints: The total demand assigned to a charging station cannot exceed its capacity if the station is activated.  \nTransportation cost constraints: For each demand area, the transportation cost to its assigned charging station must not exceed 20 units.  \nDemand coverage constraints: The total demand from all demand areas must be fully served by the activated charging stations.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated as the sum of transportation costs between each demand area and its assigned charging station.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Second block: A cost matrix of dimensions [number of demand areas  number of candidate locations], where each entry specifies the service cost between a demand area and a candidate charging station.  \n- Third line: A list of demand values for each demand area, representing the predicted charging demand.  \n- Fourth line: A list of fixed construction costs for each candidate location.  \n- Fifth line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    deployment_cost_to_assigned_station = mdl.element(assignment[c], deployment_cost[c])\n    mdl.add(deployment_cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for service zones: For each service zone and candidate location, a binary variable indicating whether the service zone is assigned to the given charging station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total number of defined service zones (e.g., residential zones, commercial centers, transportation hubs) and potential charging station locations.  \nService cost matrix: A matrix of size [number of service zones  number of candidate locations], where each entry represents the transportation cost (e.g., distance or travel time) between a service zone and a candidate location.  \nDemand values: For each service zone, the predicted charging demand that must be fully satisfied.  \nFixed construction costs: For each candidate location, the cost of constructing and activating a charging station.  \nCapacity limits: For each candidate location, the maximum load (e.g., number of users or charging events) that the charging station can accommodate.  \nMaximum transportation cost: A fixed upper limit on the transportation cost between any service zone and its assigned charging station, ensuring reasonable access for users.  \n\n3. Constraints  \nStation activation constraint: A candidate location can only serve service zones if it is activated as a charging station.  \nDemand satisfaction constraint: The total demand of each service zone must be fully satisfied by the assigned charging station(s).  \nCapacity constraint: The total demand assigned to each activated charging station must not exceed its peak load capacity.  \nAssignment constraint: Each service zone must be assigned to exactly one activated charging station.  \nTransportation cost constraint: The transportation cost between any service zone and its assigned charging station must not exceed the specified maximum transportation cost.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of the fixed construction costs for all activated charging stations and the total service cost for all service zones.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of service zones and the number of candidate locations.  \nNext [number of service zones] lines: Each line contains [number of candidate locations] integers representing the service cost matrix (transportation costs between service zones and candidate locations).  \nNext line: [number of service zones] integers representing the demand values for each service zone.  \nNext line: [number of candidate locations] integers representing the fixed construction costs for each candidate location.  \nNext line: [number of candidate locations] integers representing the capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\n\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate location, a binary decision variable indicates whether the site is activated as a charging station (1 if activated, 0 otherwise).  \nAllocation variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand of the area is served by the given location (1 if served, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas (e.g., residential zones, commercial centers, transportation hubs) and candidate locations for charging stations.  \nService cost matrix: A matrix of dimensions [number of demand areas  number of candidate locations], where each entry represents the cost of serving a specific demand area from a specific candidate location.  \nDemand values: A vector specifying the energy demand for each demand area.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum power capacity of each candidate location, limiting the total demand that can be served by each facility.  \nBudget range: A lower and upper bound (20,000 and 25,000 monetary units) on the total fixed construction cost of all activated charging stations.  \n\n3. Constraints  \nDemand fulfillment constraints: The total demand of each demand area must be fully served by one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum power capacity.  \nFacility activation constraints: A demand area can only be served by a candidate location if that location is activated as a charging station.  \nBudget constraints: The total fixed construction cost of all activated charging stations must lie within the specified budget range of 20,000 to 25,000 monetary units.  \nDemand area expansion constraints: The problem must accommodate an increased number of demand areas, expanding from the baseline of 30 to 40 areas.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction cost of all activated charging stations.  \n- The total service cost for all demand areas, calculated based on the service cost matrix entries corresponding to the selected facility-destination pairs.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Second section: A cost matrix of dimensions [number of demand areas  number of candidate locations], where each entry specifies the service cost for a demand area-location pair.  \n- Third section: A vector of demand values, with one value per demand area.  \n- Fourth section: A vector of fixed construction costs, with one value per candidate location.  \n- Fifth section: A vector of capacity limits, with one value per candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nContinuous variables for demand allocation: For each demand area and each candidate location, a continuous variable represents the fraction of the demand from the area that is allocated to the location.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas (e.g., residential districts, business districts, transit centers) and candidate locations for potential charging stations.  \nDemand values: For each demand area, the total predicted charging demand that must be fully served.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the cost (e.g., travel distance or time) of serving a unit of demand from a specific demand area at a specific candidate location.  \nFixed construction costs: For each candidate location, the fixed cost of activating the location as a charging station.  \nCapacity limits: For each candidate location, the maximum amount of demand that can be served by the location.  \nBudget range: The allowable range for the sum of fixed construction costs for all activated charging stations, between 20,000 and 25,000 monetary units.  \n\n3. Constraints  \nDemand coverage constraints: The total demand from each demand area must be fully allocated to one or more activated charging stations.  \nCapacity constraints: The total demand allocated to a charging station cannot exceed its maximum service capacity.  \nActivation dependency constraints: Demand can only be allocated to a candidate location if the location is activated as a charging station.  \nBudget constraint: The sum of the fixed construction costs for all activated charging stations must lie strictly within the budget range of 20,000 to 25,000 monetary units.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, based on the cost of serving demand from each demand area at the allocated charging station(s).  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Next [number of demand areas  number of candidate locations] entries: A matrix of service costs, with one row per demand area and one column per candidate location.  \n- Next [number of demand areas] entries: Demand values for each demand area.  \n- Next [number of candidate locations] entries: Fixed construction costs for each candidate location.  \n- Next [number of candidate locations] entries: Capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for site activation: For each candidate location, a binary variable indicates whether the location is selected as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for service zones: For each service zone and candidate location, a binary variable indicates whether the service zone is assigned to the specific charging station (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total number of service zones where charging demand arises and the total number of candidate locations for potential charging stations.  \nDemand values: Predicted charging demand for each service zone, representing the number of users or charging events that must be served.  \nService cost matrix: A cost matrix where each entry represents the cost (e.g., travel time or distance) of assigning a specific service zone to a particular candidate location.  \nFixed construction costs: The fixed cost associated with activating each candidate location as a charging station.  \nCapacity limits: The maximum number of users or charging events that each candidate location can serve if activated.  \nBudget range: A strict budget constraint on the sum of fixed construction costs for all activated charging stations, specified as a range between 20,000 and 25,000 monetary units.  \n\n3. Constraints  \nService zone assignment constraints: Each service zone must be fully assigned to exactly one activated charging station, ensuring that all demand is served.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its peak load capacity.  \nActivation constraints: A candidate location can only serve demand if it is activated as a charging station.  \nBudget constraint: The total fixed construction cost of all activated charging stations must lie strictly within the budget range of 20,000 to 25,000 monetary units.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of the fixed construction costs for all activated charging stations and the total service cost for all users, where the service cost is based on the assignment of service zones to charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and the number of candidate locations.  \n- Subsequent lines (one per service zone): Service cost matrix of dimensions [number of service zones  number of candidate locations], where each entry represents the service cost of assigning a service zone to a candidate location.  \n- Next line: A list of demand values for each service zone.  \n- Next line: A list of fixed construction costs for each candidate location.  \n- Final line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables\nBinary decision variables for each candidate location: Indicate whether a candidate location is selected to become an active charging station.\nContinuous decision variables for assignment: Represent the allocation of demand from each demand area to the selected charging stations.\n\n2. Parameters and Input Data\nNumber of demand areas and candidate locations: Total count of demand areas to be served and potential locations for charging stations.\nCost matrix: A matrix representing the service cost for each pair of demand area and candidate location, typically based on distance or travel time.\nDemand values: Predicted energy demand for each demand area, representing the number of users or charging events required to be accommodated.\nFixed construction costs: The cost associated with constructing a charging station at each candidate location.\nCapacity limits: Maximum power capacity constraints for each candidate location, limiting the number of users or charging events it can accommodate.\n\n3. Constraints\nDemand satisfaction constraint: Each demand area must be fully served, ensuring that the predicted energy demand is met by the selected charging stations.\nCapacity constraint: Each charging station must not exceed its maximum power capacity, limiting the number of users or charging events it can accommodate.\nBudget constraint: The sum of fixed construction costs for all activated charging stations must be within the budget range of 20,000 to 25,000 monetary units.\nLocation selection constraint: Determine the optimal subset of candidate locations to activate as charging stations to serve all demand areas.\n\n4. Objective Function\nMinimize the combined cost function, which includes both the sum of fixed construction costs for all activated charging stations and the total service cost for all users, thereby achieving an economically efficient charging network layout.\n\n5. Data Specification\nThe input file \"charging_location.data\" follows this format:\nFirst line: Two integers representing the number of demand areas and candidate locations.\nSubsequent lines: A cost matrix [nbCustomer  nbLocation] representing service costs between demand areas and candidate locations.\nFollowing lines: Demand values for each area.\nNext lines: Fixed construction costs for each location.\nLast lines: Capacity limits for each location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables\nBinary decision variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station.\nContinuous decision variables for service allocation: For each demand area and candidate location pair, a continuous variable represents the amount of demand served by the station.\n\n2. Parameters and Input Data\nNumber of demand areas and candidate locations: Two integers indicating the total number of demand areas and candidate station locations.\nService cost matrix: A matrix with dimensions [number of demand areas  number of candidate locations] representing the service cost associated with each demand area and candidate location pair.\nDemand values: A list of integers representing the predicted charging demand for each demand area.\nFixed construction costs: A list of integers representing the fixed costs associated with constructing a charging station at each candidate location.\nCapacity limits: A list of integers representing the maximum service capacity for each candidate location.\n\n3. Constraints\nDemand fulfillment constraint: Each demand area must have its entire predicted charging demand fully served by the activated charging stations.\nCapacity constraints: The total demand served by each activated charging station must not exceed its maximum service capacity.\nBudget constraint: The sum of fixed construction costs for all activated charging stations must be strictly within the budget range of 20,000 to 25,000 monetary units.\nActivation constraint: A candidate location can only serve demand if it is activated as a charging station.\n\n4. Objective Function\nMinimize the combined cost function, which includes the sum of fixed construction costs for all activated stations and the total service cost for all users, thereby achieving an economically efficient charging network layout.\n\n5. Data Specification\nThe input file \"plant_location.data\" follows this format:\nFirst line: Two integers representing the number of demand areas and candidate locations.\nSubsequent lines: A cost matrix [number of demand areas  number of candidate locations] representing service costs.\nNext lines: Demand values for each area, followed by fixed construction costs for each location, and capacity limits for each location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is selected as a charging station (1 if selected, 0 otherwise).  \nContinuous variables for demand allocation: For each service zone and each candidate location, a continuous variable represents the proportion of the service zone's demand satisfied by the selected location.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: The total number of service zones (e.g., residential areas, commercial centers) and potential candidate locations for charging stations.  \nDemand for each service zone: Predicted charging demand for each service zone, representing the number of users or charging events that must be served.  \nFixed construction costs: The fixed cost associated with activating each candidate location as a charging station.  \nService cost matrix: A cost matrix where each entry represents the cost of serving a specific service zone from a specific candidate location, typically based on distance or travel time.  \nCapacity limits: The maximum demand that each candidate location can serve, representing the peak load capacity of each charging station.  \nBudget range: The total fixed construction costs for all selected stations must fall within the range of 20,000 to 25,000 monetary units.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each service zone must be fully satisfied by the selected charging stations.  \nCapacity constraints: The total demand allocated to each activated charging station cannot exceed its peak load capacity.  \nBudget constraint: The sum of fixed construction costs for all activated charging stations must lie strictly within the range of 20,000 to 25,000 monetary units.  \nDemand allocation constraints: Demand from each service zone can only be allocated to candidate locations that are activated as charging stations.  \nService zone expansion: The number of service zones must be expanded from the baseline of 30 to 40, reflecting urban growth and increased spatial coverage requirements.  \nBinary activation constraints: Each candidate location can either be activated as a charging station (binary value of 1) or remain inactive (binary value of 0).  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The total fixed construction costs for all activated charging stations.  \n- The total service costs for all users, calculated as the sum of the service costs for satisfying the demand of all service zones based on the cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and candidate locations.  \n- Second block: A cost matrix of dimensions [number of service zones  number of candidate locations], where each entry specifies the service cost for a service zone-location pair.  \n- Third block: A list of demand values for each service zone, one per line.  \n- Fourth block: A list of fixed construction costs for each candidate location, one per line.  \n- Fifth block: A list of capacity limits for each candidate location, one per line.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for facility activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1) or not (0).  \nContinuous decision variables for demand allocation: For each demand area and candidate location, a continuous variable representing the amount of energy allocated from the location to the demand area.\n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring service and candidate locations available for charging station deployment.  \nEnergy demand per area: Predicted energy demand for each demand area, representing the total energy required to fully serve the area.  \nFixed construction costs: Cost associated with activating each candidate location as a charging station.  \nService costs: Matrix of service costs, where each entry represents the cost (e.g., distance or travel time) of serving a specific demand area from a specific candidate location.  \nCapacity limits: Maximum energy capacity for each candidate location, representing the upper bound on the energy that can be allocated from the location to all demand areas.  \n\n3. Constraints  \nDemand satisfaction constraints: The total energy allocated to each demand area must meet or exceed its predicted energy demand, ensuring full service coverage.  \nCapacity constraints: For each activated charging station, the total energy allocated from the station to all demand areas must not exceed 90% of its maximum energy capacity, maintaining operational resilience.  \nActivation constraints: Energy can only be allocated from a candidate location to demand areas if the location is activated as a charging station.  \nDemand area expansion: The problem includes an increased number of demand areas, complicating the allocation and activation decisions due to the higher service requirements.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, based on the cost matrix representing distance or travel time between demand areas and candidate locations.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A matrix of size [nbCustomer  nbLocation], where each entry represents the service cost from a candidate location to a demand area.  \nThird line: A list of energy demand values for each demand area.  \nFourth line: A list of fixed construction costs for each candidate location.  \nFifth line: A list of maximum capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbStations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for station activation: For each candidate location, a binary variable indicating whether the station is activated (1) or not (0).  \nContinuous decision variables for demand allocation: For each demand area and candidate station, a continuous variable representing the fraction of the demand allocated to that station.  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas to be served and potential charging station locations.  \nService cost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the cost (e.g., distance or travel time) of serving a specific demand area from a specific candidate station.  \nDemand values: A vector of size [number of demand areas], where each entry specifies the predicted charging demand for each demand area.  \nFixed construction costs: A vector of size [number of candidate locations], where each entry represents the fixed cost of constructing a station at the corresponding location.  \nCapacity limits: A vector of size [number of candidate locations], where each entry specifies the maximum service capacity of a candidate station.  \n\n3. Constraints  \nDemand fulfillment constraint: Each demand area must have its total predicted charging demand fully allocated across the activated stations.  \nCapacity constraint: The total demand allocated to any activated station must not exceed its maximum service capacity.  \nStation activation constraint: Demand can only be allocated to a candidate station if the station is activated.  \nOperational resilience constraint: The total load allocated to any activated station must not exceed 90% of its design capacity, ensuring reliability and resilience.  \n\n4. Objective Function  \nMinimize the combined cost function, which consists of:  \n- The sum of fixed construction costs for all activated stations.  \n- The total service cost for all users, calculated as the sum of service costs across all demand areas and candidate stations based on the demand allocation.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and candidate locations.  \nSecond block: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost for a specific demand area and candidate station.  \nThird block: A vector of size [number of demand areas], where each entry specifies the predicted demand for each demand area.  \nFourth block: A vector of size [number of candidate locations], where each entry specifies the fixed construction cost for each candidate station.  \nFifth block: A vector of size [number of candidate locations], where each entry specifies the maximum service capacity for each candidate station.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= max_capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAllocation variables for service zones: For each service zone and each candidate location, a binary variable represents whether the charging demand of the service zone is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total number of service zones requiring charging services and the number of candidate locations where charging stations can be established.  \nService cost matrix: A matrix of size [number of service zones  number of candidate locations], where each entry represents the cost (e.g., travel time or distance) of serving a service zone from a candidate location.  \nDemand values: A vector specifying the predicted charging demand for each service zone.  \nFixed construction costs: A vector specifying the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the peak load capacity of each candidate location, representing the maximum demand it can serve.  \n\n3. Constraints  \nDemand satisfaction constraints: Each service zone's charging demand must be fully met by the activated charging stations.  \nAllocation constraints: A service zone can only be assigned to a candidate location if that location is activated as a charging station.  \nCapacity constraints: The total demand assigned to each activated charging station must not exceed 90% of its design capacity, ensuring operational resilience.  \nService zone expansion constraints: The number of service zones considered in the problem is increased from 30 to 40, requiring the solution to address the expanded demand.  \n\n4. Objective Function  \nMinimize the combined cost function, which consists of:  \n- The total fixed construction costs for all activated charging stations.  \n- The total service cost, calculated as the sum of service costs for all service zones based on their assigned charging station.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and candidate locations.  \n- Second section: A matrix of size [number of service zones  number of candidate locations], where each entry represents the service cost between a service zone and a candidate location.  \n- Third section: A vector of demand values, one per service zone.  \n- Fourth section: A vector of fixed construction costs, one per candidate location.  \n- Fifth section: A vector of capacity limits, one per candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_UTILIZATION_RATIO = 0.9\nfor p in range(nbLocations):\n    mdl.add(load[p] <= capacity[p] * MAX_UTILIZATION_RATIO)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for facility activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand allocation: For each demand area and candidate location, a binary variable indicates whether the demand of the area is assigned to the location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: The total number of demand areas that require service and the total number of candidate locations available for charging station construction.  \nCost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., based on distance or travel time) between a demand area and a candidate location.  \nDemand values: A list of predicted energy demand values for each demand area.  \nFixed construction costs: A list of fixed costs associated with activating each candidate location as a charging station.  \nCapacity limits: A list of maximum power capacities for each candidate location, representing the total demand that can be served by the location.  \nSimilarity threshold for site pairs: A threshold defining the nearest 10% of site pairs based on cost characteristics, used to impose a diversity constraint.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each demand area must be fully assigned to one or more activated charging stations.  \nCapacity constraints: The total demand assigned to any activated charging station must not exceed its maximum power capacity.  \nActivation constraints: Demand can only be assigned to a candidate location if the location is activated as a charging station.  \nDiversity constraint: For any two candidate locations with cost characteristics ranking within the nearest 10% of all site pairs, at most one of the two locations can be activated.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, defined as the sum of service costs for all assigned demand-location pairs.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Second section: A cost matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost between a demand area and a candidate location.  \n- Third section: A list of demand values for each demand area.  \n- Fourth section: A list of fixed construction costs for each candidate location.  \n- Fifth section: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbStations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbStations) for j in range(i + 1, nbStations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and each candidate location, a binary variable indicates whether the demand area is assigned to the candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of defined demand areas (e.g., residential districts, business districts, transit centers) and candidate locations for charging stations.  \nDemand values: Predicted charging demand for each demand area, represented as the total number of charging events or users requiring service.  \nCost matrix: A matrix of size [number of demand areas  number of candidate locations] representing the service cost (e.g., travel time or distance) for assigning each demand area to a specific candidate location.  \nFixed construction costs: A vector of fixed costs associated with activating each candidate location as a charging station.  \nCapacity limits: A vector of maximum service capacities for each candidate location, representing the upper bound on the number of charging events or users that can be accommodated at the location.  \nSimilarity threshold for site pairs: A parameter defining the nearest 10% of candidate location pairs based on cost similarity, used for imposing diversity constraints.  \n\n3. Constraints  \nDemand fulfillment constraints: Each demand area must be fully assigned to one or more activated charging stations such that its total demand is satisfied.  \nCapacity constraints: The total demand assigned to any candidate location must not exceed its maximum service capacity.  \nStation activation constraints: A demand area can only be assigned to a candidate location if the location is activated as a charging station.  \nSimilarity-based diversity constraints: For any two candidate locations identified as being within the nearest 10% of cost similarity, at most one of the two locations can be activated as a charging station.  \nCoverage expansion constraints: The number of demand areas to be served is increased from 30 to 40, requiring broader network coverage.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The total fixed construction costs of all activated charging stations.  \n- The total service cost for all demand areas, calculated based on the assignment of demand areas to activated locations and the associated service costs from the cost matrix.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of demand areas and the number of candidate locations.  \nSecond section: A cost matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost for assigning a demand area to a candidate location.  \nThird section: A list of demand values, one for each demand area, representing the total predicted charging demand.  \nFourth section: A list of fixed construction costs, one for each candidate location.  \nFifth section: A list of capacity limits, one for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nimport numpy as np\ndeployment_cost_profiles = np.array(full_deployment_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(deployment_cost_profiles[i] - deployment_cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for site activation: A binary variable is defined for each candidate site location to indicate whether the site is selected as a charging station (1) or not (0).  \nContinuous variables for service allocation: For each service zone and candidate site, a continuous variable represents the portion of the charging demand at the service zone that is served by the site.  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: The total number of defined service zones and potential site locations.  \nDemand values: Each service zone has a predicted charging demand that must be served entirely.  \nCapacity limits: Each candidate site location has a peak load capacity constraint, representing the maximum demand it can serve.  \nCost matrix: A matrix of service costs, where each entry represents the cost (distance or travel time) of serving a unit of demand from a specific site to a specific service zone.  \nFixed construction costs: Each candidate site has an associated fixed cost for activation as a charging station.  \n\n3. Constraints  \nDemand satisfaction constraints: The total demand of each service zone must be fully served by the selected charging stations.  \nCapacity constraints: For each activated site, the total demand allocated to the site from all service zones must not exceed its peak load capacity.  \nSite activation constraints: A site can only serve demand if it is activated as a charging station.  \nCoverage constraints: The service zones must be expanded to cover all 40 defined zones, ensuring broader coverage beyond the baseline of 30 zones.  \nStrategic diversity constraints: For any two candidate sites with cost characteristics ranking in the nearest 10% among all site pairs, at most one of them can be activated as a charging station.  \n\n4. Objective Function  \nMinimize the combined cost function, which includes:  \n- The sum of fixed construction costs for all activated charging stations.  \n- The total service cost for all users, calculated based on the cost matrix and the allocation of demand from service zones to activated sites.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \nFirst line: Two integers representing the number of service zones and candidate site locations.  \nNext lines: A cost matrix [nbServiceZones  nbLocations], where each entry specifies the service cost for a unit of demand between a service zone and a candidate site.  \nNext line: A list of demand values for each service zone.  \nNext line: A list of fixed construction costs for each candidate site.  \nNext line: A list of capacity limits for each candidate site.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(site_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary decision variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary decision variable specifies whether the demand of a specific area is served by a specific location (1 if served, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of demand areas requiring service and candidate locations available for constructing charging stations.  \nDemand values: Predicted energy demand for each demand area, representing the total energy required to fully serve that area.  \nService cost matrix: A cost matrix where each element represents the service cost (e.g., distance or travel time) for assigning a specific demand area to a specific candidate location.  \nFixed construction costs: A fixed cost associated with activating each candidate location as a charging station.  \nCapacity limits: Maximum power capacity of each candidate location, representing the upper limit of the total energy demand that can be served by that location.  \nCost similarity threshold: A threshold value (10% of the total cost range) used to identify pairs of candidate locations with similar cost characteristics.  \n\n3. Constraints  \nDemand fulfillment constraints: The total demand of each demand area must be fully satisfied by the assigned charging stations. Specifically, the sum of assignments for each demand area across all candidate locations must equal 1.  \nCapacity constraints: For each activated charging station, the total demand assigned to it must not exceed its maximum power capacity.  \nActivation constraints: A candidate location can only serve demand areas if it is activated as a charging station.  \nMutual exclusion constraints: For any two candidate locations identified as having similar cost characteristics (within the nearest 10% of all site pairs), at most one of them can be activated as a charging station.  \nAssignment constraints: Each demand area can only be assigned to candidate locations that are activated as charging stations.  \n\n4. Objective Function  \nMinimize the total cost, which is the sum of fixed construction costs for all activated charging stations and the total service cost for all demand assignments.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and candidate locations.  \n- Second block: A cost matrix of size [nbDemandAreas  nbLocations], where each element represents the service cost for assigning a specific demand area to a specific candidate location.  \n- Third line: A list of demand values, one for each demand area.  \n- Fourth line: A list of fixed construction costs, one for each candidate location.  \n- Fifth line: A list of capacity limits, one for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 40\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(full_cost).T[:nbStations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbStations) for j in range(i + 1, nbStations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicates whether the demand of that area is assigned to the specific location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total count of demand areas requiring charging services and candidate locations available for station construction.  \nDemand values: For each demand area, the predicted charging demand (e.g., number of users or charging events).  \nCost matrix: A matrix of size [number of demand areas  number of candidate locations], where each entry represents the service cost (e.g., travel distance or time) for assigning a demand area to a specific location.  \nFixed construction costs: For each candidate location, a fixed cost associated with constructing a charging station at that location.  \nCapacity limits: For each candidate location, the maximum service capacity, representing the maximum number of users or charging events the station can accommodate.  \nSimilarity threshold for site pairs: A threshold defining the nearest 10% of candidate location pairs based on similarity in cost characteristics, which is used to restrict simultaneous construction of similar sites.  \n\n3. Constraints  \nDemand fulfillment constraints: Each demand area must be fully assigned to one or more activated charging stations, ensuring that the total assigned capacity meets or exceeds the demand for that area.  \nCapacity constraints: For each activated charging station, the total demand assigned to the station cannot exceed its maximum capacity.  \nActivation constraints: A candidate location can only serve demand areas if it is activated as a charging station.  \nMutual exclusivity constraints: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 10% among all site pairs), at most one of them can be activated as a charging station.  \nDemand assignment constraints: Each demand area can only be assigned to candidate locations that are activated as charging stations.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction costs for all activated charging stations.  \n- The total service costs for all assigned demand areas, based on the cost matrix values.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Next [number of demand areas  number of candidate locations] entries: A cost matrix in row-major order, where each entry represents the service cost for assigning a demand area to a candidate location.  \n- Following line: A list of demand values for each demand area.  \n- Following line: A list of fixed construction costs for each candidate location.  \n- Final line: A list of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbCustomer = data[ptr];\nptr += 1\nfull_nbLocation = data[ptr];\nptr += 1\nfull_deployment_cost = [[data[ptr + c * full_nbLocation + l] for l in range(full_nbLocation)] for c in range(full_nbCustomer)]\nptr += full_nbCustomer * full_nbLocation\nfull_energy_requirement = [data[ptr + c] for c in range(full_nbCustomer)];\nptr += full_nbCustomer\nfull_fixedCost = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\nfull_max_capacity = [data[ptr + p] for p in range(full_nbLocation)];\nptr += full_nbLocation\n\nnbDemandAreas = 40\nnbLocations = 20\n\ndeployment_cost = [row[:nbLocations] for row in full_deployment_cost[:nbDemandAreas]]\nenergy_requirement = full_energy_requirement[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\nmax_capacity = full_max_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(max_capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, energy_requirement))\n\nimport numpy as np\ndeployment_cost_profiles = np.array(full_deployment_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(deployment_cost_profiles[i] - deployment_cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], deployment_cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / max_capacity[i]) * 100 if max_capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {max_capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary variables for station activation: For each candidate location, a binary variable indicates whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for service zones: For each service zone and each candidate location, a binary variable represents whether the service zone is assigned to the candidate location for charging service (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of service zones and candidate locations: Total number of service zones requiring coverage and the total number of candidate locations available for potential charging station construction.  \nService cost matrix: A matrix where each entry represents the service cost (e.g., distance or travel time) between a service zone and a candidate location.  \nDemand values: A vector where each entry specifies the predicted charging demand for each service zone.  \nFixed construction costs: A vector where each entry specifies the fixed cost of constructing a charging station at a candidate location.  \nCapacity limits: A vector where each entry specifies the maximum charging demand that a candidate location can accommodate if activated.  \n\n3. Constraints  \nDemand coverage constraints: Each service zone must be fully assigned to one or more activated charging stations such that its total demand is satisfied.  \nCapacity constraints: The total demand assigned to an activated charging station must not exceed its peak load capacity.  \nActivation constraints: Service zones can only be assigned to candidate locations that are activated as charging stations.  \nStrategic diversity constraints: For any two candidate locations with the most similar cost characteristics (ranking in the nearest 10% of cost similarity among all location pairs), at most one of them can be activated as a charging station.  \nService zone expansion constraints: The number of service zones to be covered is expanded from the baseline of 30 zones to 40 zones, ensuring broader service coverage.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- Fixed construction costs for all activated charging stations.  \n- Total service costs for all assigned service zones, typically based on the distance or travel time between service zones and their assigned charging stations.  \n\n5. Data Specification  \nThe input file \"plant_location.data\" follows this format:  \n- First line: Two integers representing the number of service zones and the number of candidate locations.  \n- Second block: A cost matrix of size [number of service zones  number of candidate locations], where each entry represents the service cost between a service zone and a candidate location.  \n- Third block: A vector of demand values for each service zone.  \n- Fourth block: A vector of fixed construction costs for each candidate location.  \n- Fifth block: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"plant_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\ntotal_zones = data[ptr];\nptr += 1\ntotal_sites = data[ptr];\nptr += 1\nsite_cost = [[data[ptr + c * total_sites + l] for l in range(total_sites)] for c in range(total_zones)]\nptr += total_zones * total_sites\nfull_demand = [data[ptr + c] for c in range(total_zones)];\nptr += total_zones\nfull_fixedCost = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\nfull_capacity = [data[ptr + p] for p in range(total_sites)];\nptr += total_sites\n\nnbDemandAreas = 40\nnbLocations = 20\n\ncost = [row[:nbLocations] for row in site_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbLocations]\ncapacity = full_capacity[:nbLocations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbLocations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbLocations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbLocations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nimport numpy as np\ncost_profiles = np.array(site_cost).T[:nbLocations]\ndistances = {(i, j): np.linalg.norm(cost_profiles[i] - cost_profiles[j])\n             for i in range(nbLocations) for j in range(i + 1, nbLocations)}\nthreshold = np.percentile(list(distances.values()), 10)\nclose_pairs = [pair for pair, dist in distances.items() if dist < threshold]\nmdl.add(open_station[loc1] + open_station[loc2] <= 1 for loc1, loc2 in close_pairs)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for facility activation: For each candidate location, a binary variable indicating whether the location is activated as a charging station (1 if activated, 0 otherwise).  \nAssignment variables for demand areas: For each demand area and candidate location, a binary variable indicating whether the demand area is assigned to the specific candidate location (1 if assigned, 0 otherwise).  \n\n2. Parameters and Input Data  \nNumber of demand areas and candidate locations: Total number of defined demand areas and potential candidate locations for charging stations.  \nService cost matrix: A [number of demand areas  number of candidate locations] matrix where each entry represents the transportation or service cost between a demand area and a candidate location.  \nDemand values: A vector containing the energy demand for each demand area.  \nFixed construction costs: A vector containing the fixed cost of activating each candidate location as a charging station.  \nCapacity limits: A vector specifying the maximum power capacity (in terms of the number of users or charging events) for each candidate location.  \nBudget range: A lower and upper bound (20,000 to 25,000 monetary units) on the total fixed construction costs for the activated charging stations.  \nMaximum service distance: A maximum allowable transportation cost of 20 units between any assigned demand area and its corresponding charging station.  \n\n3. Constraints  \nFacility activation constraint: Each demand area must be assigned to exactly one charging station from the set of activated candidate locations.  \nCapacity constraint: The total demand assigned to a charging station must not exceed its maximum power capacity.  \nService distance constraint: The transportation cost between any demand area and its assigned charging station must not exceed 20 units.  \nBudget constraint: The total fixed construction cost of all activated charging stations must lie within the budget range of 20,000 to 25,000 monetary units.  \nActivation-assignment consistency constraint: A demand area can only be assigned to a candidate location if that location is activated as a charging station.  \n\n4. Objective Function  \nMinimize the combined cost function, which is the sum of:  \n- The total fixed construction costs of all activated charging stations.  \n- The total service costs for all demand areas, calculated as the sum of transportation costs between each demand area and its assigned charging station.  \n\n5. Data Specification  \nThe input file \"charging_location.data\" follows this format:  \n- First line: Two integers representing the number of demand areas and the number of candidate locations.  \n- Subsequent lines: A [number of demand areas  number of candidate locations] matrix representing the service costs between each demand area and each candidate location.  \n- Next line: A vector of demand values for each demand area.  \n- Next line: A vector of fixed construction costs for each candidate location.  \n- Final line: A vector of capacity limits for each candidate location.",
    "input": "",
    "output": "import os\nfrom docplex.cp.model import CpoModel\n\nfilename = os.path.join(\"data\", \"charging_location.data\")\nwith open(filename, \"r\") as file:\n    data = [int(v) for v in file.read().split()]\n\nptr = 0\nfull_nbDemandPoint = data[ptr];\nptr += 1\nfull_nbStation = data[ptr];\nptr += 1\nfull_cost = [[data[ptr + c * full_nbStation + l] for l in range(full_nbStation)] for c in range(full_nbDemandPoint)]\nptr += full_nbDemandPoint * full_nbStation\nfull_demand = [data[ptr + c] for c in range(full_nbDemandPoint)];\nptr += full_nbDemandPoint\nfull_fixedCost = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\nfull_capacity = [data[ptr + p] for p in range(full_nbStation)];\nptr += full_nbStation\n\nnbDemandAreas = 30\nnbStations = 20\n\ncost = [row[:nbStations] for row in full_cost[:nbDemandAreas]]\ndemand = full_demand[:nbDemandAreas]\nfixedCost = full_fixedCost[:nbStations]\ncapacity = full_capacity[:nbStations]\n\nmdl = CpoModel()\n\nassignment = mdl.integer_var_list(nbDemandAreas, 0, nbStations - 1, \"DemandAreaAssignment\")\nopen_station = mdl.integer_var_list(nbStations, 0, 1, \"OpenStation\")\nload = [mdl.integer_var(0, cap, f\"StationLoad_{p}\") for p, cap in enumerate(capacity)]\n\nfor p in range(nbStations):\n    mdl.add(open_station[p] == (load[p] > 0))\nmdl.add(mdl.pack(load, assignment, demand))\n\nMAX_ALLOWED_COST = 20\nfor c in range(nbDemandAreas):\n    cost_to_assigned_station = mdl.element(assignment[c], cost[c])\n    mdl.add(cost_to_assigned_station <= MAX_ALLOWED_COST)\n\nobj = mdl.scal_prod(fixedCost, open_station)\nmdl.add(obj >= 20000)\nmdl.add(25000 >= obj)\n\nfor c in range(nbDemandAreas):\n    obj += mdl.element(assignment[c], cost[c])\nmdl.add(mdl.minimize(obj))\n\nprint(\"Solving the model...\")\nmsol = mdl.solve(TimeLimit=100)\n\nif msol:\n    print(\"\\n------------------ SOLUTION FOUND ------------------\")\n    print(f\"Objective Value (Total Cost): {msol.get_objective_value():.2f}\")\n    open_stations_indices = [i for i, var in enumerate(open_station) if msol.get_value(var) == 1]\n    print(f\"Stations to open: {open_stations_indices}\")\n\n    print(\"\\n--- Station Loads and Capacities ---\")\n    loads_solution = [msol.get_value(l) for l in load]\n    for i in open_stations_indices:\n        utilization = (loads_solution[i] / capacity[i]) * 100 if capacity[i] > 0 else 0\n        print(f\"Station {i}: Load = {loads_solution[i]}, Capacity = {capacity[i]} ({utilization:.1f}% utilized)\")\n\n    print(\"\\n--- Demand Area Assignments ---\")\n    assignment_solution = [msol.get_value(v) for v in assignment]\n    for i, assigned_station in enumerate(assignment_solution):\n        print(f\"Demand Area {i} is assigned to Station {assigned_station}\")\nelse:\n    print(\"\\nNo solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nAssignment variables: Binary variables indicating whether a specific vehicle is assigned to serve a specific customer point.  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at each customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customer points: Total number of unmanned vehicles in the fleet and customer service points, including the central depot.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, limiting the total demand that can be served on a single route.  \nCustomer demands: The amount of goods required by each customer point.  \nTravel distances: A matrix representing the pairwise distances between all customer points, including the central depot.  \nTime windows: Each customer point has a ready time and a due time, defining the earliest and latest times the customer can be served.  \nService times: The time required to deliver goods at each customer point.  \n\n3. Constraints  \nCapacity constraints: The total demand served by any vehicle along its assigned route must not exceed its maximum load capacity.  \nAssignment constraints: Each customer point must be visited exactly once by one and only one vehicle, ensuring complete and non-overlapping service coverage.  \nDepot constraints: Each vehicle must start its route from the central depot and return to the same depot after completing its assigned deliveries.  \nRoute continuity constraints: For each vehicle, the sequence of customer visits must form a continuous path with no disjoint segments.  \nTime window constraints: Each vehicle must arrive at each customer point within the specified ready time and due time of that customer. If the vehicle arrives earlier than the ready time, it must wait until the service can begin.  \nService time constraints: After arriving at a customer point, the vehicle must remain there for the duration of the specified service time before proceeding to the next point.  \nNon-overlapping route constraints: No two vehicles can simultaneously serve the same customer point, ensuring logical and executable delivery paths.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet, calculated as the sum of the distances traveled by all vehicles along their respective routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of customer points (including the depot) and the number of vehicles.  \nSubsequent lines (one per customer point): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time. The first line after the header corresponds to the central depot, which has a demand of 0.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle and each pair of customer locations (including the depot), a binary variable indicating whether the vehicle travels directly between the two locations.  \nArrival time variables: For each customer location and each unmanned vehicle, a continuous variable representing the time at which the vehicle arrives at the respective customer location.  \nLoad variables: For each unmanned vehicle and each customer location, a continuous variable representing the cumulative load carried by the vehicle upon arrival at that location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for deliveries.  \nNumber of customers: Total number of customer locations to be visited.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, the following attributes are provided:  \n  - Customer ID: Unique identifier for each customer.  \n  - Coordinates: x and y coordinates of the customer location.  \n  - Demand: Quantity of goods required by the customer.  \n  - Time window: Ready time and due time defining the earliest and latest times the delivery can occur.  \n  - Service time: Duration required to complete the delivery at the customer location.  \nDistance matrix: A symmetric matrix where each entry represents the Euclidean distance between two locations (customers or depot).  \nVehicle capacity: Maximum load capacity of each unmanned vehicle.  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one vehicle.  \nDepot constraints: Each vehicle must start and end its route at the central depot.  \nLoad capacity constraints: The total load carried by a vehicle at any point in its route must not exceed its maximum load capacity.  \nTime window constraints: Each customer must be visited within their specified time window, and the arrival time at each location must respect the ready time and due time.  \nService time constraints: After arriving at a customer location, the vehicle must remain there for the duration of the service time before departing to the next location.  \nSubtour elimination constraints: The solution must ensure that the delivery routes are connected and do not form disjoint subtours that exclude the depot or other customers.  \nNon-overlapping route constraints: The routes assigned to different vehicles must not overlap in a way that violates the one-visit-per-customer requirement.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, calculated as the sum of the distances between consecutive locations (including the depot) visited by each vehicle.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the depot.  \nSubsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\nwarehouse = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != warehouse]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Represent the sequence of customer locations visited by each vehicle, including departure from and return to the central depot.  \nAssignment variables: Binary variables indicating whether a specific vehicle is assigned to serve a particular customer.  \nArrival time variables: Represent the exact time each vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nNumber of customers: Total count of customer locations requiring service.  \nDepot location: Coordinates of the central depot from which all vehicles start and return.  \nCustomer data: For each customer, the following attributes are provided:  \n- Coordinates (x, y): Location of the customer.  \n- Demand: Quantity of goods required by the customer.  \n- Ready time: Earliest time the customer is ready to receive goods.  \n- Due time: Latest time by which delivery must be completed.  \n- Service time: Duration required to complete delivery at the customer location.  \nVehicle capacity: Maximum load capacity for each vehicle, specifying the upper limit of goods that can be carried during a delivery cycle.  \nTravel distance matrix: Precomputed distances between all pairs of locations (customers and depot).  \n\n3. Constraints  \nCapacity constraints: The total demand served by each vehicle must not exceed its maximum load capacity, ensuring no overloading.  \nAssignment constraints: Each customer must be visited exactly once by one vehicle, fulfilling their entire demand.  \nDepot constraints: Each vehicle must depart from the central depot at the start of its route and return to the same depot at the end.  \nSequence constraints: The route followed by each vehicle must be logically consistent, with no overlapping or conflicting assignments.  \nTime window constraints: Each customer must be served within their specified ready time and due time intervals, ensuring timely delivery.  \nArrival time constraints: The arrival time at each customer location must account for the travel distance from the previous location and the service time at the previous location.  \nNon-overlap constraints: Vehicles cannot simultaneously serve the same customer or occupy the same location at the same time.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, which is the sum of the distances traveled by each vehicle along its route, including travel to and from the depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two integers representing the x-coordinate and y-coordinate of the depot.  \nSubsequent lines (one per customer): Seven columns representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Define the sequence of customer points visited by each unmanned vehicle, including the depot as the start and end point.  \nArrival time variables for each customer: Represent the time at which each customer is visited by a vehicle, ensuring adherence to time window constraints.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customers: Total count of unmanned vehicles in the fleet and customer points to be served.  \nDepot location: The coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: Includes the coordinates, demand (not considered in this problem variant), ready time, due time, and service time for each customer.  \nDistance matrix: A precomputed matrix representing the travel distance between all pairs of locations (customers and depot).  \nTime windows: Ready time and due time for each customer, defining the permissible time interval for service.  \n\n3. Constraints  \nCustomer visit constraint: Each customer must be visited exactly once by one vehicle to fulfill their service requirements.  \nDepot routing constraint: Each vehicle must start its route at the central depot, visit its assigned customers in sequence, and return to the depot.  \nTime window constraints: Each customer must be visited within their specified time window, with the arrival time falling between the ready time and due time.  \nService time constraint: After arriving at a customer location, the vehicle must remain for the specified service time before proceeding to the next location.  \nNon-overlapping route constraint: The routes assigned to different vehicles must be logically conflict-free, with no overlapping assignments or duplicate visits.  \nUnlimited capacity assumption: Vehicle load capacity is not considered, allowing vehicles to carry an unlimited amount of goods.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled along all routes, including the return to the depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of vehicles and number of customers.  \n- Second line: Two integers representing the x-coordinate and y-coordinate of the central depot.  \n- Subsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand (not used), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle and each customer location, a binary decision variable indicating whether the vehicle travels directly from one location to another.  \nArrival time variables: For each customer location, a continuous variable representing the time at which the assigned vehicle arrives at that location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: The total number of unmanned vehicles available for delivery.  \nNumber of customer locations: The total number of customer points to be served, including the central depot.  \nDepot location: The coordinates of the central depot, from which all vehicles depart and to which they return.  \nCustomer data: For each customer location, the following attributes are specified:  \n- Customer ID  \n- x-coordinate and y-coordinate (spatial location)  \n- Ready time: The earliest time the customer is available to receive the delivery.  \n- Due time: The latest time by which the delivery must be completed.  \n- Service time: The time required to complete the delivery at the customer location.  \nDistance matrix: A precomputed matrix containing the pairwise Euclidean distances between all locations (depot and customers).  \n\n3. Constraints  \nRoute assignment constraints: Each customer location must be visited exactly once by one unmanned vehicle.  \nDepot return constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nSequence constraints: If a vehicle travels from location A to location B, the arrival time at location B must be greater than or equal to the sum of the arrival time at location A, the service time at location A, and the travel time from A to B.  \nTime window constraints: The arrival time at each customer location must lie within the specified ready time and due time for that location.  \nNon-overlapping route constraints: The routes of different vehicles must not conflict, ensuring that no two vehicles simultaneously visit the same customer location.  \nRelaxed capacity constraint: The load capacity of the unmanned vehicles is not considered in this problem, allowing each vehicle to carry an unlimited quantity of goods.  \n\n4. Objective Function  \nMinimize the total route distance of all vehicles, calculated as the sum of the distances traveled along the assigned routes for the entire fleet.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: An integer representing the total number of customer locations (including the depot).  \n- Subsequent lines (one per customer): Seven columns containing the following data for each location:  \n  - Customer ID  \n  - x-coordinate  \n  - y-coordinate  \n  - Demand (ignored in this problem due to relaxed capacity constraint)  \n  - Ready time  \n  - Due time  \n  - Service time",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nwarehouse = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != warehouse]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer locations visited by each vehicle, starting and ending at the central depot.  \nArrival time variables: Represent the time at which each vehicle arrives at each customer location.  \nService variables: Binary variables indicating whether a specific customer is served by a specific vehicle.\n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available to perform deliveries.  \nNumber of customers: Total count of customer locations requiring delivery service.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates (x, y): The location of the customer.  \n  - Demand: The quantity of goods required by the customer (not constrained in this problem).  \n  - Ready time: The earliest time the customer is ready to receive the delivery.  \n  - Due time: The latest time by which the delivery must be completed.  \n  - Service time: The fixed duration required to complete the delivery at the customer location.  \nTravel distances: Precomputed or dynamically calculated Euclidean distances between all pairs of locations (customers and depot).  \n\n3. Constraints  \nService coverage constraint: Each customer must be visited exactly once by one vehicle to fulfill their delivery demand.  \nRoute continuity constraint: Each vehicle must start its route at the central depot, visit a sequence of customer locations, and return to the depot.  \nTime window constraints: Each vehicle must arrive at each customer location within the specified ready time and due time window.  \nService time constraint: The service time at each customer location must be accounted for before the vehicle proceeds to the next location.  \nNon-overlapping routes constraint: No two vehicles can simultaneously serve the same customer.  \nUnlimited capacity relaxation: The load capacity of each vehicle is considered unlimited, allowing any vehicle to serve any number of customers regardless of their demand.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled by each vehicle along its assigned route, including the return to the depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the central depot.  \nSubsequent lines (one per customer): Seven columns representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary variables indicating whether a specific unmanned vehicle travels directly from one customer point to another.  \nVisit variables: Binary variables indicating whether a specific customer point is visited by a specific unmanned vehicle.  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: The total number of unmanned vehicles available for delivery.  \nNumber of customer points: The total number of service points that must be visited, excluding the central depot.  \nDepot location: The coordinates of the central depot where all vehicles start and end their routes.  \nCustomer locations: The x- and y-coordinates of each customer point.  \nTime windows: For each customer point, a ready time and due time specifying the earliest and latest allowable times for the vehicle to arrive and begin service.  \nService times: The time required to complete service at each customer point.  \nTravel distances: The Euclidean distance between every pair of points (including the depot and customer points).  \n\n3. Constraints  \nRoute assignment constraints: Each customer point must be visited exactly once by one vehicle.  \nDepot return constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nNon-overlapping route constraints: The routes assigned to different vehicles must not overlap, ensuring each customer point is served by only one vehicle.  \nTime window constraints: Each vehicle must arrive at each customer point within the specified ready time and due time for that point.  \nService completion constraints: A vehicle must remain at a customer point for the duration of the service time before departing to the next point on its route.  \nTravel sequence constraints: If a vehicle travels from one customer point to another, the arrival time at the second point must account for the departure time from the first point, the service time at the first point, and the travel time between the two points.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled along all routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: An integer representing the number of customer points (excluding the depot).  \n- Second line: Two floating-point numbers representing the x- and y-coordinates of the central depot.  \n- Subsequent lines (one per customer point): Seven values representing the customer number, x-coordinate, y-coordinate, demand (ignored in this variant), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Represent the sequence of customer points visited by each unmanned vehicle, including departure from and return to the central depot.  \nTime variables: Represent the arrival time at each customer location for each unmanned vehicle, ensuring adherence to the specified time windows.  \nAssignment variables: Binary variables indicating whether a specific customer point is served by a particular unmanned vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nNumber of customer points: Total count of customer locations to be served.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer data: Each customer is characterized by:  \n  - Customer ID: Unique identifier for the customer point.  \n  - Coordinates: X and Y positions of the customer location.  \n  - Demand: Quantity of goods required by the customer (not bounded by vehicle capacity in this variant).  \n  - Ready time: Earliest allowable arrival time for delivery.  \n  - Due time: Latest allowable arrival time for delivery.  \n  - Service time: Time required to complete delivery at the customer location.  \nDistance matrix: Precomputed pairwise distances between all customer points and the depot, based on Euclidean distance.  \n\n3. Constraints  \nVisit constraint: Each customer point must be visited exactly once by one unmanned vehicle, ensuring complete service coverage without duplication.  \nDepot constraint: Each vehicle must start and end its route at the central depot.  \nRoute feasibility constraint: The sequence of customer points served by each vehicle must form a valid route, with no overlapping or conflicting assignments.  \nTime window constraint: The arrival time at each customer location must lie within the specified ready and due time interval, accounting for travel and service times.  \nUnlimited capacity relaxation: Vehicles are assumed to have no load capacity constraints, allowing unrestricted delivery of goods.  \n\n4. Objective Function  \nMinimize the total route distance of all vehicles, calculated as the sum of the distances traveled by each vehicle from the depot, through its assigned customer points, and back to the depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer points.  \nSecond line: Two integers representing the X and Y coordinates of the depot.  \nSubsequent lines (one per customer): Seven values representing the customer ID, X-coordinate, Y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nwarehouse = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != warehouse]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Define the sequence of customer locations visited by each vehicle, including departure from and return to the central depot.  \nArrival time variables: Represent the time at which each vehicle arrives at each customer location, ensuring compliance with time window constraints.  \nService variables: Indicate whether a customer location is visited by a specific vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customer locations: Total count of delivery points, including the central depot.  \nCustomer data: For each customer location, the following information is provided:  \n  - Customer ID: Unique identifier for each location.  \n  - Coordinates: X and Y coordinates representing the geographical position of the customer location.  \n  - Demand: Quantity of goods required at the location (not constrained in this problem).  \n  - Ready time: Earliest time at which delivery can begin at the location.  \n  - Due time: Latest time by which delivery must be completed at the location.  \n  - Service time: Duration required to unload goods and complete the delivery at the location.  \nDistance matrix: Precomputed pairwise distances between all customer locations, including the depot.  \n\n3. Constraints  \nSingle-visit constraint: Each customer location must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nTime window constraints: Each vehicle must arrive at each customer location within the specified ready time and due time interval.  \nService time constraints: After arriving at a customer location, the vehicle must remain there for the specified service time before proceeding to the next location.  \nConflict-free route constraints: The delivery paths of all vehicles must be logically executable, with no overlapping assignments or impossible configurations.  \nUnlimited capacity relaxation: The load capacity of vehicles is not constrained, allowing them to carry unlimited goods.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances covered by each vehicle along its assigned route, including travel to and from the central depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer locations (including the depot).  \nSubsequent lines (one per customer location): Seven values representing the customer ID, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nArrival time variables: For each customer point, represent the time at which the assigned unmanned vehicle arrives at that point.  \nLoad variables: For each vehicle, represent the cumulative load on the vehicle as it serves its assigned customer points.\n\n2. Parameters and Input Data  \nNumber of vehicles and customers: Total count of unmanned vehicles in the fleet and customer service points to be visited.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer data: For each customer, the following information is provided:  \n  - Customer ID  \n  - Coordinates (x, y)  \n  - Demand (quantity of goods to be delivered)  \n  - Time window (ready time and due time during which the customer must be served)  \n  - Service time (duration required to complete delivery at the customer point).  \nVehicle capacity: Maximum load capacity for each unmanned vehicle, representing the total quantity of goods it can carry.  \nDistance matrix: Pairwise distances between all customer points and the depot, calculated based on their coordinates.\n\n3. Constraints  \nCapacity constraints: The total demand of all customer points assigned to an unmanned vehicle must not exceed its maximum load capacity.  \nAssignment constraints: Each customer point must be visited exactly once by one and only one unmanned vehicle.  \nRouting constraints: Each unmanned vehicle must start its route at the central depot, visit its assigned customer points in a feasible sequence, and return to the central depot.  \nTemporal constraints: Each customer point must be visited within its specified time window. The vehicle must arrive no earlier than the ready time and no later than the due time. If the vehicle arrives earlier than the ready time, it must wait until the ready time to begin service.  \nService time constraints: The service time at each customer point must be accounted for before the vehicle proceeds to the next point in its route.  \nNon-overlapping routes: The routes assigned to different vehicles must be logically conflict-free, ensuring no overlapping assignments or infeasible configurations.  \nTravel time constraints: The travel time between consecutive points on a vehicle's route must be respected, ensuring consistency with the distance matrix.\n\n4. Objective Function  \nMinimize the total travel distance of all unmanned vehicles, calculated as the sum of the distances traveled along the routes of all vehicles, including the return to the depot.\n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of customer points (including the depot) and the number of vehicles.  \n- Second line: Vehicle capacity (a single integer).  \n- Subsequent lines (one per customer, including the depot): Seven values specifying customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \n- The depot is always listed as customer 0, with demand 0 and service time 0.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nArrival time variables for each customer point: Represent the time at which a vehicle arrives at each customer location, ensuring compliance with time window constraints.  \nLoad variables for each vehicle: Represent the cumulative load carried by each vehicle at any point along its route, ensuring capacity constraints are met.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customer points: Total count of unmanned vehicles in the fleet and customer locations to be served.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: Each customer point is defined by its coordinates (x, y), demand (quantity of goods required), ready time (earliest allowable arrival time), due time (latest allowable arrival time), and service time (duration of service at the location).  \nVehicle capacity: Maximum load each unmanned vehicle can carry, expressed as a fixed numerical value.  \nDistance matrix: Precomputed pairwise distances between all customer points and the depot, used to calculate route lengths and travel times.  \n\n3. Constraints  \nCapacity constraints: The total load carried by each vehicle along its route must not exceed its maximum load capacity.  \nAssignment constraints: Each customer point must be visited exactly once by one vehicle, fulfilling its entire demand without duplication.  \nDepot constraints: Each vehicle must begin its route at the central depot, serve its assigned customer points, and return to the depot to complete its delivery cycle.  \nTemporal constraints: Each customer point must be visited within its designated time window, ensuring the arrival time falls between the ready time and due time.  \nNon-overlapping route constraints: Routes must be conflict-free, meaning no vehicle can simultaneously serve multiple customer points or overlap assignments with another vehicle.  \nSequence feasibility constraints: The order of customer visits within each route must be executable, ensuring logical progression without impossible configurations.  \n\n4. Objective Function  \nMinimize the total route distance of the entire unmanned vehicle fleet, calculated as the sum of distances traveled by all vehicles to complete their assigned delivery tasks.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and customer points.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the central depot.  \nSubsequent lines (one per customer): Seven columns containing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\nwarehouse = 0\n\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        travel_dist_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != warehouse]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][warehouse] for i in locations) == model.sum(arc[v][warehouse][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][warehouse] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = travel_dist_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer locations visited by each unmanned vehicle, starting and ending at the central depot.  \nArrival time variables: Represent the time at which each vehicle arrives at each customer location, ensuring compliance with specified time windows.  \nLoad variables: Represent the cumulative load carried by each vehicle at each point in its route, ensuring the vehicle's capacity is not exceeded.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for deliveries.  \nNumber of customers: Total count of customer locations to be served, excluding the central depot.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates (x, y): Location of the customer point.  \n  - Demand: Amount of goods required at the customer point.  \n  - Ready time and due time: Time window during which the customer must be visited.  \n  - Service time: Duration required to deliver goods at the customer point.  \nVehicle capacity: Maximum load capacity for each unmanned vehicle, defining the amount of goods it can carry.  \nTravel distances: Euclidean distances between all pairs of locations (customers and depot), calculated from their coordinates.  \n\n3. Constraints  \nVehicle capacity constraints: The total load carried by each unmanned vehicle must not exceed its maximum load capacity at any point in its route.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nRoute continuity constraints: Each vehicle must depart from the central depot, serve its assigned customer points in sequence, and return to the depot to complete its route.  \nTime window constraints: Each customer must be visited within their specified ready time and due time, ensuring compliance with availability requirements.  \nService time constraints: The service time at each customer point must be included in the vehicle's schedule, accounting for the time spent delivering goods.  \nNo-overlap constraints: The delivery paths of different vehicles must be conflict-free, meaning no overlapping assignments or impossible route configurations.  \nTravel consistency constraints: The arrival time at each customer must account for travel time from the previous location, ensuring logical routing sequences.  \n\n4. Objective Function  \nMinimize the total travel distance of all unmanned vehicles, representing the sum of distances traveled across all routes.  \n\n5. Data Specification  \nThe input file \"/data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two floating-point numbers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer): Seven columns containing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nBinary assignment variables: For each customer point, a binary variable indicates whether it is visited by a specific vehicle.  \nLoad variables: Represent the cumulative load carried by each vehicle at each point in its route.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customer points: Total count of unmanned vehicles in the fleet and service points, including the central depot.  \nCustomer data: Each customer point is characterized by its coordinates (x, y), demand, ready time, due time, and service time.  \nVehicle capacity: The maximum load capacity of each vehicle is fixed at 180 units.  \nTravel distances: Euclidean distances between all pairs of customer points, including the depot.  \nTime windows: Each customer point has a specific ready time (earliest time service can begin) and due time (latest time service must be completed).  \n\n3. Constraints  \nCapacity constraints: The total load carried by each vehicle at any point in its route must not exceed the maximum load capacity of 180 units.  \nCustomer service constraints: Each customer point must be visited exactly once by one vehicle to fulfill its entire demand.  \nDepot constraints: Each vehicle must start and end its route at the central depot.  \nRoute continuity constraints: Each vehicle must follow a continuous sequence of customer points, ensuring logical and executable paths.  \nTravel time constraints: Each vehicle must arrive at a customer point within its specified time window (ready time to due time). If a vehicle arrives early, it must wait until the ready time to begin service.  \nNon-overlapping constraints: No two vehicles can simultaneously serve the same customer point.  \nService time constraints: The service time at each customer point must be accounted for in the vehicles schedule before proceeding to the next point.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled by each vehicle along its route, including the return to the depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer points (including the depot).  \nSubsequent lines (one per customer point): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute assignment variables: Binary variables indicating whether a specific unmanned vehicle traverses a given edge between two customer locations (including the depot).  \nCustomer assignment variables: Binary variables indicating whether a specific customer is assigned to a particular unmanned vehicle.  \nArrival time variables: Continuous variables representing the time at which each unmanned vehicle arrives at each customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by each unmanned vehicle upon arriving at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for deliveries.  \nMaximum vehicle capacity: The maximum load capacity of each vehicle, fixed at 180 units.  \nNumber of customers: Total number of customer locations to be served.  \nDepot location: The central depot coordinates, from which all vehicles start and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Customer number (unique identifier).  \n  - Coordinates (x, y) representing the customers location.  \n  - Demand: The quantity of goods required by the customer.  \n  - Time window: Ready time and due time specifying the earliest and latest times the customer can be served.  \n  - Service time: The time required to unload goods at the customer location.  \nDistance matrix: A precomputed matrix where each element represents the Euclidean distance between two locations (including the depot and customer locations).  \n\n3. Constraints  \nRoute continuity constraints: Each unmanned vehicle must start its route at the central depot, visit a sequence of assigned customer locations, and return to the central depot.  \nCustomer assignment constraints: Each customer must be visited exactly once by one unmanned vehicle to fully satisfy its demand.  \nVehicle capacity constraints: The total demand served by each unmanned vehicle along its route must not exceed its maximum load capacity of 180 units.  \nTime window constraints: Each customer must be visited within their specified time window, with the vehicle arriving no earlier than the ready time and no later than the due time.  \nService time constraints: Upon arriving at a customer location, the vehicle must remain at the location for the specified service time before departing.  \nNon-overlapping route constraints: The routes assigned to different vehicles must not overlap in terms of customer assignments to ensure logical and executable delivery paths.  \nSubtour elimination constraints: The solution must not contain any disconnected cycles or subtours, ensuring that each vehicle completes a single continuous route starting and ending at the depot.  \n\n4. Objective Function  \nMinimize the total route distance traveled by the entire fleet of unmanned vehicles. This is calculated as the sum of the distances of all edges traversed by all vehicles in their assigned routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and the number of customers.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the central depot.  \nSubsequent lines (one per customer): Seven columns containing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\nwarehouse = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != warehouse]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly between two customer locations or between the depot and a customer location.  \nVehicle assignment variables: Binary decision variables indicating whether a specific customer is assigned to a particular vehicle.  \nArrival time variables: Continuous decision variables representing the time at which each vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nNumber of customers: Total count of customer locations requiring deliveries.  \nDepot location: The central starting and ending point for all vehicles.  \nCustomer data: Each customer is defined by their coordinates (x, y), demand (units of goods), ready time (earliest allowable arrival time), due time (latest allowable arrival time), and service time (duration required to complete delivery at the customer location).  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, set to 180 units.  \nTravel distances: Euclidean distances between all pairs of locations (customers and depot), calculated from their respective coordinates.  \n\n3. Constraints  \nCapacity constraints: The total demand of all customers assigned to a single vehicle must not exceed the vehicle's maximum load capacity of 180 units.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nRoute continuity constraints: Each vehicle must start its route at the depot, visit its assigned customers in sequence, and return to the depot after completing all deliveries.  \nTime window constraints: Each customer must be served within their specified ready time and due time, ensuring timely deliveries.  \nService time constraints: After arriving at a customer location, the vehicle must spend the required service time before departing for the next location.  \nConflict-free routing constraints: The generated delivery paths must be logically executable, meaning no overlapping assignments or impossible route configurations.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of distances traveled by each vehicle across all segments of their assigned delivery routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two integers representing the x-coordinate and y-coordinate of the depot location.  \nSubsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\n\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle traverses a specific edge (link) between two customer points or between a customer point and the depot.  \nAssignment variables: Binary decision variables indicating whether a specific customer is assigned to a specific vehicle.  \nArrival time variables: Continuous variables representing the arrival time of each vehicle at each customer point.  \nLoad variables: Continuous variables representing the cumulative load carried by each vehicle upon arrival at each customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nVehicle capacity: Maximum load capacity of each vehicle, which cannot be exceeded.  \nNumber of customer points: Total number of service points (excluding the depot) to be visited.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: Each customer point is defined by its coordinates, demand (quantity of goods to be delivered), ready time (earliest time the delivery can start), due time (latest time the delivery must be completed), and service time (time required to unload goods at the customer location).  \nTravel distances: A matrix specifying the travel distance between every pair of customer points and between the depot and each customer point.  \nExcluded customer point: Service Point No. 5 is removed from the network and must not be included in any route or assignment.  \n\n3. Constraints  \nCapacity constraints: The total amount of goods delivered by any vehicle must not exceed its maximum load capacity.  \nAssignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nRoute constraints: Each vehicle must start its route at the depot, visit its assigned customer points in a sequence, and return to the depot to complete the route.  \nTime window constraints: Each customer must be served within its specified ready time and due time. The arrival time at a customer point must satisfy these time bounds, and the service time must be accounted for before proceeding to the next point.  \nTravel consistency constraints: A vehicle can only travel between two points if both points are part of its assigned route.  \nNetwork exclusion constraint: Service Point No. 5 is excluded from all delivery routes and planning considerations.  \nConflict-free routing constraint: The set of delivery paths for all vehicles must be logically consistent and executable, with no overlapping assignments or impossible route configurations.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of unmanned vehicles required to complete all delivery tasks. This includes the sum of the distances traveled by all vehicles, reducing operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: An integer specifying the number of customer points (excluding the depot) and the number of vehicles available.  \n- Second line: Coordinates of the depot (x-coordinate and y-coordinate).  \n- Subsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \n- Travel distance matrix: A symmetric matrix indicating the distance between every pair of points (including the depot).",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the ordered sequence of customer points assigned to each vehicle, starting and ending at the central depot.  \nLoad variables for each vehicle: Represent the cumulative load carried by each vehicle at any point in its route.  \nTime variables for each customer: Represent the arrival time of a vehicle at each customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for deliveries.  \nNumber of customer points: Total number of customer locations to be served, excluding the central depot.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer point, the x-coordinate, y-coordinate, demand (quantity of goods to be delivered), ready time (earliest allowable arrival time), due time (latest allowable arrival time), and service time (time required to complete delivery at the location).  \nVehicle capacity: Maximum load capacity of each vehicle, ensuring no overloading.  \nDistance matrix: A precomputed matrix of pairwise Euclidean distances between all customer points and the depot.  \nExcluded service points: Service Point No. 5 is removed from consideration and must not appear in any route.  \n\n3. Constraints  \nVehicle capacity constraints: The total demand served by any vehicle on its route must not exceed its maximum load capacity.  \nVisit constraints: Each customer point must be visited exactly once by one and only one vehicle.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nTime window constraints: Each customer point must be served within its specified time window, defined by the ready time and due time. The arrival time at a customer point must not be earlier than its ready time, and the vehicle must wait if it arrives early.  \nService time constraints: The time spent at each customer point must include the specified service time before the vehicle can proceed to the next point in its route.  \nRoute feasibility constraints: The sequence of customer visits assigned to each vehicle must form a valid and continuous route, with no overlapping or conflicting assignments.  \nNetwork modification constraint: Service Point No. 5 is excluded from all planning and must not appear in any vehicle route.  \n\n4. Objective Function  \nMinimize the total route distance of all vehicles, defined as the sum of the distances traveled by each vehicle along its assigned route, including the return to the central depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of vehicles and the number of customer points (excluding the depot).  \n- Second line: Two integers representing the x-coordinate and y-coordinate of the central depot.  \n- Subsequent lines (one per customer point): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\nwarehouse = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly from one customer location to another.  \nLoad variables: Continuous variables representing the cumulative load carried by each vehicle after visiting a particular customer location.  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nVehicle capacity: Maximum load capacity of each vehicle, representing the upper limit on the total demand it can serve.  \nNumber of customers: Total number of customer locations to be served.  \nDepot location: Central starting and ending point for all vehicles.  \nCustomer data: For each customer, the following information is provided:  \n- Coordinates (x, y): Spatial location of the customer.  \n- Demand: Quantity of goods required by the customer.  \n- Time window: Ready time (earliest time the customer can be served) and due time (latest time the customer can be served).  \n- Service time: Duration required to serve the customer.  \nDistance matrix: Symmetric matrix representing the travel distance between each pair of locations (including the depot).  \n\n3. Constraints  \nCapacity constraints: The total demand served by each vehicle along its route must not exceed its maximum load capacity.  \nVisit constraints: Each customer must be visited exactly once by one vehicle, ensuring complete and non-duplicative service coverage.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nTime window constraints: Each customer must be served within their specified time window, with service starting no earlier than the ready time and no later than the due time.  \nService time constraints: The service time at each customer location must be included in the route schedule, extending the departure time from that location.  \nRoute feasibility constraints: All routes must be logically feasible, ensuring no overlapping assignments or impossible configurations.  \nNetwork exclusion constraint: Service Point No. 5 is excluded from all delivery routes and planning considerations due to its removal from the distribution network.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire vehicle fleet, calculated as the sum of the distances traveled along all selected routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Number of vehicles and vehicle capacity.  \nSecond line: Coordinates (x, y) of the depot.  \nSubsequent lines (one per customer): Customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables\nRoute variables for each vehicle: Represent the sequence of service points each unmanned vehicle visits, starting and ending at the central depot.\nBinary assignment variables: Indicate whether a specific vehicle visits a specific service point, ensuring each point is visited exactly once.\nLoad variables for each vehicle: Represent the total demand served by each vehicle on its route, ensuring it does not exceed the vehicle's capacity.\n\n2. Parameters and Input Data\nNumber of vehicles and service points: Total count of unmanned vehicles available and customer service points in the network.\nDepot location: Coordinates of the central depot from which all vehicles start and end their routes.\nService point details: Each service point has associated coordinates, demand, ready time, due time, and service time.\nVehicle capacity: Maximum load capacity for each unmanned vehicle, limiting the total demand it can serve on a route.\nNetwork modification: Service Point No. 5 is removed from the network and must not be included in any delivery route.\n\n3. Constraints\nCapacity constraints: The total demand served by each vehicle must not exceed its maximum load capacity.\nVisit constraints: Each service point must be visited exactly once by one vehicle, ensuring full demand coverage.\nDepot constraints: Each vehicle route must start and end at the central depot.\nRoute feasibility constraints: Routes must be executable without overlapping assignments or impossible configurations.\nNetwork exclusion constraint: Service Point No. 5 is excluded from all routes due to closure.\nTime window constraints: Each service point must be visited within its specified ready time and due time.\n\n4. Objective Function\nMinimize the total travel distance of all vehicles, reducing operational costs, energy consumption, and delivery time.\n\n5. Data Specification\nThe input file \"data/25c101.txt\" follows this format:\nEach line contains customer information with columns: customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly from one customer location to another.  \nAssignment variables: Binary decision variables indicating whether a specific customer is assigned to a particular vehicle.  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for deliveries.  \nNumber of customers: Total count of customer locations to be serviced, excluding the depot.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer data: Each customer is defined by its coordinates, demand, ready time, due time, and service time.  \nVehicle capacity: Maximum load capacity of each vehicle, representing the upper limit of goods it can carry.  \nDistance matrix: Precomputed pairwise distances between all locations (customers and depot) based on their coordinates.  \nService Point No. 5 exclusion: The specific customer location (Service Point No. 5) is removed from the network and must not be included in any route planning or assignment.  \n\n3. Constraints  \nCapacity constraints: The total demand of all customers assigned to a single vehicle must not exceed the vehicle's maximum load capacity.  \nAssignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nRoute constraints: Each vehicle must start its route at the depot, visit its assigned customers in sequence, and return to the depot to complete its delivery cycle.  \nTemporal window constraints: Each vehicle must arrive at a customer location within the specified ready time and due time for that customer, and must remain at the location for the designated service time before proceeding to the next location.  \nConflict-free route constraints: The routes generated for all vehicles must be logically executable, with no overlapping assignments or impossible configurations.  \nExclusion constraint: Service Point No. 5 must be excluded from all delivery routes and planning considerations due to its removal from the distribution network.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, calculated as the sum of distances covered across all routes, to reduce operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two floats representing the x-coordinate and y-coordinate of the depot location.  \nSubsequent lines (one per customer): Seven values representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\nwarehouse = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables representing whether a given vehicle travels directly between two customer locations (or between the depot and a customer) in its delivery route.  \nAssignment variables: Binary variables indicating whether a specific customer is assigned to a particular vehicle.  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at a customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nVehicle capacity: Maximum load capacity of each vehicle, specifying the total demand it can carry.  \nNumber of customers: Total number of customer locations to be served, excluding the depot.  \nDepot location: Central starting and ending location for all vehicles.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates: x and y coordinates of the customer location.  \n  - Demand: Amount of goods required by the customer.  \n  - Time windows: Ready time and due time specifying the earliest and latest times the customer can be served.  \n  - Service time: Time required to unload goods at the customer location.  \nDistance matrix: A precomputed matrix containing the travel distances between all pairs of locations (including the depot and customer locations).  \nExcluded service points: Service Point No. 5 is removed from the network and must be excluded from all routes.  \n\n3. Constraints  \nVehicle capacity constraints: The total demand served by each vehicle along its route must not exceed its maximum load capacity.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle to fulfill its entire demand.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the depot after completing its assigned deliveries.  \nRoute continuity constraints: If a vehicle travels from one location to another, it must also arrive at the subsequent location and continue its route logically without gaps or disconnections.  \nTime window constraints: Each customer must be served within their specified time window, considering the travel time, arrival time, and service time.  \nExclusion constraints: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \nNon-overlapping routes: Delivery routes must be conflict-free, meaning no vehicle can serve the same customer as another vehicle.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, calculated as the sum of the distances traveled along all selected routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of vehicles and the maximum capacity of each vehicle.  \n- Second line: One integer representing the total number of customers.  \n- Subsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \n- The distance matrix is implicitly derived from the coordinates of the depot and customer locations.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\n\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\n\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly from one service point to another.  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at each service point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery tasks.  \nNumber of service points: Total count of customer locations, including the central depot.  \nService point coordinates: Each service point (including the depot) is represented by its x and y coordinates.  \nTime windows: Each service point has a ready time and a due time, defining the time window during which it must be serviced.  \nService times: The fixed duration during which a vehicle must remain at a service point to complete the delivery.  \nDistance matrix: A precomputed matrix containing the travel distances between all pairs of service points.  \n\n3. Constraints  \nService assignment constraints: Each service point (excluding the depot) must be visited exactly once by one vehicle.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nRoute continuity constraints: If a vehicle travels from service point A to service point B, the arrival time at B must be greater than or equal to the sum of the departure time from A and the travel time between A and B.  \nTime window constraints: Each vehicle must arrive at a service point within the specified time window (ready time to due time) for that service point.  \nNon-overlapping routes: The routes assigned to different vehicles must not overlap in a way that violates the service assignment constraints.  \n\n4. Objective Function  \nMinimize the total travel distance of the fleet, which is the sum of the distances traveled by all vehicles across all routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of vehicles and the number of service points (including the depot).  \n- Subsequent lines (one per service point): Seven columns containing the service point number, x-coordinate, y-coordinate, demand (ignored in this problem), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly from one customer location to another.  \nArrival time variables: Continuous decision variables representing the time at which each vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customers: Total count of unmanned vehicles available for delivery and customer locations requiring service.  \nDepot location: Central hub from which all vehicles depart and to which they return after completing their routes.  \nCustomer data: Each customer is defined by a unique identifier, spatial coordinates (x, y), ready time, due time, and service duration.  \nDistance matrix: Precomputed pairwise distances between all locations (including the depot and customer points).  \nTime window constraints: Each customer has a specific time interval during which service must occur, defined by ready time and due time.  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the depot and return to the depot after serving its assigned customers.  \nLogical route constraints: Routes must be conflict-free and executable, meaning vehicles cannot simultaneously serve overlapping locations or follow infeasible paths.  \nTime window constraints: Each customer must be visited within their specified time window, ensuring operational feasibility and adherence to customer availability requirements.  \nArrival time consistency constraints: The arrival time at a customer location must account for the travel time from the preceding location and the service duration at that location.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, calculated as the sum of distances for all active travel arcs in the solution. This objective reduces operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSubsequent lines (one per customer): Seven columns specifying customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nwarehouse = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        travel_dist_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != warehouse]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][warehouse] for i in locations) == model.sum(arc[v][warehouse][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    model.add(t[v][warehouse] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = travel_dist_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle and each customer location, a binary decision variable indicating whether the vehicle visits the customer location as part of its route.  \nArrival time variables: For each customer location, a continuous variable representing the time at which the assigned vehicle arrives at that location.  \nRoute sequencing variables: For each pair of customer locations, a binary decision variable indicating whether one customer is visited immediately after the other by the same vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customers: Total count of unmanned vehicles available in the fleet and customer locations to be served.  \nDepot location: The coordinates of the central depot from which all vehicles depart and to which they return.  \nCustomer locations: Coordinates of each customer location, defining their spatial position.  \nTime windows: For each customer, a ready time (earliest time the customer can be served) and a due time (latest time the customer must be served).  \nService times: For each customer, the duration required to complete the delivery service at that location.  \nTravel distances: A matrix representing the Euclidean distance between every pair of locations (including the depot).  \n\n3. Constraints  \nCustomer visit constraints: Each customer location must be visited exactly once by one vehicle.  \nVehicle route constraints: Each vehicle must start its route at the depot, visit its assigned customer locations in a valid sequence, and return to the depot to complete its route.  \nTime window constraints: Each vehicle must arrive at each customer location within the specified time window for that customer. The arrival time at a customer location must not be earlier than the customers ready time or later than the due time.  \nService time constraints: The time spent at each customer location must account for the specified service time before the vehicle can proceed to the next location.  \nRoute sequencing constraints: If a vehicle visits one customer location immediately after another, the arrival time at the second location must be at least the departure time from the first location plus the travel time between the two locations.  \nNo-overlap constraints: Routes assigned to different vehicles must not overlap in such a way that a customer location is visited by more than one vehicle.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, where the travel distance is the sum of the distances covered by each vehicle in its complete route, including the return to the depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customers, followed by the number of vehicles.  \nSubsequent lines (one per customer): Seven columns specifying customer number, x-coordinate, y-coordinate, demand (not used in this variant), ready time, due time, and service time.  \nLast line: The coordinates of the depot.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables\nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.\nAssignment variables for each customer point: Binary decision variables indicating whether a specific customer point is visited by a particular vehicle.\n\n2. Parameters and Input Data\nNumber of vehicles and customer points: Total count of unmanned vehicles in the fleet and customer points to be serviced.\nCustomer point details: Each customer point has associated coordinates (x, y), demand, ready time, due time, and service time.\nDepot location: The central depot's coordinates, serving as the starting and ending point for all vehicle routes.\nMaximum load capacity: Each vehicle has a reference load capacity of 180 units, although load capacity constraints are relaxed in this variant.\n\n3. Constraints\nVisit constraint: Each customer point must be visited exactly once by one vehicle to fulfill its demand.\nRoute continuity constraint: Each vehicle must start its route at the central depot, visit its assigned customer points, and return to the depot.\nNon-overlapping route constraint: Delivery paths must be logically conflict-free, ensuring no overlapping assignments or impossible configurations.\nTime window constraints: Each customer point must be visited within its specified ready and due time window.\nService completion constraint: Service time at each customer point must be accommodated within the visit duration.\n\n4. Objective Function\nMinimize the total travel distance of the entire unmanned vehicle fleet, reducing operational costs, energy consumption, and delivery time.\n\n5. Data Specification\nThe input file \"data/25c101.txt\" follows this format:\nFirst line: Number of vehicles and number of customer points.\nSubsequent lines (one per customer point): Customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables\nRoute variables for each vehicle: Represent the sequence of customer locations each unmanned vehicle visits during its delivery route.\nBinary variables for customer visits: For each customer, a binary variable indicating whether a particular vehicle visits that customer.\nDeparture and return variables: Represent the times each vehicle departs from and returns to the central depot.\n\n2. Parameters and Input Data\nNumber of vehicles and customers: Total count of unmanned vehicles available and customer locations to be serviced.\nCustomer data: Each customer location is characterized by its coordinates (x, y), demand, ready time, due time, and service time.\nDepot location: Coordinates of the central depot from which all vehicles depart and return.\nMaximum load capacity: Each vehicle has a reference maximum load capacity of 180 units, although this is relaxed in this problem variant.\n\n3. Constraints\nSingle visit constraint: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.\nRoute continuity constraint: Each vehicle must start and end its route at the central depot, serving its assigned customers sequentially.\nConflict-free route constraint: The generated set of delivery paths must be logically executable, with no overlapping assignments or impossible configurations.\nTime window constraints: Each customer must be visited within their specified ready and due times, respecting service time requirements.\nCapacity reference constraint: Although the load capacity is relaxed, the reference maximum load capacity of 180 units per vehicle serves as a parameter for potential operational considerations.\n\n4. Objective Function\nMinimize the total route distance of the entire fleet of unmanned vehicles, reducing operational costs, energy consumption, and delivery time.\n\n5. Data Specification\nThe input file \"data/25c101.txt\" contains customer information with the following format:\n- Each line specifies details for one customer: customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nwarehouse = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != warehouse]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary variables indicating whether a specific vehicle travels directly from one customer location to another.  \nVisit variables: Binary variables representing whether a specific customer is visited by a specific vehicle.  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customer locations: Total count of customer points requiring service, excluding the central depot.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer data: Each customer point is defined by its coordinates (x, y), demand, ready time, due time, and service time.  \nMaximum load capacity: Each vehicle has a maximum load capacity of 180 units.  \nTravel distance matrix: Precomputed pairwise distances between all locations (including the depot and customer points).  \n\n3. Constraints  \nRoute assignment: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nConflict-free routing: The routes assigned to all vehicles must be logically feasible, with no overlapping or impossible configurations.  \nTime window constraints: Each customer must be visited within their specified ready time and due time window, ensuring timely delivery.  \nService time constraints: After arriving at a customer location, each vehicle must spend the specified service time fulfilling the customers demand before proceeding to the next location.  \nArrival time constraints: The arrival time at each customer location must account for travel time from the previous location and respect the ready time and due time constraints.  \nTravel distance minimization: Routes must be optimized to minimize the total travel distance across all vehicles.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of unmanned vehicles, reducing logistics costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer locations.  \nSecond line: Two integers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer): Seven columns indicating customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle traverses a given edge (from one customer point to another).  \nSequence variables: Continuous variables representing the order in which each customer point is visited within a route.  \nArrival time variables: Continuous variables representing the arrival time of each vehicle at each customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customer points: Total number of service points to be visited, including the depot.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer point, the following information is provided:  \n  - Customer number: Unique identifier of the customer point.  \n  - X-coordinate and Y-coordinate: Spatial location of the customer point.  \n  - Demand: Quantity of goods to be delivered to the customer.  \n  - Ready time and due time: Time window within which the delivery must occur.  \n  - Service time: Time required to complete delivery at the customer point.  \nDistance matrix: Precomputed matrix representing the travel distances between all pairs of customer points, including the depot.  \nVehicle capacity: Maximum load capacity of each vehicle, explicitly set to 180 units.  \n\n3. Constraints  \nAssignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nRoute constraints: Each vehicle must depart from the central depot, visit its assigned customer points in sequence, and return to the depot to complete its route.  \nNon-overlapping constraints: The delivery paths of all vehicles must be logically conflict-free, meaning no overlapping assignments or impossible route configurations.  \nTime window constraints: Deliveries to customer points must occur within their specified ready time and due time intervals.  \nService time constraints: The service time at each customer point must be accounted for in the arrival and departure times of the vehicle.  \nCapacity constraints: While the load capacity limit is relaxed, the maximum load capacity of each vehicle is explicitly set to 180 units, ensuring operational feasibility.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet, which is the sum of the distances traveled by all vehicles across their respective routes. This reduction in travel distance corresponds to minimizing operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer points (including the depot).  \nSecond line: Two floating-point numbers representing the X-coordinate and Y-coordinate of the depot.  \nSubsequent lines (one per customer point): Seven values representing the customer number, X-coordinate, Y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Binary decision variables indicating whether a vehicle travels directly from one customer location to another.  \nArrival time variables: Continuous decision variables representing the time at which a vehicle arrives at each customer location.  \nService sequence variables: Ordered sequence variables representing the visiting order of customer locations for each vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customer locations: Total number of customer points that require delivery service, excluding the central depot.  \nDepot location: The central starting and ending point for all vehicle routes.  \nCustomer demands: The demand (in units) associated with each customer location.  \nVehicle capacity: The maximum allowable load capacity for each unmanned vehicle, fixed at 180 units.  \nTravel distances: A distance matrix specifying the travel distance between every pair of locations (including the depot and all customer points).  \nTime windows: For each customer location, a ready time (earliest allowable start time for service) and a due time (latest allowable start time for service).  \nService times: The time required to complete delivery at each customer location.  \n\n3. Constraints  \nRoute assignment constraints: Each customer location must be visited exactly once by one vehicle.  \nDepot return constraints: Each vehicle must start and end its route at the central depot.  \nNon-overlapping route constraints: Vehicle routes must be disjoint, ensuring no two vehicles serve the same customer location.  \nService time constraints: Each vehicle must arrive at a customer location within the specified time window (ready time to due time) and spend the required service time before departing.  \nTravel time constraints: The arrival time at a customer location must account for the travel time from the previous location and the service time at the previous location.  \nMaximum load capacity constraints: Although vehicle capacity is not actively enforced in this variant, the maximum load capacity of 180 units is defined as a reference parameter.  \n\n4. Objective Function  \nMinimize the total route distance of all vehicles, calculated as the sum of the travel distances across all vehicle routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer locations.  \nSecond line: Coordinates of the depot (x-coordinate and y-coordinate).  \nSubsequent lines (one per customer): Seven values representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nwarehouse = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != warehouse]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle and each pair of customer locations (including the depot), a binary decision variable indicates whether the vehicle travels directly between the two locations.  \nArrival time variables: For each customer location, a continuous variable represents the time at which the assigned vehicle arrives at that location.  \nService assignment variables: For each customer, a decision variable specifies which unmanned vehicle is assigned to service that customer.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nNumber of customers: Total number of customer locations to be served, excluding the depot.  \nDepot location: The coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, the following input parameters are provided:  \n- Coordinates (x, y): The geographical location of the customer.  \n- Demand: The amount of goods to be delivered to the customer (in this relaxed variant, demand is not a binding constraint).  \n- Ready time: The earliest time at which the customer is ready to receive the delivery.  \n- Due time: The latest time by which the delivery must be completed.  \n- Service time: The time required to deliver goods and complete service at the customer location.  \nDistance matrix: A precomputed matrix specifying the travel distance between every pair of locations (including the depot and all customer locations).  \nMaximum vehicle load: The maximum load capacity of each vehicle, set as 180 units for reference purposes.  \n\n3. Constraints  \nRoute feasibility constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must depart from the central depot at the start of its route and return to the same depot at the end of its route.  \nContinuity constraints: If a vehicle travels to a customer location, it must also leave that location to ensure feasible and continuous routes.  \nTime window constraints: Each customer must be serviced within their specified time window, meaning the vehicles arrival time must not be earlier than the ready time or later than the due time.  \nService time constraints: The time spent at each customer location must be included in the calculation of arrival times at subsequent locations.  \nNon-overlapping routes: The routes assigned to different vehicles must not overlap in terms of customer assignments, ensuring logical consistency and conflict-free execution.  \nRelaxed capacity constraints: While the demand of each customer is provided as input, and a maximum vehicle load of 180 units is specified, this variant does not enforce strict capacity constraints on vehicle routes.  \n\n4. Objective Function  \nMinimize the total travel distance of the unmanned vehicle fleet, defined as the sum of the distances traveled by all vehicles across their respective routes. This objective aims to optimize logistics efficiency by reducing overall transportation costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and the number of customers.  \nSecond line: Two floating-point numbers representing the x- and y-coordinates of the depot.  \nSubsequent lines (one per customer): Seven values specifying the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nlocations = [i for i in range(num_locations) if i != depot]\ndemands = [data[3] for data in customer_data]\nvehicle_capacity = 180\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_load = model.sum(\n        arc[v][i][j] * demands[j]\n        for i in range(num_locations)\n        for j in locations\n    )\n    model.add(vehicle_load <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each vehicle, a sequence of customer points to be visited, including the depot as the start and end points.  \nVisit variables: Binary variables indicating whether a specific customer point is visited by a specific vehicle.  \nTravel variables: Continuous variables representing the distance traveled between consecutive points in a route for each vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customer points: Total count of service points excluding the depot, with Service Point No. 5 removed from the network.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer information: Each customer point includes its coordinates (x, y), demand (which is ignored in this variant), ready time, due time, and service time.  \nTravel distances: Euclidean distances between all pairs of points (customers and depot), calculated based on their coordinates.  \n\n3. Constraints  \nVisit constraints: Each customer point must be visited exactly once by one vehicle.  \nDepot constraints: Each vehicle must start its route at the depot and return to the depot after completing its assigned deliveries.  \nRoute feasibility constraints: The sequence of customer points visited by each vehicle must form a valid route with no overlaps or conflicts.  \nService exclusion constraint: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \nTime window constraints: Each customer point must be visited within its specified ready and due time, and the service time at each point must be accounted for in the route scheduling.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles across their routes, representing the sum of distances traveled between consecutive points in each vehicles route, including trips to and from the depot.  \n\n5. Data Specification  \nThe input file \"/data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the total number of customer points and vehicles.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the depot.  \nSubsequent lines (one per customer point): Seven values representing customer number, x-coordinate, y-coordinate, demand (ignored in this variant), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer locations visited by each unmanned vehicle, starting and ending at the central depot.  \nVisit variables for each customer: Binary variables indicating whether a specific customer is visited by a particular vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customers: Total count of customer locations to be served, excluding Service Point No. 5 due to closure.  \nDepot location: Coordinates of the central depot from which all vehicles must depart and return.  \nCustomer information: Each customer is characterized by its location (x-coordinate, y-coordinate), demand (not considered in this variant), ready time, due time, and service time.  \nDistance matrix: Precomputed matrix containing the Euclidean distances between all pairs of locations, including the depot and customer points.  \n\n3. Constraints  \nVisit constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must depart from the central depot and return to the same depot at the end of its delivery route.  \nExclusion constraint: Service Point No. 5 must not be included in any delivery route or planning considerations.  \nRoute feasibility constraints: The sequence of customer visits for each vehicle must form a valid, executable route without overlapping assignments or impossible configurations.  \nTime window constraints: Each customer must be served within its specified time window (ready time to due time), accounting for travel time and service duration.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, reducing operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: Two floating-point numbers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer): Seven values representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nwarehouse = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle, a sequence of customer locations to be visited, including the central depot as the start and end point.  \nVisit variables: Binary decision variables indicating whether a specific customer location is visited by a specific vehicle.  \nTravel variables: Continuous variables representing the distance traveled between consecutive customer locations in the route of each vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for deliveries.  \nNumber of customer locations: Total count of customer points to be served, excluding the central depot and Service Point No. 5.  \nDepot location: Coordinates of the central depot, where all vehicles start and end their routes.  \nCustomer locations: Coordinates of each customer point, along with their delivery demand, ready time, due time, and service time.  \nTravel distances: Euclidean distances between all pairs of locations (customer points and depot), computed from their coordinates.  \nTime windows: Ready and due times defining the allowable service window for each customer location.  \n\n3. Constraints  \nVisit constraint: Each customer location must be visited exactly once by one unmanned vehicle.  \nDepot constraint: Each vehicle must start and end its route at the central depot.  \nRoute feasibility constraint: The sequence of customer points visited by each vehicle must form a valid route, starting and ending at the depot, without overlapping or conflicting assignments.  \nExclusion constraint: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \nTime window constraints: Each customer location must be visited within its specified time window (ready time and due time).  \nService completion constraint: The service time at each customer location must be accounted for in the route schedule of the assigned vehicle.  \n\n4. Objective Function  \nMinimize the total travel distance of all unmanned vehicles, computed as the sum of distances traveled across all routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of vehicles.  \nSecond line: An integer representing the number of customer locations, excluding Service Point No. 5.  \nThird line: Two floating-point numbers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer location): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Define the sequence of customer points visited by each unmanned vehicle, including departure from and return to the central depot.  \nAssignment variables: Binary variables indicating whether a customer point is assigned to a specific vehicle.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery tasks.  \nNumber of customer points: Total count of service points excluding the central depot and Service Point No. 5, which has been removed from the network.  \nDepot location: Coordinates of the central depot, representing the start and end location for all vehicle routes.  \nCustomer data: Each customer point is characterized by its coordinates (x, y), demand (not considered in this variant), ready time, due time, and service time.  \nTravel distances: Euclidean distance between every pair of points (including depot and customer points), derived from their coordinates.  \n\n3. Constraints  \nService coverage constraint: Each customer point must be visited exactly once by one unmanned vehicle to fulfill its demand.  \nRoute continuity constraint: Each vehicle must start its route at the central depot, serve its assigned customer points in sequence, and return to the depot.  \nConflict-free routing constraint: The delivery paths generated must be logically executable, meaning no overlapping assignments or impossible route configurations.  \nExclusion constraint: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \nTime window constraints: Each customer point must be visited within its specified ready time and due time, ensuring timely delivery.  \nService time constraint: Each vehicle must account for the service time at each customer point when planning its route.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet, representing the sum of distances traveled across all routes. This reduces operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the total number of customer points (excluding Service Point No. 5) and the number of vehicles.  \nSubsequent lines (one per customer point): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time. The first line after the header corresponds to the central depot, which has demand 0 and service time 0.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each vehicle and each pair of customer points (including the depot), a binary decision variable indicating whether the vehicle travels directly from one point to the other.  \nArrival time variables: For each customer point, a continuous variable representing the time at which the vehicle arrives at that point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: The total number of unmanned vehicles available for delivery.  \nNumber of customer points: The total number of customer locations, excluding Service Point No. 5, which is removed from the distribution network.  \nDepot location: The central depot from which all vehicles depart and to which they return after completing their routes.  \nCustomer data: For each customer point, the following information is provided:  \n  - Customer number: A unique identifier for each customer location.  \n  - Coordinates: The x and y coordinates of the customer point in a 2D plane.  \n  - Ready time: The earliest time at which delivery can begin at the customer location.  \n  - Due time: The latest time by which delivery must be completed at the customer location.  \n  - Service time: The time required to complete delivery at the customer location.  \nDistance matrix: The pairwise Euclidean distances between all customer points and the depot, computed from the coordinates.  \n\n3. Constraints  \nRoute assignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the depot after completing its deliveries.  \nExclusion constraint: Service Point No. 5 must not be included in any route or delivery plan.  \nTime window constraints: Each customer point must be visited within its specified time window, i.e., the arrival time at the customer location must be between its ready time and due time.  \nService time constraints: After arriving at a customer point, the vehicle must remain at the location for the duration of the service time before proceeding to the next point.  \nLogical route feasibility: The generated routes must be conflict-free and executable, meaning no overlapping assignments or impossible route configurations.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, calculated as the sum of the distances covered by each vehicle along its assigned route.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customer points (excluding Service Point No. 5).  \nSubsequent lines (one per customer): Seven columns containing the customer number, x-coordinate, y-coordinate, demand (not used in this variant), ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nwarehouse = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle, define the sequence of customer points to be visited, including departure from and return to the central depot.  \nVisit variables: Binary decision variables indicating whether a specific customer point is visited by a particular vehicle.  \nTravel variables: Continuous variables representing the distance traveled between consecutive customer points within a vehicle's route.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nNumber of customer points: Total count of customer locations requiring service, excluding Service Point No. 5.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer data: For each customer point, the following information is provided:  \n- Customer number (excluding Service Point No. 5).  \n- x-coordinate and y-coordinate of the location.  \n- Demand quantity (not considered in this variant due to unlimited vehicle capacity).  \n- Ready time: Earliest time at which delivery can begin.  \n- Due time: Latest permissible time for delivery completion.  \n- Service time: Duration required to complete delivery at the customer point.  \n\nTravel distance matrix: Precomputed pairwise distances between all customer points and the depot based on Euclidean distance.  \n\n3. Constraints  \nVisit constraints: Each customer point must be visited exactly once by one unmanned vehicle to fulfill its delivery requirement.  \nDepot constraints: Each vehicle must begin its route at the central depot and return to the same depot after completing its assigned deliveries.  \nRoute feasibility constraints: The sequence of customer points visited by each vehicle must form a valid and executable route, with no overlapping or conflicting assignments.  \nService exclusion constraint: Service Point No. 5 is excluded from all delivery routes and must not be visited or considered in planning.  \nTemporal constraints: For each customer point, delivery must occur within its specified ready time and due time window, ensuring timely service.  \nTravel constraints: The total travel distance for each vehicles route is calculated based on the distances between consecutive points visited, including the depot.  \n\n4. Objective Function  \nMinimize the total travel distance of the unmanned vehicle fleet across all delivery routes, thereby reducing logistics costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer points.  \nSecond line: Two floating-point numbers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer point): Seven fields representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time. Service Point No. 5 is omitted from the file.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nArrival time variables for each customer point: Represent the specific time at which a vehicle arrives at each customer location.  \nLoad variables for each vehicle: Represent the cumulative load carried by each vehicle at any point along its route.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for deliveries.  \nNumber of customer points: Total count of service points requiring deliveries, including the central depot.  \nVehicle capacity: Maximum load capacity for each unmanned vehicle, fixed at 180 units.  \nCustomer demand: Each customer point has a specific demand quantity that must be fully delivered by a single vehicle.  \nTime windows: Each customer point has a designated ready time and due time, defining the permissible time window for delivery.  \nService time: Each customer point has a fixed service duration, representing the time required to unload goods.  \nTravel distances: Euclidean distances between all pairs of service points, calculated from their respective x and y coordinates.  \n\n3. Constraints  \nVehicle capacity constraints: The total load carried by any vehicle at any time must not exceed its maximum load capacity of 180 units.  \nCustomer assignment constraints: Each service point (excluding the depot) must be visited exactly once by a single vehicle, ensuring complete coverage without duplication.  \nRoute constraints: Each vehicle must start its route at the central depot, visit its assigned customer points in sequence, and return to the central depot to complete its delivery cycle.  \nConflict-free routing constraints: Delivery paths must be executable, meaning no overlapping assignments or infeasible configurations.  \nTime window constraints: Each customer point must be visited within its designated ready time and due time, ensuring compliance with customer availability requirements.  \nService time constraints: After arriving at a customer point, each vehicle must remain for the specified service duration to complete unloading before proceeding to the next point.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet, defined as the sum of all distances traveled across all routes, to reduce operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"/data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of customer points (including the depot) and the number of vehicles.  \nSubsequent lines (one per customer point): Seven columns representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nArrival time variables: Represent the time at which each vehicle arrives at a customer point, ensuring compliance with specified time windows.  \nLoad variables: Represent the cumulative load carried by each vehicle at each customer point, ensuring the load does not exceed the vehicle's maximum capacity.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customers: Total count of customer locations to be served.  \nDepot location: Coordinates of the central depot from which all vehicles depart and to which they return.  \nCustomer locations: Coordinates (x, y) for each customer point.  \nCustomer demands: Amount of goods required by each customer, expressed in units.  \nTime windows: Ready time and due time for each customer, defining the permissible interval during which delivery must occur.  \nService times: Fixed duration required to complete delivery at each customer point.  \nMaximum vehicle capacity: Load limit for each unmanned vehicle, set to 180 units.  \nDistance matrix: Precomputed pairwise distances between all locations (customers and depot), used for route optimization.  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot, visit its assigned customer points, and return to the depot to complete its delivery cycle.  \nCapacity constraints: The total load carried by each vehicle at any point in its route must not exceed the maximum vehicle capacity of 180 units.  \nTime window constraints: Each customer must be visited within their specified time window, with the vehicle arriving no earlier than the ready time and no later than the due time.  \nService time constraints: After arriving at a customer point, the vehicle must remain for the fixed service duration before proceeding to the next point.  \nNon-overlap constraints: Routes assigned to different vehicles must be logically conflict-free, ensuring no overlapping assignments or infeasible configurations.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, representing the sum of distances for all delivery paths, to reduce operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customers.  \nSecond line: The x and y coordinates of the depot location.  \nSubsequent lines (one per customer): Seven fields containing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\nwarehouse = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        travel_dist_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != warehouse]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][warehouse] for i in locations) == model.sum(arc[v][warehouse][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][warehouse] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = travel_dist_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute assignment variables: Binary decision variables indicating whether a specific vehicle travels directly between two customer locations (or between the depot and a customer).  \nArrival time variables: Continuous decision variables representing the time at which each vehicle arrives at each customer location.  \nLoad variables: Continuous decision variables representing the cumulative load carried by each vehicle upon arrival at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: The total number of unmanned vehicles available for delivery.  \nNumber of customers: The total number of customer locations to be served.  \nDepot location: The central depot where all vehicles start and end their delivery routes.  \nCustomer data: For each customer, the following information is provided:  \n- Coordinates (x, y): The geographical location of the customer.  \n- Demand: The quantity of goods required by the customer.  \n- Time window: The earliest and latest allowable times for the vehicle to arrive at the customer location.  \n- Service time: The time required to unload goods at the customer location.  \nVehicle capacity: The maximum load capacity of each vehicle, set to 180 units.  \nDistance matrix: A precomputed symmetric matrix specifying the travel distance between every pair of locations (including the depot and customer locations).  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by exactly one vehicle.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nCapacity constraints: The total demand served by a vehicle during its route must not exceed the vehicle's maximum load capacity of 180 units.  \nTime window constraints: Each vehicle must arrive at each customer location within the specified time window for that customer. Arrival times must respect the earliest (ready time) and latest (due time) allowable times.  \nService time constraints: The arrival time at the next customer location must account for the service time at the current location and the travel time between the two locations.  \nNon-overlapping route constraints: The routes assigned to different vehicles must not overlap, ensuring that no two vehicles serve the same customer.  \nConnectivity constraints: The routes assigned to each vehicle must form a single, continuous path starting and ending at the depot.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of unmanned vehicles. This is calculated as the sum of the distances traveled along all assigned routes, aiming to reduce logistics costs, energy consumption, and overall delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and the number of customers.  \nSubsequent lines (one per customer): Seven values representing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nThe distance matrix is precomputed and provided as a separate input or generated dynamically from the coordinates.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each vehicle, starting and ending at the depot.  \nArrival time variables for each customer: Represent the time at which a vehicle arrives at each customer point.  \nLoad variables for each vehicle: Represent the cumulative load carried by a vehicle at each point in its route.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customers: Total count of service points (excluding the depot).  \nVehicle capacity: Maximum load that each vehicle can carry, fixed at 180 units.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer point, the following information is provided:  \n  - Customer number: Unique identifier for the service point.  \n  - Coordinates: x and y coordinates of the customer location.  \n  - Demand: Quantity of goods required by the customer.  \n  - Time window: Ready time and due time, defining the time period during which the customer must be visited.  \n  - Service time: Time required to complete the delivery at the customer point.  \nTravel distances: Euclidean distance matrix between all customer points and the depot, calculated from their coordinates.  \n\n3. Constraints  \nVehicle capacity constraints: The total load carried by a vehicle at any point in its route must not exceed its maximum capacity of 180 units.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start and end its route at the central depot.  \nTime window constraints: Each customer must be visited within its designated time window, meaning the vehicle must arrive no earlier than the ready time and no later than the due time.  \nService time constraints: Once a vehicle arrives at a customer point, it must remain there for the duration of the specified service time before proceeding to the next point.  \nRoute feasibility constraints: The sequence of visits in each vehicles route must be logically consistent, ensuring no overlapping assignments or invalid configurations.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of vehicles, defined as the sum of the distances traveled by all vehicles across their respective routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and the number of customers.  \nSecond line: Two floating-point numbers representing the x and y coordinates of the depot.  \nSubsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle travels directly from one customer location to another.  \nArrival time variables: Continuous variables representing the time at which each unmanned vehicle arrives at a specific customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by an unmanned vehicle upon arrival at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available in the fleet.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, fixed at 180 units.  \nNumber of customers: Total number of customer locations to be served.  \nDepot location: Coordinates of the central depot, where all vehicles start and end their routes.  \nCustomer data: For each customer, the following attributes are provided:  \n  - Coordinates: x and y coordinates of the customer location.  \n  - Demand: Quantity of goods required by the customer.  \n  - Time window: Ready time (earliest time the customer can be served) and due time (latest time the customer must be served).  \n  - Service time: Time required to complete the delivery at the customer location.  \nDistance matrix: Euclidean distances between all pairs of locations (including the depot and customer locations).  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one unmanned vehicle.  \nDepot constraints: Each unmanned vehicle must start and end its route at the central depot.  \nVehicle capacity constraints: The cumulative load carried by each unmanned vehicle at any point in its route must not exceed its maximum capacity of 180 units.  \nTime window constraints: Each customer must be visited within their specified time window. The arrival time of the unmanned vehicle at the customer location must fall between the ready time and due time of the customer.  \nService time constraints: Upon arrival at a customer location, the unmanned vehicle must remain at the location for the duration of the service time before proceeding to the next location.  \nSubtour elimination constraints: The set of routes must not contain any disjoint cycles or subtours that do not include the depot.  \nNon-overlapping route constraints: No two unmanned vehicles may simultaneously occupy the same location or traverse the same segment of a route.  \n\n4. Objective Function  \nMinimize the total route distance traveled by the entire fleet of unmanned vehicles. This is calculated as the sum of the distances traveled between consecutive locations (including the depot) for all vehicles.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customers.  \nSecond line: Coordinates of the central depot (x-coordinate and y-coordinate).  \nSubsequent lines (one per customer): Seven values representing the following attributes for each customer:  \n  - Customer number (integer)  \n  - x-coordinate (float)  \n  - y-coordinate (float)  \n  - Demand (integer)  \n  - Ready time (integer)  \n  - Due time (integer)  \n  - Service time (integer)",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\nwarehouse = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        travel_dist_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != warehouse]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][warehouse] for i in locations) == model.sum(arc[v][warehouse][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][warehouse] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = travel_dist_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly between two customer locations (or between the depot and a customer).  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at a specific customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by each vehicle upon arrival at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery.  \nNumber of customers: Total count of customer locations to be served.  \nDepot location: The central starting and ending point for all vehicles.  \nCustomer data: For each customer, the following data is provided:  \n  - Coordinates (x, y): The geographical location of the customer.  \n  - Demand: The quantity of goods required by the customer.  \n  - Time window: The ready time and due time specifying the allowable time period for servicing the customer.  \n  - Service time: The time required to unload and complete the delivery at the customer location.  \nVehicle capacity: The maximum load capacity (180 units) of each unmanned vehicle.  \nDistance matrix: A precomputed matrix containing the travel distances between all pairs of locations (including the depot and customer points).  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nVehicle departure and return constraints: Each vehicle must start its route at the depot, visit its assigned customers, and return to the depot after completing its deliveries.  \nCapacity constraints: The cumulative load carried by each vehicle at any point during its route must not exceed the vehicle's maximum load capacity of 180 units.  \nTime window constraints: Each customer must be visited within their specified time window. The arrival time of the assigned vehicle at each customer location must fall between the ready time and due time of that customer.  \nService time constraints: The service time at each customer location must be accounted for in the vehicle's schedule before proceeding to the next location.  \nNon-overlapping route constraints: The set of delivery routes must be logically conflict-free, ensuring no overlapping assignments or infeasible route configurations.  \nSubtour elimination constraints: The generated routes must not contain subtours, i.e., disjoint cycles that do not include the depot.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire fleet of vehicles. This is achieved by summing the distances traveled along all active routes, with the goal of reducing logistics costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" contains the following customer and vehicle data:  \nFirst line: Two integers representing the number of customers and the number of vehicles.  \nSubsequent lines (one per customer): Seven columns specifying the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle travels directly between two customer points or between a customer point and the depot.  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at each customer point.  \nLoad variables: Continuous variables representing the total load carried by each vehicle upon arrival at each customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for goods delivery.  \nNumber of customer points: Total count of service points to be visited, excluding the central depot.  \nDepot location: Coordinates of the central depot, which serves as the starting and ending point for all vehicle routes.  \nCustomer data: Each service point is characterized by its coordinates, demand (amount of goods required), ready time (earliest allowable arrival time), due time (latest allowable arrival time), and service time (duration required to complete delivery).  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, ensuring safe operation and preventing overloading.  \n\n3. Constraints  \nRoute assignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nCapacity constraints: The total load carried by each vehicle at any point in its route must not exceed its maximum load capacity.  \nDepot constraints: Each vehicle must start its route at the central depot, serve its assigned customer points, and return to the central depot to complete its delivery cycle.  \nTime window constraints: Each customer point must be visited within its specified time window, ensuring that the vehicle arrives no earlier than the ready time and no later than the due time.  \nService exclusion constraint: Service Point No. 5 has been removed from the network and must not appear in any delivery route or planning considerations.  \nConflict-free routing constraints: The generated set of vehicle routes must be logically executable, ensuring no overlapping assignments or impossible route configurations.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles across all delivery routes, reducing operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and number of customer points.  \nSecond line: Two floating-point numbers representing the x-coordinate and y-coordinate of the central depot.  \nSubsequent lines (one per customer point): Seven values specifying the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle travels directly between two customer locations (or between the depot and a customer).  \nArrival time variables: Continuous variables representing the time at which a vehicle arrives at each customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by a vehicle immediately after visiting a specific customer location.  \n\n2. Parameters and Input Data  \nFleet size and capacity: Total number of unmanned vehicles available and their maximum load capacity.  \nCustomer data: For each customer, the following parameters are provided:  \n  - Location coordinates (x, y).  \n  - Demand: The quantity of goods to be delivered.  \n  - Time window: The earliest and latest times (ready time and due time) during which the customer must be served.  \n  - Service time: The time required to unload goods at the customer location.  \nDepot data: Location coordinates (x, y) of the central depot, where all vehicles must start and end their routes.  \nExcluded service points: A subset of customer locations (e.g., Service Point No. 5) that are removed from the distribution network and must not be visited.  \nDistance matrix: The pairwise travel distances between all customer locations and the depot, computed based on their coordinates.  \n\n3. Constraints  \nVehicle capacity constraints: The total load carried by each vehicle at any point in its route must not exceed its maximum load capacity.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle to fulfill its entire demand.  \nDepot constraints: Each vehicle must start its route from the central depot and return to the same depot after completing its assigned deliveries.  \nRoute continuity constraints: If a vehicle travels from one location to another, it must arrive at the second location after departing from the first, accounting for travel time and service time.  \nTime window constraints: Each customer must be visited within its specified time window. The vehicle must arrive no earlier than the ready time and no later than the due time.  \nExcluded service point constraints: Service Point No. 5 must not be included in any delivery route or planning considerations.  \nNon-overlapping route constraints: The delivery paths of the vehicles must be logically conflict-free, ensuring no overlapping assignments or infeasible configurations.  \n\n4. Objective Function  \nMinimize the total route distance of all vehicles, calculated as the sum of the distances traveled by each vehicle across its entire route.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: An integer representing the total number of customers (excluding the depot) and an integer representing the number of vehicles available.  \n- Second line: Two integers representing the x and y coordinates of the depot.  \n- Subsequent lines (one per customer): Seven columns containing the following information:  \n  - Customer number (integer).  \n  - x-coordinate (float).  \n  - y-coordinate (float).  \n  - Demand (integer).  \n  - Ready time (integer).  \n  - Due time (integer).  \n  - Service time (integer).",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\nwarehouse = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        travel_dist_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][warehouse] for i in locations) == model.sum(arc[v][warehouse][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][warehouse] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = travel_dist_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle traverses a specific edge (route) between two customer points, including the depot.  \nArrival time variables: Continuous variables representing the time at which each unmanned vehicle arrives at each customer point.  \nLoad variables: Continuous variables representing the cumulative load carried by each unmanned vehicle after visiting a specific customer point.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for the delivery operation.  \nVehicle capacity: The maximum load capacity of each unmanned vehicle, limiting the total demand it can serve on a single route.  \nNumber of customer points: Total number of customer locations to be served, excluding the depot.  \nDepot: Central starting and ending location for all unmanned vehicles.  \nCustomer demands: The quantity of goods required by each customer point.  \nCustomer time windows: Ready time and due time for each customer point, defining the permissible time interval during which the point must be visited.  \nService times: The time required to unload goods at each customer point.  \nTravel distances: A distance matrix specifying the travel distance between every pair of locations, including the depot and all customer points.  \nExcluded customer points: Service Point No. 5 is permanently removed and must not appear in any route.  \n\n3. Constraints  \nVehicle capacity constraints: The total demand served by any unmanned vehicle on its delivery route must not exceed its maximum load capacity.  \nVisit constraints: Each customer point must be visited exactly once by one unmanned vehicle, ensuring complete and non-duplicative service.  \nRoute continuity constraints: Each unmanned vehicle must depart from the central depot, visit its assigned customer points in sequence, and return to the depot to complete its route.  \nTime window constraints: Each unmanned vehicle must arrive at each customer point within the specified ready time and due time for that point, ensuring compliance with customer availability.  \nService time constraints: After arriving at a customer point, the unmanned vehicle must account for the specified service time before departing to the next point.  \nExclusion constraints: Service Point No. 5 must not be included in any delivery route or planning considerations.  \nNon-overlapping constraints: The routes assigned to different unmanned vehicles must not overlap, ensuring conflict-free delivery paths.  \nSubtour elimination constraints: The solution must not contain any disconnected subtours that do not include the depot, ensuring all routes are connected and feasible.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet, calculated as the sum of the distances traveled by all vehicles across all routes. This objective reflects the goal of reducing logistics costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of customer points (excluding the depot) and the number of unmanned vehicles.  \nSubsequent lines (one per customer point): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nThe file also includes a distance matrix, representing the travel distance between each pair of locations (depot and customer points).",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each vehicle, including departure from and return to the central depot.  \nArrival time variables for each customer point: Represent the time at which a vehicle arrives at each customer point, ensuring compliance with time window constraints.  \nLoad variables for each vehicle: Represent the cumulative load carried by each vehicle at any given point in its route, ensuring adherence to maximum load capacity.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned delivery vehicles available for routing.  \nNumber of customer points: Total count of service points to be visited, excluding the central depot.  \nDepot location: Coordinates of the central depot, serving as the origin and destination for all vehicle routes.  \nCustomer data: Each customer point is defined by its coordinates, demand (quantity of goods to be delivered), time window (ready time and due time), and service time (duration required to complete delivery).  \nVehicle capacity: Maximum load capacity for each unmanned delivery vehicle.  \n\n3. Constraints  \nRoute assignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nCapacity constraints: The total goods delivered by each vehicle must not exceed its maximum load capacity at any point in its route.  \nDepot constraints: Each vehicle must start its route at the central depot, visit its assigned customer points in sequence, and return to the central depot to complete its delivery cycle.  \nTime window constraints: Each customer point must be visited within its designated time window, requiring the vehicle to arrive no earlier than the ready time and no later than the due time.  \nExclusion constraints: Service Point No. 5 must be excluded from all delivery routes and planning considerations, as it has been removed from the distribution network.  \nConflict-free routing constraints: The generated delivery paths must be logically executable, ensuring no overlapping assignments or impossible route configurations.  \n\n4. Objective Function  \nMinimize the total travel distance of the unmanned vehicle fleet, calculated as the sum of distances traveled by all vehicles across their assigned routes. This objective reduces operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Number of vehicles and number of customer points.  \nSecond line: Depot coordinates (x, y).  \nSubsequent lines (one per customer point): Customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute assignment variables: Binary decision variables indicating whether a specific unmanned vehicle travels directly from one customer location to another.  \nArrival time variables: Continuous variables representing the arrival time of each unmanned vehicle at each customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by each unmanned vehicle at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customers: Total count of unmanned vehicles in the fleet and customer locations to be serviced.  \nDepot location: The central depot from which all unmanned vehicles start and return after completing their assigned routes.  \nCustomer data: For each customer, the following information is provided:  \n- Coordinates (x, y): The spatial location of the customer.  \n- Demand: The quantity of goods required by the customer.  \n- Time window: The earliest and latest possible times (ready time and due time) that the customer can be serviced.  \n- Service time: The duration required to unload the goods at the customer's location.  \nVehicle capacity: The maximum load capacity of each unmanned vehicle, which cannot be exceeded.  \nTravel distances: A matrix representing the Euclidean distance between every pair of locations (depot and customer points).  \n\n3. Constraints  \nRoute feasibility constraints: Each unmanned vehicle must start and end its route at the central depot.  \nCustomer service constraints: Each customer must be visited exactly once by one unmanned vehicle, and their entire demand must be fulfilled by that vehicle.  \nVehicle capacity constraints: The total load carried by each unmanned vehicle must not exceed its maximum load capacity at any point in its route.  \nTime window constraints: Each unmanned vehicle must arrive at each customer location within the specified time window for that customer. If the vehicle arrives early, it must wait until the ready time before starting the service.  \nService exclusion constraint: Service Point No. 5 must not be included in any route or visited by any unmanned vehicle.  \nNon-overlapping route constraints: The routes assigned to different unmanned vehicles must be logically conflict-free, ensuring no overlapping assignments or infeasible configurations.  \nSubtour elimination constraints: The generated routes must not contain disconnected cycles or subtours that do not include the depot.  \n\n4. Objective Function  \nMinimize the total route distance of the entire unmanned vehicle fleet, calculated as the sum of travel distances across all vehicles and their assigned routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and the number of customers.  \nSubsequent lines (one per customer): Seven columns containing the following information for each customer:  \n- Customer number (integer)  \n- x-coordinate (float)  \n- y-coordinate (float)  \n- Demand (integer)  \n- Ready time (float)  \n- Due time (float)  \n- Service time (float)",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\nwarehouse = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        travel_dist_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][warehouse] for i in locations) == model.sum(arc[v][warehouse][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][warehouse] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = travel_dist_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle traverses a particular edge (connection between two locations).  \nArrival time variables: Continuous variables representing the time at which each vehicle arrives at each customer location.  \nLoad variables: Continuous variables representing the cumulative load carried by each vehicle upon arrival at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles and capacity: Total number of unmanned vehicles in the fleet and the maximum load capacity of each vehicle.  \nNumber of customers: Total number of customer locations to be served, excluding the central depot.  \nDepot: The central depot from which all vehicles must depart and to which they must return.  \nCustomer demands: The amount of goods required by each customer, expressed as a positive integer.  \nCustomer time windows: For each customer, a specific ready time (earliest allowable arrival time) and due time (latest allowable arrival time).  \nService times: The fixed amount of time required to complete delivery at each customer location.  \nTravel distances: A distance matrix specifying the travel distance between every pair of locations (including the depot and customer points).  \n\n3. Constraints  \nRoute assignment constraints: Each customer must be visited exactly once by exactly one vehicle.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nCapacity constraints: The total demand of all customers served by a single vehicle must not exceed its maximum load capacity.  \nTime window constraints: Each vehicle must arrive at each customer location within the specified time window for that customer. If a vehicle arrives earlier than the ready time, it must wait until the ready time to begin service.  \nService exclusion constraint: Service Point No. 5 is removed from the distribution network and must not be included in any delivery route.  \nSubtour elimination constraints: The set of routes must form a single connected solution, ensuring that no disconnected or circular subtours exist.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, defined as the sum of distances traveled along all edges included in the selected routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: An integer specifying the number of customer points (excluding the depot).  \n- Second line: An integer specifying the number of vehicles in the fleet and their uniform maximum load capacity.  \n- Subsequent lines (one per customer and depot): Seven columns representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \n- Note: The depot is included as the first entry in the file, with demand set to zero. Customer 5 is excluded from the problem.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = \"data/25c101.txt\"\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    for line in f:\n        if line.strip().startswith(\"CUST NO.\"):\n            break\n    for line in f:\n        parts = line.strip().split()\n        if parts:\n            customer_data.append([int(p) for p in parts])\n\nnum_vehicles = 3\nvehicle_capacity = 200\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\ncoords = np.array([[c[1], c[2]] for c in customer_data])\ndemands = [c[3] for c in customer_data]\nready_times = [c[4] for c in customer_data]\ndue_times = [c[5] for c in customer_data]\nservice_times = [c[6] for c in customer_data]\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        dist = math.sqrt((coords[i][0] - coords[j][0]) ** 2 + (coords[i][1] - coords[j][1]) ** 2)\n        distance_matrix[i][j] = dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\") for j in range(num_locations)] for i in range(num_locations)] for v\n       in range(num_vehicles)]\nt = [[model.integer_var(min=ready_times[i], max=due_times[i], name=f\"t_{v}_{i}\") for i in range(num_locations)] for v in\n     range(num_vehicles)]\n\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if j != i) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][i][depot] for i in locations) == model.sum(arc[v][depot][j] for j in locations))\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) == model.sum(\n            arc[v][i][k] for k in range(num_locations) if k != i))\n\nfor v in range(num_vehicles):\n    total_demand = model.sum(\n        demands[i] * model.sum(arc[v][j][i] for j in range(num_locations) if j != i) for i in locations)\n    model.add(total_demand <= vehicle_capacity)\n\nfor v in range(num_vehicles):\n    model.add(t[v][depot] == 0)\n    for i in range(num_locations):\n        for j in locations:\n            if i != j:\n                travel_time = distance_matrix[i][j]\n                service_time = service_times[i]\n                model.add(model.if_then(\n                    arc[v][i][j] == 1,\n                    t[v][j] >= t[v][i] + service_time + int(travel_time)\n                ))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables for each vehicle: Represent the sequence of customer points visited by each unmanned vehicle, starting and ending at the central depot.  \nAssignment variables: Binary decision variables indicating whether a specific customer point is assigned to a specific vehicle.  \nLoad variables for each vehicle: Represent the cumulative load carried by each vehicle along its route, ensuring capacity limitations are respected.  \nTime variables for each customer point: Represent the arrival time at each customer point and the departure time after completing service, ensuring adherence to time window constraints.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery tasks.  \nNumber of customer points: Total count of service points excluding the central depot and any removed points (e.g., Service Point No. 5).  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, fixed at 180 units.  \nCustomer demands: Amount of goods required by each customer point.  \nService times: Time required to complete delivery at each customer point.  \nTime windows: Ready time and due time for each customer point, specifying the permissible time range for delivery.  \nDistance matrix: Euclidean distances between all customer points and the central depot, computed from their coordinates.  \n\n3. Constraints  \nCapacity constraints: The total load carried by each vehicle must not exceed its maximum capacity of 180 units.  \nAssignment constraints: Each customer point must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot, serve its assigned customer points, and return to the same central depot to complete its delivery cycle.  \nRoute feasibility constraints: The sequence of visits by each vehicle must form a valid and executable route, with no overlapping assignments or impossible configurations.  \nTime window constraints: Each customer point must be visited within its specified ready time and due time, ensuring delivery occurs within operational limits.  \nService exclusion constraints: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \n\n4. Objective Function  \nMinimize the total travel distance of all unmanned vehicles, calculated as the sum of distances traveled by each vehicle along its route, including the return to the central depot.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Integer representing the number of vehicles.  \nSecond line: Integer representing the number of customer points, excluding the central depot and removed points.  \nSubsequent lines (one per customer point): Seven columns specifying the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nFinal line: Coordinates of the central depot.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a vehicle travels directly from one customer location to another.  \nAssignment variables: Binary decision variables representing whether a specific vehicle serves a particular customer.  \nArrival time variables: Continuous variables specifying the time at which each vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for delivery operations.  \nMaximum load capacity: Each vehicle has a maximum load capacity of 180 units.  \nDepot location: The central depot where all vehicles start and end their delivery routes.  \nCustomer locations: Each customer is defined by a unique ID, coordinates (x, y), demand (in units), ready time, due time, and service time.  \nExcluded customer: Customer ID 5 is removed from the network and must not be included in any route or assignment.  \nDistance matrix: A precomputed matrix specifying pairwise distances between all locations, including the depot and customer points.  \n\n3. Constraints  \nCapacity constraints: The total demand served by each vehicle must not exceed its maximum load capacity of 180 units.  \nAssignment constraints: Each customer must be visited exactly once by one vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must start its route at the central depot, visit its assigned customer locations, and return to the depot.  \nService exclusion constraint: Customer ID 5 is excluded from all routes and assignments, reflecting its removal from the distribution network.  \nTime window constraints: Each vehicle must arrive at a customer location within the specified ready time and due time for that customer.  \nService time constraints: Upon arrival at a customer location, each vehicle must remain for the specified service time before departing.  \nRouting constraints: The set of delivery paths must be conflict-free, ensuring no overlapping assignments or infeasible route configurations.  \n\n4. Objective Function  \nMinimize the total route distance traveled by all vehicles, reducing operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of customers (excluding the depot).  \nSubsequent lines (one per customer): Seven columns containing the customer ID, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nThe depot is represented as customer ID 0 with coordinates and zero demand.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\nwarehouse = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle and each customer location, a binary variable indicating whether the vehicle visits the customer location.  \nSequence variables: For each unmanned vehicle, a set of ordered variables representing the sequence of customer visits along the vehicle's route.  \nLoad variables: For each unmanned vehicle at each customer location, a continuous variable representing the cumulative load carried by the vehicle upon reaching that location.  \n\n2. Parameters and Input Data  \nNumber of vehicles and customers: The total number of unmanned vehicles in the fleet and the total number of customer locations to be served.  \nVehicle capacity: The maximum load capacity of each unmanned vehicle, fixed at 180 units.  \nDepot location: The central depot where all vehicles start and end their delivery routes.  \nCustomer data: For each customer location, the following data is provided:  \n  - Customer number: Unique identifier for each customer.  \n  - Coordinates: x and y coordinates of the customer location.  \n  - Demand: The quantity of goods required by the customer.  \n  - Time window: Ready time and due time specifying the earliest and latest times the customer can be served.  \n  - Service time: The time required to complete the delivery at the customer location.  \nTravel distances: A distance matrix specifying the travel distance between every pair of locations (including the depot).  \n\n3. Constraints  \nCapacity constraints: The total load carried by each unmanned vehicle at any point along its route must not exceed its maximum load capacity of 180 units.  \nVisit constraints: Each customer location must be visited exactly once by one unmanned vehicle, ensuring complete and non-duplicative service.  \nDepot constraints: Each vehicle must start its route at the central depot and return to the same depot after completing its assigned deliveries.  \nSequence constraints: The sequence of customer visits for each vehicle must form a valid route, with no sub-tours or disconnected paths.  \nTime window constraints: Each customer must be served within their specified time window, with the vehicle arriving no earlier than the ready time and no later than the due time.  \nExclusion constraints: Customer location 5 must not be included in any delivery route, as it has been removed from the distribution network.  \n\n4. Objective Function  \nMinimize the total travel distance of all vehicles, defined as the sum of the travel distances along the routes taken by all vehicles in the fleet.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: Two integers representing the number of vehicles and the number of customer locations.  \nSubsequent lines (one per customer): Seven columns representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: For each unmanned vehicle, a sequence of service points visited, starting and ending at the central depot.  \nLoad variables: The amount of goods carried by each vehicle at any point along its route, ensuring compliance with capacity constraints.  \nBinary assignment variables: For each pair of service points and vehicles, a binary variable indicating whether the vehicle travels directly between the two points.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total count of unmanned vehicles available for deliveries.  \nNumber of service points: Total count of customer service points, excluding the central depot and any removed locations (e.g., Service Point No. 5).  \nMaximum vehicle capacity: Fixed at 180 units for all vehicles.  \nService point data: Each service point is characterized by its unique identifier, x-coordinate, y-coordinate, demand (in units of goods), ready time, due time, and service time.  \nDepot location: The central depot is specified by its unique identifier and coordinates.  \nTravel distances: Symmetric distance matrix representing the travel cost between every pair of service points, including the depot.  \n\n3. Constraints  \nVehicle capacity constraints: The total load carried by any vehicle at any point in its route must not exceed the maximum capacity of 180 units.  \n\nCustomer service constraints: Each service point must be visited exactly once by one vehicle, and its entire demand must be fulfilled during that visit.  \n\nDepot constraints: Each vehicle must start and end its route at the central depot.  \n\nRoute continuity constraints: If a vehicle travels to a service point, it must also depart from that point to ensure a continuous, conflict-free route.  \n\nRemoved service point constraint: Service Point No. 5 is excluded from all routes and planning considerations.  \n\nTime window constraints: Each service point must be visited within its specified ready time and due time, and the vehicle must remain at the service point for the required service time before departing.  \n\nTravel distance constraints: The total travel distance of all vehicles must be minimized, ensuring efficient routing.  \n\n4. Objective Function  \nMinimize the total travel distance of the unmanned vehicle fleet, defined as the sum of distances traveled by all vehicles across all assigned routes.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \nFirst line: An integer representing the number of service points (excluding the depot).  \nSecond line: An integer representing the number of vehicles.  \nSubsequent lines (one per service point): Seven values representing the service point number, x-coordinate, y-coordinate, demand, ready time, due time, and service time. The depot is listed as service point number 0.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific vehicle traverses a specific edge (route) between two customer locations or between a customer and the depot.  \nCustomer assignment variables: Binary decision variables indicating whether a specific customer is assigned to a specific vehicle.  \nArrival time variables: Continuous decision variables representing the time at which a vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nNumber of vehicles: Total number of unmanned vehicles available for delivery.  \nNumber of customers: Total number of customer locations requiring service, excluding the central depot.  \nDepot location: Coordinates of the central depot where all vehicles start and end their routes.  \nCustomer data: For each customer, the following information is provided:  \n  - Coordinates: x and y location of the customer.  \n  - Demand: Quantity of goods required by the customer.  \n  - Time window: Ready time and due time defining the allowable time range for service.  \n  - Service time: Time required to unload the goods at the customer location.  \nVehicle capacity: Maximum load capacity of each vehicle, set to 180 units.  \nExcluded service points: Specific customer locations that must not be included in any route (e.g., Service Point No. 5).  \n\n3. Constraints  \nVehicle capacity constraints: The total demand served by each vehicle must not exceed its maximum load capacity of 180 units.  \nCustomer assignment constraints: Each customer must be visited exactly once by one vehicle to fulfill their entire demand.  \nDepot constraints: Each vehicle must start and end its route at the central depot.  \nRoute continuity constraints: For each vehicle, the sequence of customer visits must form a continuous and feasible route, with no disjoint segments.  \nTime window constraints: Each vehicle must arrive at a customer location within the specified time window (ready time to due time).  \nService time constraints: The service time at each customer location must be accounted for in the vehicle's schedule before proceeding to the next location.  \nExcluded service point constraints: Service Point No. 5 must not be included in any route due to its removal from the distribution network.  \nNon-overlapping route constraints: Routes assigned to different vehicles must not overlap in terms of customer assignments.  \n\n4. Objective Function  \nMinimize the total route distance of the entire unmanned vehicle fleet, which is the sum of the distances traveled by all vehicles. This objective reflects the goal of reducing operational costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"data/25c101.txt\" follows this format:  \n- First line: Two integers representing the number of vehicles and number of customers.  \n- Second line: Two floating-point numbers representing the x and y coordinates of the central depot.  \n- Subsequent lines (one per customer): Seven values representing the customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\nwarehouse = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != warehouse and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ntravel_dist_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            travel_dist = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            travel_dist_matrix[i][j] = travel_dist\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][warehouse][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][warehouse] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_path_length = num_locations\nu = [[model.integer_var(min=0, max=max_path_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][warehouse] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_travel_dist = model.sum(\n    arc[v][i][j] * travel_dist_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_travel_dist)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total travel_dist): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned paths are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{warehouse}_{j}\") for j in locations) == 0:\n            continue\n        path = [warehouse]\n        current_loc = warehouse\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == warehouse:\n                path.append(warehouse)\n                break\n            path.append(next_loc)\n            current_loc = next_loc\n        path_str = \" -> \".join(map(str, path))\n        print(path_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nRoute variables: Binary decision variables indicating whether a specific unmanned vehicle travels between two customer locations or between the depot and a customer location.  \nCustomer assignment variables: Binary decision variables specifying which unmanned vehicle is assigned to each customer location.  \nArrival time variables: Continuous decision variables representing the time at which a vehicle arrives at each customer location.  \n\n2. Parameters and Input Data  \nFleet size: Total number of unmanned vehicles available for delivery operations.  \nVehicle capacity: Maximum load capacity of each unmanned vehicle, fixed at 180 units.  \nDepot location: Coordinates of the central depot from which all vehicles depart and return.  \nCustomer locations: Coordinates of each customer point in the distribution network, excluding Service Point No. 5 due to closure.  \nCustomer demands: Amount of goods required at each customer location.  \nTime windows: Ready time and due time for each customer location, defining the permissible time range for deliveries.  \nService time: Duration required to complete delivery at each customer location.  \nTravel distances: Euclidean distances between all pairs of locations (customers and depot).  \n\n3. Constraints  \nCapacity constraints: The total goods delivered by each unmanned vehicle must not exceed its maximum load capacity of 180 units.  \nCustomer assignment constraints: Each customer location must be visited exactly once by one unmanned vehicle, ensuring complete service coverage without duplication.  \nDepot constraints: Each vehicle must depart from the central depot, serve its assigned customer locations, and return to the depot to complete its delivery cycle.  \nRoute feasibility constraints: Delivery routes must be conflict-free and executable, meaning no overlapping assignments or impossible configurations.  \nExclusion constraints: Service Point No. 5 must be excluded from all delivery routes and planning considerations.  \nTime window constraints: Each vehicle must arrive at each customer location within the specified ready time and due time for that location.  \nService constraints: Vehicles must account for the service time at each customer location when planning their routes.  \nTravel distance constraints: Routes must consider the Euclidean distances between all locations to ensure accurate travel calculations.  \n\n4. Objective Function  \nMinimize the total travel distance of the entire unmanned vehicle fleet to complete all delivery tasks, reducing logistics costs, energy consumption, and delivery time.  \n\n5. Data Specification  \nThe input file \"/data/25c101.txt\" follows this format:  \nFirst line: Integer representing the number of customers, followed by the number of vehicles.  \nSubsequent lines (one per customer): Seven columns containing customer number, x-coordinate, y-coordinate, demand, ready time, due time, and service time.  \nFinal line: Coordinates of the depot.",
    "input": "",
    "output": "import math\nimport numpy as np\nfrom docplex.cp.model import CpoModel\n\ndata_file_path = 'data/25c101.txt'\n\ncustomer_data = []\nwith open(data_file_path, 'r') as f:\n    next(f)\n    for line in f:\n        parts = line.split()\n        if parts:\n            customer_data.append([int(p) for p in parts[:4]])\n\nnum_vehicles = 3\nvehicle_capacity = 180\ndepot = 0\nnum_locations = len(customer_data)\nnode_to_skip = 5\nlocations = [i for i in range(num_locations) if i != depot and i != node_to_skip]\ndemands = [data[3] for data in customer_data]\ncoords = np.array([[data[1], data[2]] for data in customer_data])\ndistance_matrix = [[0.0] * num_locations for _ in range(num_locations)]\n\nfor i in range(num_locations):\n    for j in range(num_locations):\n        if i != j:\n            x1, y1 = customer_data[i][1], customer_data[i][2]\n            x2, y2 = customer_data[j][1], customer_data[j][2]\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            distance_matrix[i][j] = distance\n\nmodel = CpoModel()\n\narc = [[[model.binary_var(name=f\"arc_{v}_{i}_{j}\")\n         for j in range(num_locations)]\n        for i in range(num_locations)]\n       for v in range(num_vehicles)]\n\nfor i in locations:\n    model.add(model.sum(arc[v][j][i] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n    model.add(model.sum(arc[v][i][j] for v in range(num_vehicles) for j in range(num_locations) if i != j) == 1)\n\nfor v in range(num_vehicles):\n    model.add(model.sum(arc[v][depot][j] for j in locations) <= 1)\n    model.add(model.sum(arc[v][j][depot] for j in locations) <= 1)\n\nfor v in range(num_vehicles):\n    for i in locations:\n        model.add(model.sum(arc[v][j][i] for j in range(num_locations) if j != i) ==\n                  model.sum(arc[v][i][j] for j in range(num_locations) if j != i))\n\nfor v in range(num_vehicles):\n    vehicle_demand = model.sum(\n        demands[j] * model.sum(arc[v][i][j] for i in range(num_locations) if i != j) for j in locations)\n    model.add(vehicle_demand <= vehicle_capacity)\n\nmax_route_length = num_locations\nu = [[model.integer_var(min=0, max=max_route_length, name=f\"u_{v}_{i}\")\n      for i in range(num_locations)]\n     for v in range(num_vehicles)]\n\nfor v in range(num_vehicles):\n    model.add(u[v][depot] == 0)\n    for i in locations:\n        model.add(model.if_then(model.sum(arc[v][i][j] for j in range(num_locations) if i != j) == 0, u[v][i] == 0))\n    for i in locations:\n        for j in locations:\n            if i != j:\n                model.add(model.if_then(arc[v][i][j] == 1, u[v][j] >= u[v][i] + 1))\n\nmodel.add(model.sum(arc[v][i][node_to_skip] for v in range(num_vehicles) for i in range(num_locations)) == 0)\nmodel.add(model.sum(arc[v][node_to_skip][j] for v in range(num_vehicles) for j in range(num_locations)) == 0)\n\ntotal_distance = model.sum(\n    arc[v][i][j] * distance_matrix[i][j]\n    for v in range(num_vehicles)\n    for i in range(num_locations)\n    for j in range(num_locations)\n)\n\nmodel.minimize(total_distance)\n\nprint(\"Solving the model...\")\nsolution = model.solve(TimeLimit=60, Workers=4)\n\nif solution:\n    print(f\"\\nSolution found! Objective value (total distance): {solution.get_objective_value():.2f}\")\n    print(\"\\nThe planned routes are as follows:\")\n    for v in range(num_vehicles):\n        if sum(solution.get_value(f\"arc_{v}_{depot}_{j}\") for j in locations) == 0:\n            continue\n        route = [depot]\n        current_loc = depot\n        while True:\n            next_loc = -1\n            for j in range(num_locations):\n                if current_loc != j and solution.get_value(f\"arc_{v}_{current_loc}_{j}\") > 0.5:\n                    next_loc = j\n                    break\n            if next_loc == -1 or next_loc == depot:\n                route.append(depot)\n                break\n            route.append(next_loc)\n            current_loc = next_loc\n        route_str = \" -> \".join(map(str, route))\n        print(route_str)\nelse:\n    print(\"\\nNo solution found within the time limit!\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection: A set of 6 decision variables, each representing one genetic sequence to be selected from the predefined word list. Each sequence is an ordered tuple of 8 integers, where each integer corresponds to a nucleotide (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid genetic sequences, each represented as an ordered tuple of 8 integers. This list ensures biological feasibility by containing only nucleotide combinations that meet specific biochemical criteria.  \nSequence length: Each genetic sequence must be exactly 8 bases long.  \nGC content requirement: The GC content (proportion of guanine and cytosine bases) must be exactly 50% for each sequence, meaning each sequence must contain exactly 4 guanine (G) and cytosine (C) bases in total.  \nHamming distance threshold: A minimum Hamming distance of 4 between any two distinct sequences in the set and between any sequence and its reverse complement.  \n\n3. Constraints  \nSequence selection constraint: The 6 selected sequences must be distinct and chosen from the predefined word list of valid genetic sequences.  \nGC content constraint: Each selected sequence must have exactly 4 guanine (G) and cytosine (C) bases, ensuring a GC content of 50%.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct sequences in the set must be at least 4, ensuring sufficient diversity and avoiding cross-base pairing issues.  \nReverse complement Hamming distance constraint: The Hamming distance between each sequence and its reverse complement must be at least 4, preventing self-base pairing and the formation of secondary structures.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 genetic sequences that simultaneously satisfy all the biochemical and structural constraints. No optimization criterion is specified beyond the satisfaction of constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of 8 integers enclosed in brackets, where:  \n0 represents nucleotide A,  \n1 represents nucleotide T,  \n2 represents nucleotide C,  \n3 represents nucleotide G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nSequence variables: Represent each DNA sequence to be designed, consisting of 8 positions, each with a nucleotide selected from the predefined word list.\nReverse complement variables: Represent the reverse complement of each DNA sequence, ensuring compliance with biochemical constraints.\n\n2. Parameters and Input Data\nSequence length: Each DNA sequence must be exactly 8 bases in length.\nNumber of sequences: A total of 6 DNA sequences need to be designed.\nValid nucleotide combinations: A predefined list of valid DNA sequences from which each position in the designed sequences must be selected.\nGC content requirement: Each sequence must have exactly 50% GC content, meaning 4 out of 8 bases should be either G or C.\n\n3. Constraints\nSelection constraint: Each position in the DNA sequence must be selected from the predefined word list to ensure biological feasibility.\nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) and cytosine (C) bases to maintain thermodynamic stability.\nHamming distance constraint between sequences: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sequence diversity and preventing cross-hybridization.\nHamming distance constraint with reverse complements: The Hamming distance between any DNA sequence and its reverse complement must be at least 4 to prevent self-hybridization and unwanted structural formations.\n\n4. Objective Function\nDesign a set of 6 DNA sequences that simultaneously satisfies all biochemical and structural constraints.\n\n5. Data Specification\nThe input file \"data/word.txt\" contains the list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for sequence selection: For each valid DNA sequence from the predefined word list, a binary variable indicates whether the sequence is included in the solution set (1 if selected, 0 otherwise).  \nArray variables for selected sequences: An ordered array of six variables, each representing one of the 8-base DNA sequences in the solution set. Each variable takes its value from the predefined word list.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 DNA sequences.  \nSequence length: Each DNA sequence is exactly 8 bases long.  \nPredefined word list: A set of valid DNA sequences, each represented as an 8-base string composed of nucleotides A, T, C, and G, encoded as integers (0=A, 1=T, 2=C, 3=G).  \nGC content requirement: The GC content (proportion of guanine and cytosine bases) for each sequence must be exactly 50%.  \nHamming distance requirement:  \n- Minimum Hamming distance of 4 between any two different sequences in the solution set.  \n- Minimum Hamming distance of 4 between any sequence and its reverse complement.  \n\n3. Constraints  \nSequence selection constraint: Exactly 6 sequences must be selected from the predefined word list to form the solution set.  \nGC content constraint: For each selected sequence, the number of guanine (G) and cytosine (C) bases must equal 4 out of the total 8 bases, ensuring a GC content of 50%.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct sequences in the solution set must be at least 4, ensuring sufficient diversity to avoid cross-hybridization.  \nReverse complement Hamming distance constraint: For each selected sequence, the Hamming distance between the sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \n\n4. Objective Function  \nNo explicit objective function is defined. The problem is a feasibility problem, aiming to find any set of 6 DNA sequences that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n[0, 1, 2, 3, 3, 2, 1, 0]  \n[3, 2, 1, 0, 0, 1, 2, 3]  \n[2, 2, 3, 3, 0, 0, 1, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nBinary variables for sequence selection: Represent whether a specific sequence from the predefined word list is included in the final set of designed sequences.\nSequence composition variables: Represent the nucleotide composition of each selected sequence, ensuring compliance with biochemical constraints.\n\n2. Parameters and Input Data\nNumber of sequences to design: A total of 6 genetic sequences must be designed.\nSequence length: Each sequence must be exactly 8 bases long.\nValid nucleotide combinations: Predefined word list containing all valid sequences, read from a file named \"word.txt\".\nNucleotide encoding: Integers 0, 1, 2, and 3 represent nucleotides A, T, C, and G respectively.\n\n3. Constraints\nGC content constraint: Each sequence must have exactly 50% GC content, meaning 4 out of 8 bases must be either G (guanine) or C (cytosine).\nHamming distance constraint between sequences: The Hamming distance between any two different sequences must be at least 4 to ensure sufficient diversity and discrimination.\nHamming distance constraint with reverse complement: The Hamming distance between any sequence and its reverse complement must be at least 4 to prevent self-base pairing.\nTerminal stability constraint: The last base of each sequence must be either C or G to enhance binding stability.\n\n4. Objective Function\nThere is no specific objective function for optimization; the goal is to find any set of sequences that satisfy all the given constraints.\n\n5. Data Specification\nThe input file \"data/word.txt\" contains the valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0 represents A, 1 represents T, 2 represents C, and 3 represents G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence selection: A set of 6 decision variables, each representing one DNA sequence selected from the predefined word list of valid nucleotide combinations. Each variable corresponds to an 8-base sequence.  \n\n2. Parameters and Input Data  \nNumber of sequences: The objective is to design exactly 6 DNA sequences.  \nSequence length: Each DNA sequence must consist of exactly 8 nucleotide bases.  \nValid word list: A predefined list of valid DNA sequences, where each sequence is an 8-base combination of nucleotides represented as integers (0=A, 1=T, 2=C, 3=G).  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two different DNA sequences must be at least 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal stability requirement: The last nucleotide of each DNA sequence must be either cytosine (C) or guanine (G).  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any pair of distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and unintended folding structures.  \nTerminal stability constraint: The final base of each DNA sequence must be either cytosine (C) or guanine (G) to enhance terminal binding stability.  \n\n4. Objective Function  \nNo explicit optimization objective is specified. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the valid DNA sequences. Each line represents an 8-base sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables indicating whether each DNA sequence from the predefined word list is selected as part of the final solution.  \nSequence composition variables: Integer variables representing the nucleotide composition (0=A, 1=T, 2=C, 3=G) for each position in each selected DNA sequence.  \n\n2. Parameters and Input Data  \nSequence length: Each DNA sequence must be exactly 8 nucleotides long.  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \nValid word list: A predefined list of DNA sequences containing biologically feasible nucleotide combinations, provided in the input file.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal stability requirement: The last nucleotide of each DNA sequence must be either cytosine (C) or guanine (G).  \n\n3. Constraints  \nSequence selection constraint: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraint: Each DNA sequence must have exactly 50% GC content, meaning 4 out of the 8 positions must be either guanine (G) or cytosine (C).  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal stability constraint: The last nucleotide of each DNA sequence must be either cytosine (C) or guanine (G) to ensure enhanced binding stability at the sequence termini.  \n\n4. Objective Function  \nMaximize the diversity of selected DNA sequences, measured by the sum of pairwise Hamming distances between all selected sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" follows this format:  \nEach line represents a valid DNA sequence as a comma-separated list of integers enclosed in brackets, where 0 represents adenine (A), 1 represents thymine (T), 2 represents cytosine (C), and 3 represents guanine (G).",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Represent the nucleotide composition of each genetic sequence as an ordered list of 8 bases, where each base is chosen from the predefined word list.  \nBinary decision variables for base selection: For each position in each sequence, a binary variable indicates whether a particular nucleotide (0=A, 1=T, 2=C, 3=G) is selected.  \n\n2. Parameters and Input Data  \nNumber of sequences: A total of 6 genetic sequences must be designed.  \nSequence length: Each genetic sequence must contain exactly 8 nucleotide bases.  \nPredefined word list: A list of valid nucleotide combinations, representing biologically feasible sequences, is provided as input.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two different genetic sequences must be at least 4.  \nReverse complement constraint: The Hamming distance between any genetic sequence and its reverse complement must also be at least 4.  \nTerminal stability constraint: The last nucleotide in each genetic sequence must be either cytosine (C) or guanine (G).  \n\n3. Constraints  \nSequence validity constraint: Each genetic sequence must be selected from the predefined word list, ensuring biological feasibility.  \nGC content constraint: Each sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint between sequences: The Hamming distance between any pair of distinct genetic sequences must be at least 4, ensuring sufficient discrimination between sequences.  \nReverse complement constraint: The Hamming distance between each genetic sequence and its reverse complement must be at least 4, preventing self-base pairing and secondary structure formation.  \nTerminal stability constraint: The final nucleotide of each genetic sequence must be either cytosine (C) or guanine (G), providing enhanced binding stability at the sequence terminus.  \n\n4. Objective Function  \nMaximize the diversity of the designed sequences, measured as the sum of pairwise Hamming distances between all sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains a list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Define six DNA sequences, each represented as a sequence of 8 integer variables, where each variable corresponds to a nucleotide base (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nNumber of sequences: The total number of DNA sequences to design is 6.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nValid nucleotide combinations: A predefined word list specifies all valid 8-base DNA sequences. Each sequence is represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content, meaning that exactly 4 of the 8 bases in each sequence must be either G (3) or C (2).  \nReverse complement: The reverse complement of a DNA sequence is obtained by reversing the sequence and replacing each base with its complement (AT, CG). For example, the reverse complement of [0, 1, 2, 3] (ATCG) is [3, 2, 1, 0] (CGAT).  \n\n3. Constraints  \nValid sequence constraint: Each DNA sequence must be selected from the predefined word list of valid 8-base sequences.  \nGC content constraint: Each DNA sequence must have exactly 4 G (3) or C (2) bases out of 8, ensuring a GC content of 50%.  \nHamming distance constraint between sequences: The Hamming distance between any two distinct DNA sequences must be at least 4. The Hamming distance is defined as the number of positions at which the corresponding bases in two sequences are different.  \nHamming distance constraint for reverse complements: The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal stability constraint: The last base of each DNA sequence must be either C (2) or G (3).  \n\n4. Objective Function  \nThe objective is to design six DNA sequences that satisfy all the constraints. There is no optimization criterion beyond satisfying the constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined list of valid DNA sequences. Each line in the file represents a valid sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base in a sequence is represented by an integer value where 0 = A, 1 = T, 2 = C, and 3 = G.  \n\n2. Parameters and Input Data  \nPredefined word list: A list of valid DNA sequences provided as input, where each sequence is represented as a comma-separated list of integers enclosed in brackets (e.g., [0, 1, 2, 3, 0, 1, 2, 3]). This list ensures that all designed sequences are biologically feasible.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%, meaning each sequence must contain exactly 4 G or C bases combined.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences in the designed set must be at least 4.  \nReverse complement distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must also be at least 4. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base with its complement (0  1, 2  3).  \nTerminal stability requirement: The final base of each DNA sequence must be either C (2) or G (3).  \n\n3. Constraints  \nValid sequence selection: Each designed DNA sequence must be chosen from the predefined word list, ensuring biological feasibility.  \nGC content constraint: Each DNA sequence must contain exactly 4 bases that are either guanine (G) or cytosine (C), ensuring a GC content of 50%.  \nHamming distance constraint between sequences: The Hamming distance between any pair of distinct DNA sequences in the designed set must be at least 4. This ensures sufficient diversity and avoids cross-hybridization.  \nReverse complement constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal stability constraint: The last base of each DNA sequence must be either C (2) or G (3), ensuring enhanced binding stability at sequence termini.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 DNA sequences that satisfies all the above constraints. There is no optimization criterion beyond satisfying the constraints; the goal is to find a feasible solution.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. The file format is as follows:  \n- Each line represents a valid DNA sequence as a comma-separated list of integers enclosed in brackets.  \n- Each integer corresponds to a nucleotide base where 0 = A, 1 = T, 2 = C, and 3 = G.  \nExample:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[2, 3, 0, 1, 2, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables representing whether each valid genetic sequence from the predefined word list is included in the final set of designed sequences.  \nSequence composition variables: Integer decision variables representing the count of each nucleotide (A, T, G, C) in each selected genetic sequence.  \nPairwise Hamming distance variables: Integer decision variables representing the Hamming distance between any two selected genetic sequences.  \nReverse complement Hamming distance variables: Integer decision variables representing the Hamming distance between each selected genetic sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nSequence length: Each genetic sequence must be exactly 8 bases long.  \nNumber of sequences to design: A total of 6 genetic sequences must be selected.  \nGC content requirement: For each genetic sequence, the proportion of guanine (G) and cytosine (C) bases must be exactly 50%.  \nHamming distance threshold: The Hamming distance between any two selected genetic sequences must be at least 4.  \nReverse complement distance threshold: The Hamming distance between each selected genetic sequence and its reverse complement must be at least 4.  \nGlobal base composition balance: Across all selected genetic sequences, the difference in the total number of any two types of bases (A, T, G, or C) must not exceed 2.  \nValid genetic sequences: A predefined word list containing valid nucleotide combinations.  \n\n3. Constraints  \nSequence selection constraints: Exactly 6 genetic sequences must be selected from the predefined word list.  \nGC content constraints: For each selected genetic sequence, the count of guanine (G) and cytosine (C) bases must sum to exactly 4, ensuring a GC content of 50%.  \nPairwise Hamming distance constraints: The Hamming distance between any two selected genetic sequences must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement distance constraints: The Hamming distance between each selected genetic sequence and its reverse complement must be at least 4, preventing self-base pairing and secondary structure formation.  \nGlobal base composition balance constraints: Across all selected genetic sequences, the difference in the total count of any two nucleotide types (A, T, G, C) must not exceed 2, maintaining compositional equilibrium.  \n\n4. Objective Function  \nMaximize the diversity of the selected genetic sequences, represented by the sum of pairwise Hamming distances between all selected sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Binary variables representing the selection of DNA sequences from the predefined word list, where each sequence is encoded as an ordered list of integers (0=A, 1=T, 2=C, 3=G).  \nGC content variables: Binary variables indicating the proportion of guanine (G) and cytosine (C) bases in each selected sequence, ensuring 50% GC content for thermodynamic stability.  \nHamming distance variables: Integer variables representing the number of differing positions between any pair of DNA sequences and between each sequence and its reverse complement.  \nBase composition balance variables: Integer variables representing the total count of each base type (A, T, G, C) across all selected sequences, ensuring global compositional equilibrium.  \n\n2. Parameters and Input Data  \nNumber of sequences: A fixed set of 6 DNA sequences to be designed.  \nSequence length: Each DNA sequence is precisely 8 bases long.  \nWord list: A predefined list of valid DNA sequences, each represented as a comma-separated list of integers (0=A, 1=T, 2=C, 3=G), provided in the input file.  \nGC content threshold: The proportion of guanine (G) and cytosine (C) bases must be exactly 50% for each sequence.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences and between any sequence and its reverse complement is 4.  \nBase composition balance threshold: The difference in the total count of any two types of bases (A, T, G, C) across all selected sequences shall not exceed 2.  \n\n3. Constraints  \nSequence selection constraint: Each selected DNA sequence must be chosen from the predefined word list.  \nGC content constraint: The proportion of guanine (G) and cytosine (C) bases in each selected sequence must be exactly 50%, ensuring thermodynamic stability during molecular interactions.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement Hamming distance constraint: The Hamming distance between each DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and folding structure formation.  \nGlobal base composition balance constraint: Across all selected DNA sequences, the difference in the total number of any two types of bases (A, T, G, C) shall not exceed 2, ensuring overall compositional equilibrium.  \n\n4. Objective Function  \nMaximize sequence diversity by ensuring the highest possible average Hamming distance between all pairs of selected DNA sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains a list of valid DNA sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of six decision variables, each representing one DNA sequence to be designed. Each sequence consists of exactly 8 positions, where each position can take one of four values (0=A, 1=T, 2=C, 3=G).  \nBase composition variables: Integer variables representing the total count of each base (A, T, G, C) across all six DNA sequences.  \n\n2. Parameters and Input Data  \nNumber of sequences: The total number of DNA sequences to be designed is 6.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nValid word list: A predefined list of valid DNA sequences, provided in the input file \"data/word.txt\". Each sequence in the list is represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences is 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement is 4.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%. This translates to exactly 4 out of the 8 positions in each sequence being either G or C.  \nGlobal base composition balance: Across all six DNA sequences, the difference in the total number of any two types of bases (A, T, G, or C) must not exceed 2.  \n\n3. Constraints  \nSequence validity constraint: Each DNA sequence must be selected from the predefined valid word list provided in the input data.  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4. This ensures sufficient diversity among the designed sequences.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4. This prevents self-hybridization and formation of unintended secondary structures.  \nGlobal base composition balance constraint: Across all six DNA sequences, the difference in the total count of any two bases (A, T, G, or C) must not exceed 2, ensuring overall compositional balance.  \n\n4. Objective Function  \nThe objective is to find any feasible solution that satisfies all the constraints. Since no optimization criterion is specified, the problem is modeled as a feasibility problem.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the list of valid DNA sequences. Each line in the file represents a valid sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n[0,1,2,3,0,1,2,3]  \n[3,2,1,0,3,2,1,0]  \n[1,0,3,2,1,0,3,2]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Define 6 genetic sequences, each represented as an ordered list of 8 integer variables, where each variable takes a value from the set {0, 1, 2, 3}, corresponding to the nucleotide bases A, T, C, and G respectively.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 genetic sequences are to be designed.  \nSequence length: Each genetic sequence must consist of exactly 8 bases.  \nWord list: A predefined set of valid nucleotide combinations, provided as a list of sequences in the input file, ensures biological feasibility.  \nNucleotide encoding: 0 represents A, 1 represents T, 2 represents C, and 3 represents G.  \n\n3. Constraints  \nValidity constraint: Each genetic sequence must be selected from the predefined word list of valid nucleotide combinations.  \nGC content constraint: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%, implying that each sequence must contain exactly 4 occurrences of the bases 2 (C) and 3 (G) combined.  \nInter-sequence Hamming distance constraint: The Hamming distance between any pair of distinct genetic sequences must be at least 4, ensuring sufficient diversity between sequences.  \nReverse complement Hamming distance constraint: The Hamming distance between any genetic sequence and its reverse complement must be at least 4, preventing self-base pairing and secondary structure formation. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base as follows: 0 (A)  1 (T), 2 (C)  3 (G).  \nDinucleotide repetition constraint: No base sequence of length 2 (dinucleotide) may appear more than once across all positions in all sequences, eliminating repeated dinucleotide motifs.  \n\n4. Objective Function  \nNo explicit objective function is required, as the goal is to construct a feasible set of 6 genetic sequences that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0 = A, 1 = T, 2 = C, and 3 = G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables indicating whether each predefined word (valid DNA sequence) from the input word list is selected to be part of the solution.  \nPosition variables for each sequence: Integer variables representing the nucleotide at each position (0=A, 1=T, 2=C, 3=G) for each of the six DNA sequences to be designed.  \n\n2. Parameters and Input Data  \nPredefined word list: A set of valid DNA sequences provided in the input file, each consisting of 8 nucleotide positions.  \nNumber of sequences to design: Six DNA sequences are required in the solution.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nMinimum Hamming distance between sequences: The Hamming distance between any two distinct DNA sequences must be at least 4.  \nMinimum Hamming distance from reverse complement: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nPattern repetition constraint: Dinucleotides (base sequences of length 2) cannot appear more than once across all positions in all sequences.  \n\n3. Constraints  \nSequence selection constraint: Each designed DNA sequence must be selected from the predefined word list, ensuring biological feasibility.  \nGC content constraint: The number of guanine (G) and cytosine (C) bases in each sequence must constitute exactly 50% of the total sequence length (4 out of 8 bases).  \nHamming distance constraint between sequences: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nHamming distance constraint from reverse complement: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and folding structure formation.  \nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) is prohibited from appearing more than once across all positions in all sequences, eliminating repeated motifs.  \n\n4. Objective Function  \nDesign a set of six DNA sequences that simultaneously satisfies all biochemical and structural constraints without optimization of secondary objectives.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list. Each line represents a valid DNA sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[2, 3, 0, 1, 2, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSelection variables for DNA sequences: Binary variables indicating whether each predefined DNA sequence from the word list is selected as part of the designed set.  \nSequence representation variables: Integer variables representing the nucleotide composition (0=A, 1=T, 2=C, 3=G) of each base position in the 6 designed DNA sequences, each of length 8.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 DNA sequences.  \nLength of each sequence: 8 bases.  \nValid nucleotide combinations: A predefined list of DNA sequences from the input file, each consisting of 8 nucleotides.  \nGC content requirement: Each DNA sequence must have exactly 50% of its bases as guanine (G) or cytosine (C).  \nMinimum Hamming distance: A minimum Hamming distance of 4 is required between any two designed DNA sequences.  \nReverse complement constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in all designed sequences.  \n\n3. Constraints  \nSelection constraints: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraints: For each selected sequence, the number of guanine (G) and cytosine (C) bases combined must be exactly 4 out of 8.  \nHamming distance constraints: The Hamming distance between any two different selected DNA sequences must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement constraints: The Hamming distance between any selected DNA sequence and its reverse complement must be at least 4, avoiding self-hybridization.  \nDinucleotide repetition constraints: Any dinucleotide (a pair of consecutive bases) must not appear more than once across all positions in all selected sequences, preventing repeated motifs.  \n\n4. Objective Function  \nThere is no explicit optimization objective; the goal is to find a feasible set of 6 DNA sequences that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list, formatted as follows:  \nEach line represents a DNA sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[1, 0, 3, 2, 1, 0, 3, 2]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Represent the nucleotide composition of each genetic sequence, where each sequence consists of 8 positions, and each position can take one of four values (0=A, 1=T, 2=C, 3=G).  \nPairwise Hamming distance variables: Represent the number of differing positions between any two genetic sequences.  \nReverse complement Hamming distance variables: Represent the number of differing positions between each genetic sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nNumber of sequences: The total number of genetic sequences to be designed, fixed at 6.  \nSequence length: Each genetic sequence must consist of exactly 8 nucleotide positions.  \nValid nucleotide combinations: A predefined list of valid genetic sequences, read from the input file, ensuring biological feasibility.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance thresholds: Minimum Hamming distance of 4 between any two genetic sequences and between each sequence and its reverse complement.  \nDinucleotide repetition limit: Any base sequence of length 2 (dinucleotide) is prohibited from appearing more than once across all positions in all sequences.  \n\n3. Constraints  \nGC content constraint: Each genetic sequence must have exactly 4 guanine (G) and cytosine (C) bases to ensure a GC content of 50%.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct genetic sequences must be at least 4 to ensure sufficient sequence diversity and avoid cross-base pairing.  \nReverse complement Hamming distance constraint: The Hamming distance between each genetic sequence and its reverse complement must be at least 4 to prevent self-base pairing and secondary structure formation.  \nDinucleotide repetition constraint: No dinucleotide (sequence of two consecutive bases) may appear more than once across all positions in all sequences to eliminate repeated motifs that could cause unintended molecular interactions.  \n\n4. Objective Function  \nMaximize the diversity of the designed genetic sequences while satisfying all biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" follows this format:  \nEach line represents a valid genetic sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Define 6 DNA sequences, each composed of 8 positions. Each position in a sequence can take one of four nucleotide values (0=A, 1=T, 2=C, 3=G).  \nReverse complement variables: For each DNA sequence, define its reverse complement sequence, where each position is derived by reversing the order and complementing the nucleotide (01, 23).  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 DNA sequences to be designed.  \nSequence length: Each sequence consists of exactly 8 nucleotide positions.  \nValid word list: A predefined set of valid nucleotide combinations, provided as input in the file \"word.txt\", ensuring biological feasibility.  \nGC content requirement: The GC content of each sequence must be exactly 50%, meaning the number of guanine (G) and cytosine (C) bases must equal half the sequence length (4 out of 8 positions).  \n\n3. Constraints  \nGC content constraint: Each sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, ensuring thermodynamic stability.  \nHamming distance constraint between sequences: The Hamming distance between any pair of distinct DNA sequences must be at least 4, ensuring sufficient diversity and preventing cross-hybridization.  \nHamming distance constraint with reverse complement: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and unintended folding structures.  \nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in all sequences, eliminating repeated motifs that could cause unintended molecular interactions.  \n\n4. Objective Function  \nMaximize the number of valid DNA sequences that satisfy all constraints, aiming to construct a complete set of 6 sequences.  \n\n5. Data Specification  \nThe input file \"word.txt\" is located in the \"data\" subdirectory and contains the valid nucleotide combinations. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 DNA sequences, each represented as an ordered sequence of 8 integer variables, where each variable takes a value from the set {0, 1, 2, 3} corresponding to the nucleotide bases A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 DNA sequences are to be designed.  \nSequence length: Each DNA sequence consists of exactly 8 nucleotide bases.  \nValid nucleotide combinations: A predefined list of valid DNA sequences, read from the input file, specifies feasible combinations of nucleotide bases.  \nGC content target: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50% (i.e., 4 out of 8 bases must be G or C).  \nMinimum Hamming distance: The Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement distance: The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nDinucleotide repetition constraint: Any dinucleotide (sequence of two consecutive bases) is prohibited from appearing more than once across all positions in all sequences.  \n\n3. Constraints  \nSequence validity constraint: Each DNA sequence must be selected from the predefined list of valid nucleotide combinations.  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) or cytosine (C) bases, ensuring a GC content of 50%.  \nInter-sequence Hamming distance constraint: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sufficient sequence diversity and discrimination.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, avoiding self-hybridization and secondary structure formation.  \nDinucleotide repetition constraint: Any dinucleotide (pair of consecutive bases) must not appear more than once across all positions in all sequences, eliminating repeated motifs.  \n\n4. Objective Function  \nNone. The problem is satisfaction-based and focuses on finding any feasible solution that meets all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0 corresponds to A, 1 to T, 2 to C, and 3 to G. For example, a line in the file may look like \"[0,1,2,3,0,1,2,3]\".",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nGenetic sequence variables: Represent the set of 6 genetic sequences to be designed, where each sequence consists of exactly 8 bases. Each base in a sequence is an integer variable with a domain of {0, 1, 2, 3}, corresponding to the nucleotide bases A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \n- Number of sequences: 6 genetic sequences must be designed.  \n- Sequence length: Each genetic sequence is exactly 8 bases long.  \n- Valid nucleotide combinations: A predefined word list containing valid 8-base sequences is provided in the input file.  \n- GC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \n- Minimum Hamming distance: The Hamming distance between any two distinct sequences must be at least 4.  \n- Reverse complement Hamming distance: The Hamming distance between any sequence and its reverse complement must be at least 4.  \n- Forbidden motif: The subsequence ACTG must not appear in any of the designed sequences.  \n\n3. Constraints  \nGC content constraint: Each sequence must have exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint between sequences: For any two distinct sequences, the number of differing positions (Hamming distance) must be at least 4.  \nHamming distance constraint for reverse complements: For each sequence, the Hamming distance between the sequence and its reverse complement must be at least 4. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base according to the mapping AT and CG.  \nForbidden motif constraint: The subsequence ACTG must not appear in any of the designed sequences, ensuring that none of the sequences contains this specific 4-base pattern.  \nValid sequence constraint: Each designed sequence must belong to the predefined word list of valid nucleotide combinations provided in the input data.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 genetic sequences that simultaneously satisfy all the biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line in the file represents a valid sequence as a comma-separated list of integers enclosed in brackets, where 0 represents A, 1 represents T, 2 represents C, and 3 represents G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[2, 2, 3, 3, 0, 0, 1, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base in a sequence is selected from the alphabet {A, T, C, G}, encoded as integers {0, 1, 2, 3}.  \n\n2. Parameters and Input Data  \nPredefined word list: A static list of valid 8-base DNA sequences, provided in the input file, representing biologically feasible nucleotide combinations. Each sequence in the list is encoded as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.  \nGC content requirement: The GC content of each DNA sequence must be exactly 50%, meaning each sequence must contain exactly 4 guanine (G) or cytosine (C) bases.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nForbidden motif: The subsequence ACTG (encoded as [0, 2, 3, 1]) is not allowed to appear in any DNA sequence.  \nNumber of sequences: Exactly 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G, encoded as 3) or cytosine (C, encoded as 2) bases to ensure a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct DNA sequences in the set must be at least 4. The Hamming distance is defined as the number of differing positions between two sequences of the same length.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base with its complement (A  T, C  G, encoded as 0  1, 2  3).  \nForbidden motif constraint: None of the DNA sequences may contain the subsequence ACTG (encoded as [0, 2, 3, 1]) at any position.  \n\n4. Objective Function  \nNo explicit optimization objective is specified. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a single sequence as a comma-separated list of integers enclosed in brackets, where 0 represents A, 1 represents T, 2 represents C, and 3 represents G. For example, a line in the file might appear as: [0, 3, 2, 1, 0, 2, 3, 1].",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables indicating whether each predefined DNA sequence from the input word list is included in the solution set.  \nSequence composition variables: For each selected DNA sequence, variables representing the nucleotide at each of the 8 positions (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 DNA sequences must be selected.  \nSequence length: Each DNA sequence must be exactly 8 nucleotides long.  \nPredefined word list: A set of valid DNA sequences provided as input, each of length 8 nucleotides, ensuring biological feasibility.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%. For sequences of length 8, this requires exactly 4 G or C bases per sequence.  \nHamming distance threshold: The Hamming distance between any two selected DNA sequences must be at least 4.  \nReverse complement distance threshold: The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nForbidden motif: The subsequence \"ACTG\" is not allowed to appear in any DNA sequence.  \n\n3. Constraints  \nSequence selection constraint: Exactly 6 DNA sequences must be selected from the predefined word list.  \nSequence length constraint: Each selected DNA sequence must consist of exactly 8 nucleotides.  \nGC content constraint: Each DNA sequence must contain exactly 4 occurrences of the nucleotides G (3) and/or C (2), ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two selected DNA sequences must be at least 4. This ensures sufficient diversity and avoids cross-hybridization issues.  \nReverse complement distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4. This prevents self-hybridization and secondary structure formation.  \nForbidden motif constraint: None of the selected DNA sequences may contain the subsequence \"ACTG\".  \n\n4. Objective Function  \nNo optimization objective is specified. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n...",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Represent the set of 6 genetic sequences to be designed, each consisting of 8 nucleotide bases. Each base in a sequence is an integer variable with domain {0, 1, 2, 3}, corresponding to the nucleotides A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 genetic sequences must be designed.  \nSequence length: Each sequence is exactly 8 bases long.  \nValid nucleotide combinations: A predefined word list containing feasible genetic sequences, provided as input data.  \nGC content requirement: Each sequence must have exactly 50% GC content, meaning 4 out of the 8 bases must be either G (3) or C (2).  \nMinimum Hamming distance: The Hamming distance between any pair of distinct sequences must be at least 4.  \nReverse complement constraint: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nForbidden motif: The subsequence ACTG must not appear in any designed sequence.  \n\n3. Constraints  \nGC content constraint: Each sequence must contain exactly 4 instances of the bases G (3) and C (2) combined, ensuring a GC content of 50%.  \nHamming distance constraint between sequences: For any pair of distinct sequences, the number of differing positions must be at least 4, ensuring sufficient diversity between sequences.  \nHamming distance constraint for reverse complements: For each sequence, the Hamming distance between the sequence and its reverse complement must be at least 4, avoiding self-base pairing and secondary structure formation.  \nForbidden motif constraint: The subsequence ACTG must not appear in any position within any sequence, ensuring functional and biochemical compatibility.  \nSequence validity constraint: Each designed sequence must be selected from the predefined word list of valid nucleotide combinations.  \n\n4. Objective Function  \nMaximize the diversity of the designed sequences, quantified as the sum of pairwise Hamming distances between all distinct sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains a list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Six decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base is selected from the set {0=A, 1=T, 2=C, 3=G}.  \n\n2. Parameters and Input Data  \nPredefined word list: A list of valid 8-base DNA sequences provided in the input file, representing biologically feasible nucleotide combinations.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content (i.e., exactly 4 out of the 8 bases must be either G or C).  \nHamming distance threshold: A minimum Hamming distance of 4 is required between any two different DNA sequences and between any DNA sequence and its reverse complement.  \nForbidden motif: The subsequence ACTG (represented as [0, 2, 3, 1]) is prohibited from appearing in any DNA sequence.  \nNumber of sequences: Exactly 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must contain exactly 4 G or C bases, ensuring a GC content of 50%.  \nHamming distance constraints:  \n- Pairwise diversity constraint: The Hamming distance between any two distinct DNA sequences must be at least 4.  \n- Self-hybridization prevention constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nForbidden motif constraint: None of the DNA sequences may contain the subsequence ACTG. This ensures avoidance of specific functional motifs that could interfere with the intended molecular design.  \nSequence selection constraint: Each DNA sequence must be selected from the predefined word list of valid 8-base nucleotide combinations.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 DNA sequences satisfying all constraints. No optimization objective is specified beyond feasibility.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n...",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for sequence selection: For each valid DNA sequence in the predefined word list, a binary decision variable indicating whether the sequence is included in the final set.  \nSequence representation variables: For each selected DNA sequence, variables representing the nucleotide bases at each of the 8 positions (encoded as integers: 0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nNumber of sequences to design: The target is to design exactly 6 DNA sequences.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nWord list: A predefined list of valid DNA sequences, each 8 bases in length, provided in an external file.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two sequences in the set must be at least 4.  \nReverse complement constraint: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nForbidden motif: The subsequence ACTG is not allowed to appear in any designed DNA sequence.  \n\n3. Constraints  \nSequence selection constraints: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraints: For each selected DNA sequence, the number of guanine (G) and cytosine (C) bases must sum to exactly 4 (50% of the sequence length).  \nHamming distance constraints: The Hamming distance between any pair of selected DNA sequences must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement constraints: For each selected DNA sequence, the Hamming distance between the sequence and its reverse complement must be at least 4, preventing self-hybridization.  \nForbidden motif constraint: None of the selected DNA sequences may contain the subsequence ACTG at any position.  \n\n4. Objective Function  \nNo optimization objective is specified; the goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence formatted as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Represent the 6 genetic sequences to be designed, each consisting of exactly 8 bases. Each base in a sequence is selected from the predefined nucleotide set {0=A, 1=T, 2=C, 3=G}.  \nGC content variables: Binary variables indicating whether a base in a sequence is either G (3) or C (2), used to compute the GC content of each sequence.  \nPairwise Hamming distance variables: Integer variables representing the Hamming distance between each pair of sequences.  \nReverse complement Hamming distance variables: Integer variables representing the Hamming distance between each sequence and its reverse complement.  \nBase count variables: Integer variables tracking the total number of each nucleotide type (A, T, C, G) across all sequences.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 genetic sequences are to be designed.  \nSequence length: Each sequence must be exactly 8 bases long.  \nNucleotide set: {0=A, 1=T, 2=C, 3=G}.  \nWord list: A predefined set of valid genetic sequences provided as input, ensuring biological feasibility.  \nGC content requirement: The proportion of G and C bases in each sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two sequences must be at least 4.  \nMinimum reverse complement Hamming distance: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nTerminal base requirement: The last base of each sequence must be either C (2) or G (3).  \nBase count balance: The difference in the total number of any two nucleotide types (A, T, C, G) across all sequences must not exceed 2.  \n\n3. Constraints  \nSequence validity constraints: Each sequence must be selected from the predefined word list of valid genetic sequences.  \nGC content constraints: The GC content of each sequence must be exactly 50%, meaning that half of the 8 bases in each sequence must be either G (3) or C (2).  \nPairwise Hamming distance constraints: The Hamming distance between any two distinct sequences must be at least 4.  \nReverse complement Hamming distance constraints: The Hamming distance between each sequence and its reverse complement must be at least 4. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base with its complement (AT, CG).  \nTerminal base constraints: The last base of each sequence must be either C (2) or G (3).  \nBase count balance constraints: Across all 6 sequences, the difference in the total number of any two nucleotide types (A, T, C, G) must not exceed 2.  \n\n4. Objective Function  \nNo explicit optimization objective is provided. The goal is to construct a set of 6 genetic sequences that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains a list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. Each sequence in the file is guaranteed to be exactly 8 bases long.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Binary variables representing the selection of DNA sequences from the predefined word list, where each variable corresponds to one sequence in the design set.  \nBase composition variables: Integer variables representing the count of each nucleotide type (A, T, C, G) across all selected DNA sequences.  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid DNA sequences stored in the input file \"data/word.txt\". Each sequence is represented as a list of integers corresponding to nucleotide bases (0=A, 1=T, 2=C, 3=G).  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nSet size: The design set must consist of exactly 6 DNA sequences.  \n\n3. Constraints  \nGC content constraint: Each selected DNA sequence must have exactly 50% GC content, meaning the sum of bases C and G in the sequence must equal 4.  \nSequence diversity constraint: The Hamming distance between any two different selected DNA sequences must be at least 4, ensuring sufficient discrimination between sequences.  \nReverse complement constraint: The Hamming distance between each selected DNA sequence and its reverse complement must be at least 4 to prevent self-hybridization and unintended folding.  \nTerminal base constraint: The last base of each selected DNA sequence must be either C (2) or G (3) to ensure enhanced binding stability.  \nBase composition equilibrium constraint: Across all selected DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2, ensuring overall compositional balance.  \n\n4. Objective Function  \nMaximize sequence feasibility: Ensure the design set satisfies all biochemical and structural constraints while maintaining diversity and stability.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains valid DNA sequences, each represented as a comma-separated list of integers enclosed in brackets. Each line corresponds to one sequence, where 0=A, 1=T, 2=C, and 3=G. Example format:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[0, 0, 1, 1, 2, 2, 3, 3]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: A set of 6 decision variables, each representing a DNA sequence of exactly 8 bases in length, where each base is selected from the predefined word list of valid nucleotide combinations. Each base is encoded as an integer (0=A, 1=T, 2=C, 3=G).  \nBase composition variables: Auxiliary decision variables representing the total counts of each base type (A, T, C, G) across all DNA sequences.  \n\n2. Parameters and Input Data  \nPredefined word list: A static list of valid DNA sequences provided in the input file. Each sequence is represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.  \nSequence length: Each DNA sequence must consist of exactly 8 bases.  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \n\n3. Constraints  \nGC content constraint: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%, ensuring thermodynamic stability.  \nHamming distance constraints: The Hamming distance between any two different DNA sequences must be at least 4, ensuring sufficient diversity and avoiding cross-hybridization.  \nReverse complement constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4 to prevent self-hybridization and secondary structure formation.  \nTerminal base constraint: The last base of each DNA sequence must be either cytosine (C) or guanine (G) to enhance terminal binding stability.  \nBase composition equilibrium constraint: Across all 6 DNA sequences, the difference in the total counts of any two types of bases (A, T, C, G) must not exceed 2, ensuring compositional balance.  \n\n4. Objective Function  \nMaximize sequence diversity by ensuring the Hamming distances between all pairs of DNA sequences are as large as possible, subject to the constraints.  \n\n5. Data Specification  \nThe input file \"word.txt\" located in the \"data\" subdirectory contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nGenetic sequence variables: A set of 6 decision variables, each representing a genetic sequence of exactly 8 bases in length. Each base in a sequence is an integer variable taking a value from the set {0, 1, 2, 3}, corresponding to the nucleotides A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nPredefined word list: A static list of valid genetic sequences, each of length 8, provided in the input file. These sequences are biologically feasible and define allowable nucleotide combinations.  \nGC content requirement: Each sequence must have exactly 4 guanine (G) or cytosine (C) bases, ensuring 50% GC content.  \nHamming distance threshold: The minimum Hamming distance between any two distinct sequences is 4. The Hamming distance between a sequence and its reverse complement must also be at least 4.  \nTerminal base requirement: The last base of each sequence must be either cytosine (C) or guanine (G).  \nDinucleotide repetition restriction: No dinucleotide (base pair of length 2) may appear more than once across all positions of the sequence set.  \n\n3. Constraints  \nSequence validity constraint: Each genetic sequence must be selected from the predefined word list of biologically feasible sequences.  \nGC content constraint: Each sequence must contain exactly 4 guanine (G) or cytosine (C) bases to maintain a GC content of 50%.  \nHamming distance constraints:  \n- The pairwise Hamming distance between any two distinct sequences must be at least 4.  \n- The Hamming distance between each sequence and its reverse complement must be at least 4.  \nTerminal base constraint: The last base of each sequence must be either cytosine (C) or guanine (G).  \nDinucleotide repetition constraint: No dinucleotide (sequence of two consecutive bases) may appear more than once across all positions in the set of sequences. This applies globally across all sequences to prevent repeated motifs.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 genetic sequences, each of length 8, that satisfies all the given biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[2, 3, 0, 1, 2, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nBinary variables for sequence selection: Each DNA sequence is represented by a binary variable indicating whether a particular sequence from the predefined word list is selected.\nSequence composition variables: For each selected sequence, variables representing the nucleotide at each position to ensure compliance with the GC content and terminal nucleotide constraints.\nHamming distance variables: Variables representing the Hamming distance between pairs of sequences and between each sequence and its reverse complement.\n\n2. Parameters and Input Data\nNumber of sequences to design: The goal is to design 6 DNA sequences.\nSequence length: Each DNA sequence must be precisely 8 bases long.\nValid nucleotide combinations: A predefined word list containing valid DNA sequences, read from \"word.txt\".\nNucleotide encoding: 0 represents A, 1 represents T, 2 represents C, and 3 represents G.\n\n3. Constraints\nGC content constraint: Each sequence must have exactly 50% of its bases as G or C, ensuring 4 out of 8 bases are either G or C.\nHamming distance constraint between sequences: The Hamming distance between any two distinct sequences must be at least 4 to ensure sufficient diversity.\nHamming distance constraint with reverse complement: The Hamming distance between any sequence and its reverse complement must be at least 4 to prevent self-hybridization.\nTerminal nucleotide constraint: Each sequence must end with either C or G to ensure enhanced terminal binding stability.\nDinucleotide repetition constraint: No dinucleotide (sequence of 2 bases) can appear more than once across all positions in any sequence to avoid repeated motifs.\n\n4. Objective Function\nMaximize the diversity of selected sequences, implicitly ensuring all constraints are satisfied while achieving the desired set of sequences.\n\n5. Data Specification\nThe input file \"word.txt\" is located in the data subdirectory and contains a list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for sequence selection: For each valid DNA sequence in the predefined word list, a binary variable indicates whether the sequence is included in the final design.  \nSequence composition variables: For each of the 6 DNA sequences to be designed, variables represent the nucleotide at each of the 8 positions, using integer values (0=A, 1=T, 2=C, 3=G).  \nPairwise Hamming distance variables: Integer variables represent the Hamming distance between every pair of DNA sequences in the final design.  \nReverse complement Hamming distance variables: Integer variables represent the Hamming distance between each DNA sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 DNA sequences.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nValid word list: A predefined list of valid DNA sequences, each 8 bases in length, provided in the input file.  \nGC content requirement: The GC content of each DNA sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two distinct DNA sequences must be at least 4.  \nMinimum reverse complement Hamming distance: The Hamming distance between each DNA sequence and its reverse complement must be at least 4.  \nTerminal base requirement: The last base of each DNA sequence must be either C (2) or G (3).  \nDinucleotide repetition limit: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in all DNA sequences.  \n\n3. Constraints  \nSequence selection constraints: Each of the 6 DNA sequences to be designed must be selected from the predefined word list.  \nGC content constraints: For each DNA sequence, the number of guanine (G) and cytosine (C) bases must sum to exactly 4 out of 8 total positions, ensuring a GC content of 50%.  \nPairwise Hamming distance constraints: The Hamming distance between any two distinct DNA sequences in the final design must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement Hamming distance constraints: The Hamming distance between each DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal base constraints: The last base of each DNA sequence must be either C (2) or G (3), providing enhanced terminal binding stability.  \nDinucleotide repetition constraints: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in all DNA sequences, eliminating repeated dinucleotide motifs.  \n\n4. Objective Function  \nNo explicit optimization objective; the goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables representing whether each valid genetic sequence from the predefined word list is included in the final set of designed sequences.  \nSequence composition variables: Integer decision variables for each base in each selected genetic sequence, representing the nucleotide at that position (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nNumber of sequences to design: A fixed number of 6 genetic sequences.  \nSequence length: Each genetic sequence must consist of exactly 8 nucleotide bases.  \nPredefined word list: A list of valid genetic sequences provided in the input file \"word.txt\", where each sequence is represented as a comma-separated list of integers (0=A, 1=T, 2=C, 3=G).  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two distinct sequences in the designed set must be at least 4.  \nReverse complement constraint: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nTerminal base constraint: The last base of each sequence must be either C (2) or G (3).  \nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in all designed sequences.  \n\n3. Constraints  \nSequence inclusion constraint: Exactly 6 sequences must be selected from the predefined word list to form the final set of designed sequences.  \nGC content constraint: For each selected sequence, the total count of guanine (G) and cytosine (C) bases must equal exactly 4, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct sequences in the selected set must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement distance constraint: The Hamming distance between any sequence and its reverse complement must be at least 4 to avoid self-base pairing.  \nTerminal base constraint: The last base of each sequence must be either C (2) or G (3) to ensure terminal binding stability.  \nDinucleotide repetition constraint: Any dinucleotide (a pair of consecutive bases) must not appear more than once across all positions in all selected sequences, preventing repeated motifs.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 genetic sequences that satisfies all biochemical and structural constraints. No additional optimization criterion is specified; the focus is on feasibility.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. Example format:  \n[0,3,2,1,1,2,3,0]  \n[3,0,1,2,2,1,0,3]  \n[2,2,3,3,0,1,1,2]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Each DNA sequence is represented as an ordered list of 8 positions, where each position can take one of four values corresponding to nucleotide bases (0=A, 1=T, 2=C, 3=G).  \nPairwise Hamming distance variables: Integer variables representing the Hamming distance between pairs of DNA sequences in the solution set.  \nReverse complement Hamming distance variables: Integer variables representing the Hamming distance between each DNA sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nSequence length: Each DNA sequence must contain exactly 8 nucleotide bases.  \nNumber of sequences: A total of 6 DNA sequences must be designed in the solution set.  \nWord list: A predefined list of valid DNA sequences, stored in the input file \"word.txt\", containing biologically feasible nucleotide combinations.  \nBase encoding: Nucleotides are encoded as integers (0=A, 1=T, 2=C, 3=G).  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have exactly 50% GC content, meaning the number of guanine (G) and cytosine (C) bases in the sequence must be exactly 4.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct DNA sequences in the solution set must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement Hamming distance constraint: The Hamming distance between each DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and folding structure formation.  \nTerminal base constraint: The last base in each DNA sequence must be either cytosine (C, encoded as 2) or guanine (G, encoded as 3), ensuring enhanced terminal binding stability.  \nDinucleotide repetition constraint: No base sequence of length 2 (dinucleotide motif) may appear more than once across all positions within a DNA sequence, eliminating repeated motifs that could cause unintended recognition patterns.  \n\n4. Objective Function  \nMaximize the biological feasibility and diversity of the DNA sequences while satisfying all constraints.  \n\n5. Data Specification  \nThe input file \"word.txt\" is located in the data subdirectory and contains the word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 DNA sequences, each represented as an ordered list of 8 base variables. Each base variable can take one of four integer values: 0 (A), 1 (T), 2 (C), or 3 (G).  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence is exactly 8 bases long.  \nValid words: A predefined list of valid DNA sequences, where each sequence is represented as a comma-separated list of integers (0=A, 1=T, 2=C, 3=G). This list ensures biological feasibility and is provided as input in the file \"word.txt\".  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have exactly 50% GC content, meaning that exactly 4 out of the 8 bases in each sequence must be either guanine (G) or cytosine (C).  \nHamming distance constraint between sequences: The Hamming distance between any two different DNA sequences must be at least 4. The Hamming distance is defined as the number of positions at which the corresponding bases of two sequences differ.  \nHamming distance constraint with reverse complement: The Hamming distance between any DNA sequence and its reverse complement must be at least 4. The reverse complement of a DNA sequence is obtained by reversing the sequence and replacing each base as follows: A (0)  T (1), C (2)  G (3).  \nTerminal base constraint: The last base of each DNA sequence must be either cytosine (C) or guanine (G).  \nDinucleotide repetition constraint: No dinucleotide (a sequence of two consecutive bases) may appear more than once across all positions of all 6 DNA sequences. For example, if the dinucleotide \"AT\" (represented as [0, 1]) appears at one position in one sequence, it cannot appear anywhere else in any of the sequences.  \n\n4. Objective Function  \nNo explicit optimization objective is specified. The goal is to find any feasible set of 6 DNA sequences that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets. The integers correspond to the nucleotide bases as follows: 0=A, 1=T, 2=C, 3=G. For example, a line in the file may look like: [0, 1, 2, 3, 3, 2, 1, 0].",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables indicating whether each sequence from the predefined word list is included in the final set of designed genetic sequences.  \nSequence composition variables: For each selected sequence, variables representing the nucleotide at each position (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid genetic sequences, where each sequence is represented as a string of 8 nucleotide bases.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two distinct sequences in the final set is 4.  \nReverse complement distance threshold: The minimum Hamming distance between any sequence and its reverse complement is 4.  \nTerminal nucleotide requirement: Each sequence must end with either C (2) or G (3).  \nForbidden subsequence: The subsequence ACTG (represented as [0, 1, 2, 3]) is not allowed in any sequence.  \nNumber of sequences: The final set must contain exactly 6 genetic sequences, each of length 8.  \n\n3. Constraints  \nSequence selection constraint: Exactly 6 sequences must be selected from the predefined word list.  \nGC content constraint: Each selected sequence must have exactly 4 guanine (G) or cytosine (C) bases, ensuring a GC content of 50%.  \nPairwise Hamming distance constraint: The Hamming distance between any two distinct sequences in the final set must be at least 4.  \nReverse complement distance constraint: The Hamming distance between any sequence and its reverse complement must be at least 4. The reverse complement is obtained by reversing the sequence and substituting each base with its complement (AT, CG).  \nTerminal base constraint: The last nucleotide of each sequence must be either C (2) or G (3).  \nForbidden subsequence constraint: No sequence may contain the subsequence ACTG ([0, 1, 2, 3]) at any position.  \n\n4. Objective Function  \nThe objective is to design a set of 6 genetic sequences that satisfies all constraints. There is no optimization criterion beyond feasibility in this problem.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where:  \n- 0 represents A  \n- 1 represents T  \n- 2 represents C  \n- 3 represents G",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSelected DNA sequences: A set of 6 decision variables, each representing one DNA sequence to be designed. Each sequence is an ordered list of 8 nucleotide bases, where each base is encoded as an integer (0 = A, 1 = T, 2 = C, 3 = G).  \n\n2. Parameters and Input Data  \nPredefined word list: A list of valid DNA sequences, each 8 bases long, provided as input data. Each sequence in the list satisfies basic biological feasibility criteria and is encoded as a comma-separated list of integers.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%, corresponding to exactly 4 G or C bases in an 8-base sequence.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement constraint: The minimum Hamming distance between any DNA sequence and its reverse complement must also be at least 4.  \nTerminal base constraint: The final base of each DNA sequence must be either cytosine (C) or guanine (G).  \nForbidden subsequence: The subsequence ACTG is not allowed to appear in any DNA sequence.  \n\n3. Constraints  \nSequence selection constraint: Each of the 6 DNA sequences must be selected from the predefined word list of valid sequences.  \nGC content constraint: Each DNA sequence must have exactly 4 bases that are either guanine (G) or cytosine (C), ensuring a GC content of 50%.  \nHamming distance constraints:  \n- The Hamming distance between any two distinct DNA sequences in the set must be at least 4.  \n- The Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal base constraint: The last base of each DNA sequence must be either cytosine (C) or guanine (G).  \nForbidden subsequence constraint: None of the DNA sequences may contain the specific subsequence ACTG.  \n\n4. Objective Function  \nThe objective is to construct exactly 6 DNA sequences, each 8 bases long, that simultaneously satisfy all constraints. No optimization beyond feasibility is required.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents one DNA sequence, encoded as a comma-separated list of integers (0 = A, 1 = T, 2 = C, 3 = G) enclosed in brackets. For example:  \n[0,1,2,3,0,1,2,3]  \n[3,2,1,0,3,2,1,0]  \n...",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: A set of 6 decision variables, each representing one DNA sequence of exactly 8 bases in length. Each base in the sequence is selected from the alphabet {A, T, C, G}, encoded as integers {0, 1, 2, 3}.  \nBinary variables for subsequence presence: For each DNA sequence, binary variables indicating whether the subsequence ACTG is present at any position.  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid DNA sequences, each of length 8, provided as input. Each sequence is represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.  \nNumber of sequences: The total number of DNA sequences to be designed, set to 6.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nGC content requirement: The GC content of each DNA sequence must be exactly 50%, meaning each sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences is 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement is 4.  \nTerminal base requirement: The last base of each DNA sequence must be either C (2) or G (3).  \nForbidden subsequence: The subsequence ACTG, encoded as {0, 1, 2, 3}, must not appear in any DNA sequence.  \n\n3. Constraints  \nSequence validity constraints: Each DNA sequence must be selected from the predefined word list of valid DNA sequences.  \nGC content constraints: Each DNA sequence must contain exactly 4 occurrences of guanine (G) and cytosine (C) bases combined.  \nHamming distance constraints: The Hamming distance between any two distinct DNA sequences must be at least 4. The Hamming distance is defined as the number of positions at which the corresponding bases of two sequences differ.  \nReverse complement constraints: The Hamming distance between any DNA sequence and its reverse complement must be at least 4. The reverse complement of a sequence is obtained by reversing the sequence and replacing each base with its complement (AT, CG).  \nTerminal base constraints: The last base of each DNA sequence must be either C (2) or G (3).  \nForbidden subsequence constraints: The subsequence ACTG (encoded as {0, 1, 2, 3}) must not appear as a contiguous subsequence in any DNA sequence.  \n\n4. Objective Function  \nNo explicit optimization objective is defined. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nGenetic sequence variables: Represent the nucleotide composition of each genetic sequence, where each sequence is a vector of length 8 with elements drawn from the set {0, 1, 2, 3}, corresponding to {A, T, C, G}.  \nSequence set variables: Represent the collection of 6 distinct genetic sequences to be constructed, ensuring all biochemical and structural constraints are satisfied.  \n\n2. Parameters and Input Data  \nSequence length: Each genetic sequence is exactly 8 bases long.  \nNumber of sequences: A total of 6 genetic sequences must be designed.  \nNucleotide encoding: 0 = A, 1 = T, 2 = C, 3 = G.  \nValid word list: A predefined list of nucleotide combinations representing biologically feasible sequences, loaded from the input file \"word.txt\".  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two distinct genetic sequences is 4.  \nReverse complement distance threshold: The minimum Hamming distance between any genetic sequence and its reverse complement is 4.  \nTerminal nucleotide requirement: The last base of each sequence must be either C (2) or G (3).  \nForbidden subsequence: The tetranucleotide subsequence ACTG is prohibited in all designed sequences.  \n\n3. Constraints  \nGC content constraint: Each genetic sequence must have exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nSequence diversity constraint: The Hamming distance between any two distinct genetic sequences must be at least 4, ensuring sufficient discrimination between sequences.  \nReverse complement constraint: The Hamming distance between each genetic sequence and its reverse complement must be at least 4, preventing self-base pairing and secondary structure formation.  \nTerminal nucleotide constraint: The last base of each genetic sequence must be either C (2) or G (3), providing enhanced terminal binding stability.  \nForbidden subsequence constraint: None of the designed genetic sequences may contain the subsequence ACTG, ensuring exclusion of this specific tetranucleotide motif.  \nWord list constraint: All designed genetic sequences must be selected from the predefined word list of biologically feasible nucleotide combinations.  \n\n4. Objective Function  \nMaximize sequence diversity, defined as the sum of pairwise Hamming distances between all distinct genetic sequences in the set.  \n\n5. Data Specification  \nThe input file \"word.txt\" is located in the data subdirectory and contains the list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where each integer corresponds to a nucleotide (0 = A, 1 = T, 2 = C, 3 = G).",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables indicating whether each DNA sequence from the predefined word list is included in the final solution set.  \nSequence composition variables: Integer variables representing the nucleotide composition of each selected DNA sequence, where each position is assigned a value from {0, 1, 2, 3}, corresponding to A, T, C, and G, respectively.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: A fixed number of 6 DNA sequences must be constructed.  \nSequence length: Each DNA sequence must be exactly 8 nucleotides in length.  \nValid word list: A predefined list of feasible DNA sequences, provided in the input file, where each sequence is represented as a list of integers corresponding to nucleotide bases (0=A, 1=T, 2=C, 3=G).  \nGC content requirement: The GC content of each DNA sequence must be exactly 50%, meaning each sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined.  \nHamming distance threshold: The minimum Hamming distance between any two selected DNA sequences must be at least 4.  \nSelf-complementarity threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal nucleotide constraint: The last nucleotide of each DNA sequence must be either C (2) or G (3).  \nForbidden subsequence: DNA sequences must not contain the subsequence ACTG (0, 1, 2, 3) at any position.  \n\n3. Constraints  \nSequence inclusion constraint: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraint: Each selected DNA sequence must have exactly 4 occurrences of guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two selected DNA sequences must be at least 4, ensuring sufficient diversity between sequences.  \nSelf-complementarity constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and unintended folding structures.  \nTerminal nucleotide constraint: The last nucleotide of each DNA sequence must be either C (2) or G (3), ensuring enhanced terminal binding stability.  \nForbidden subsequence constraint: DNA sequences must not contain the subsequence ACTG (0, 1, 2, 3) at any position, avoiding specific functionally significant motifs.  \n\n4. Objective Function  \nThere is no explicit optimization objective in this problem. The goal is to construct a feasible set of 6 DNA sequences that satisfies all the constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" follows this format:  \nEach line contains a valid DNA sequence represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 3, 2, 2, 1, 0, 1, 0]  \n[2, 2, 3, 0, 1, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables indicating whether each DNA sequence from the predefined word list is selected (1 if selected, 0 otherwise).  \nSequence composition variables: Integer decision variables representing the nucleotide composition of each selected DNA sequence, where 0 corresponds to A, 1 to T, 2 to C, and 3 to G.  \n\n2. Parameters and Input Data  \nPredefined word list: A finite set of valid DNA sequences, each represented as an ordered list of integers corresponding to nucleotide bases (0=A, 1=T, 2=C, 3=G).  \nSequence length: All DNA sequences must be exactly 8 bases long.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nSet size: The design objective is to construct a set of 6 DNA sequences.  \n\n3. Constraints  \nGC content constraint: Each selected DNA sequence must have exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint between sequences: The Hamming distance between any two distinct selected DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nHamming distance constraint with reverse complement: The Hamming distance between any selected DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal base constraint: The last nucleotide of each selected DNA sequence must be either cytosine (C) or guanine (G), enhancing terminal binding stability.  \nSubsequence exclusion constraint: None of the selected DNA sequences may contain the subsequence ACTG, avoiding this specific tetranucleotide motif.  \nSelection constraint: Exactly 6 DNA sequences must be selected from the predefined word list.  \n\n4. Objective Function  \nMaximize the feasibility of the DNA sequence set, ensuring all biochemical and structural constraints are satisfied while selecting the required number of sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line represents a DNA sequence as a comma-separated list of integers enclosed in brackets, where 0 corresponds to A, 1 to T, 2 to C, and 3 to G. For example:  \n[0, 1, 2, 3, 3, 2, 1, 0]  \n[2, 3, 3, 0, 1, 2, 0, 3]  \n[3, 2, 1, 0, 2, 3, 0, 1]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nGenetic sequence variables: For each of the 6 genetic sequences to be designed, define a sequence variable of length 8, where each position represents a nucleotide chosen from the set {0=A, 1=T, 2=C, 3=G}.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 genetic sequences are to be designed.  \nSequence length: Each sequence must be exactly 8 bases in length.  \nNucleotide set: The nucleotide set consists of {0=A, 1=T, 2=C, 3=G}.  \nValid sequences: A predefined list of valid genetic sequences is provided in the input file, ensuring biological feasibility.  \nGC content requirement: The GC content (proportion of guanine and cytosine bases) for each sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two distinct genetic sequences must be at least 4.  \nReverse complement constraint: The Hamming distance between any genetic sequence and its reverse complement must be at least 4.  \nBase compositional balance: Across all 6 sequences, the total count of each nucleotide type must not differ by more than 2 from the count of any other nucleotide type.  \nDinucleotide repetition restriction: Any base sequence of length 2 (dinucleotide) must not appear more than once within any single sequence.  \n\n3. Constraints  \nGC content constraint: Each sequence must have exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two different sequences must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement constraint: The Hamming distance between a sequence and its reverse complement must be at least 4, preventing self-base pairing or secondary structure formation.  \nBase compositional balance constraint: Across all 6 sequences, the difference in the total count of any two nucleotide types (A, T, C, G) must not exceed 2, maintaining overall compositional equilibrium.  \nDinucleotide repetition constraint: Within each sequence, no dinucleotide (any consecutive pair of bases) may appear more than once, eliminating repeated motifs.  \n\n4. Objective Function  \nNo explicit optimization objective is defined. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Define 6 DNA sequences, each consisting of exactly 8 bases. Each base in a sequence is represented as an integer variable taking values from the set {0, 1, 2, 3}, where 0 corresponds to adenine (A), 1 to thymine (T), 2 to cytosine (C), and 3 to guanine (G).  \n\n2. Parameters and Input Data  \nWord list: A predefined set of valid DNA sequences, read from the input file \"word.txt\". Each sequence in the word list is represented as a comma-separated list of integers enclosed in brackets.  \nSequence length: Each DNA sequence must consist of exactly 8 bases.  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \n\n3. Constraints  \nGC content constraint: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%. This ensures thermodynamic stability during molecular interactions.  \nHamming distance constraint between sequences: The Hamming distance between any two distinct DNA sequences must be at least 4. This guarantees sufficient diversity and avoids cross-hybridization issues.  \nHamming distance constraint with reverse complement: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and unintended folding structures.  \nBase composition constraint: Across all 6 DNA sequences, the difference in the total count of any two base types (A, T, C, G) must not exceed 2, ensuring compositional equilibrium.  \nDinucleotide uniqueness constraint: Any base sequence of length 2 (dinucleotide) is prohibited from appearing more than once within a single DNA sequence, eliminating repeated motifs that could cause unintended recognition patterns.  \n\n4. Objective Function  \nMaximize the feasibility of the design by constructing 6 DNA sequences that simultaneously satisfy all constraints.  \n\n5. Data Specification  \nThe input file \"word.txt\" located in the data subdirectory contains the word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0 corresponds to adenine (A), 1 to thymine (T), 2 to cytosine (C), and 3 to guanine (G).",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: A set of 6 DNA sequences, each represented as an ordered list of 8 integers, where each integer corresponds to one of the four nucleotides (0=A, 1=T, 2=C, 3=G).  \nReverse complement variables: For each DNA sequence, its reverse complement is derived by reversing the sequence order and substituting each nucleotide with its complement (01, 23).  \n\n2. Parameters and Input Data  \nNumber of sequences: A total of 6 DNA sequences to be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases in length.  \nValid nucleotide combinations: A predefined word list of feasible DNA sequences, provided in the input file \"word.txt\". Each sequence is represented as a comma-separated list of integers enclosed in brackets.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content, meaning 4 out of the 8 bases must be either guanine (G) or cytosine (C).  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have exactly 4 guanine (G) and cytosine (C) bases combined, ensuring 50% GC content for thermodynamic stability.  \nHamming distance constraints:  \n- Between any two distinct DNA sequences, the Hamming distance must be at least 4, ensuring sufficient sequence diversity and preventing cross-hybridization.  \n- Between any DNA sequence and its reverse complement, the Hamming distance must also be at least 4, avoiding self-hybridization and secondary structure formation.  \nCompositional equilibrium constraint: Across all 6 DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2, ensuring balanced nucleotide composition.  \nDinucleotide repetition constraint: No dinucleotide (sequence of 2 consecutive bases) may appear more than once in any single DNA sequence, eliminating repeated motifs that could cause unintended recognition patterns.  \n\n4. Objective Function  \nMaximize the diversity of the designed DNA sequences while satisfying all biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"word.txt\" located in the \"data\" subdirectory contains a list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence selection variables: Binary decision variables representing whether each predefined genetic sequence from the word list is selected as part of the solution set.  \nBase assignment variables: Integer variables representing the nucleotide (0=A, 1=T, 2=C, 3=G) assigned to each position of each genetic sequence.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 genetic sequences.  \nSequence length: Each sequence must be exactly 8 bases long.  \nPredefined word list: A set of valid genetic sequences, read from the input file, containing nucleotide combinations that meet biological feasibility criteria.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases must be exactly 50% for each sequence.  \nHamming distance threshold: Minimum distance of 4 between any two selected sequences and between each sequence and its reverse complement.  \nBase type equilibrium: Across all selected sequences, the difference in the total count of any two nucleotide types must not exceed 2.  \nDinucleotide repetition limit: Any base sequence of length 2 (dinucleotide) must not appear more than once in any selected genetic sequence.  \n\n3. Constraints  \nSequence validity constraint: Each selected genetic sequence must belong to the predefined word list.  \nGC content constraint: The GC content of each genetic sequence must be exactly 50%, ensuring thermodynamic stability.  \nHamming distance constraint: The Hamming distance between any two selected genetic sequences must be at least 4, ensuring sufficient sequence diversity.  \nReverse complement constraint: The Hamming distance between each genetic sequence and its reverse complement must be at least 4, preventing self-pairing and secondary structure formation.  \nBase type equilibrium constraint: Across all selected genetic sequences, the difference in the total count of any two nucleotide types (A, T, C, G) must not exceed 2, maintaining compositional balance.  \nDinucleotide repetition constraint: No dinucleotide motif (sequence of two consecutive bases) may appear more than once within any selected genetic sequence, eliminating repeated recognition patterns.  \n\n4. Objective Function  \nMaximize sequence diversity by ensuring the selected genetic sequences meet all constraints while achieving the required biochemical and structural properties.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n[0, 3, 2, 2, 1, 0, 3, 1]  \n[3, 2, 0, 1, 3, 2, 0, 1]  \n...",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Binary decision variables representing the selection of DNA sequences from the predefined word list. Each sequence is composed of 8 bases, and the decision variables determine which sequences are included in the final solution set.  \nBase composition variables: Integer variables representing the count of each base (A, T, C, G) across all selected DNA sequences.  \nDinucleotide occurrence variables: Integer variables tracking the frequency of each possible dinucleotide (e.g., AA, AT, etc.) across all selected DNA sequences.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 DNA sequences must be selected.  \nSequence length: Each DNA sequence is exactly 8 bases long.  \nValid word list: A predefined list of nucleotide sequences, read from an input file, representing biologically feasible combinations.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content (4 occurrences of G or C bases per sequence).  \nHamming distance threshold: The minimum Hamming distance between any pair of selected DNA sequences must be at least 4.  \nSelf-complementarity distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nBase composition equilibrium: The difference in the total count of any two types of bases (A, T, C, G) across all selected sequences must not exceed 2.  \nDinucleotide repetition limit: Any dinucleotide motif (e.g., AA, AT, etc.) is prohibited from appearing more than once across all selected DNA sequences.  \n\n3. Constraints  \nGC content constraint: Each selected DNA sequence must contain exactly 4 occurrences of guanine (G) and cytosine (C) bases to ensure 50% GC content.  \nHamming distance constraint: The Hamming distance between any two different DNA sequences must be at least 4 to ensure sufficient sequence diversity and avoid cross-hybridization.  \nSelf-complementarity constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4 to prevent self-hybridization and folding structure formation.  \nBase composition equilibrium constraint: Across all selected DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2 to ensure compositional balance.  \nDinucleotide repetition constraint: Any dinucleotide motif (e.g., AA, AT, etc.) is prohibited from appearing more than once across all selected DNA sequences to eliminate repeated recognition patterns.  \n\n4. Objective Function  \nMaximize sequence diversity by ensuring compliance with all biochemical and structural constraints while selecting the 6 DNA sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the valid DNA sequences in the following format:  \n- Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.  \n- Example line: [0, 1, 2, 3, 0, 1, 2, 3]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: A set of 6 decision variables, each representing one DNA sequence of exactly 8 bases in length. Each base in a sequence is represented as an integer (0=A, 1=T, 2=C, 3=G), and the sequence must be selected from a predefined word list of valid nucleotide combinations provided in the input data.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 DNA sequences are to be designed.  \nSequence length: Each DNA sequence must consist of exactly 8 bases.  \nAlphabet: The alphabet consists of four nucleotides (0=A, 1=T, 2=C, 3=G).  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nPredefined word list: A list of valid DNA sequences, each 8 bases in length, provided in the input data file.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nBase balance constraint: Across all 6 DNA sequences, the difference in the total number of any two types of bases (A, T, C, G) must not exceed 2.  \nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) is prohibited from appearing more than once in any DNA sequence.  \n\n3. Constraints  \nGC content constraints: Each DNA sequence must have exactly 4 guanine (G) and cytosine (C) bases combined, ensuring a GC content of 50% for thermodynamic stability.  \nHamming distance constraints: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement Hamming distance constraints: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nBase balance constraints: Across all 6 DNA sequences, the total count of any nucleotide (A, T, C, G) must be balanced such that the difference in counts between any two nucleotides does not exceed 2, ensuring overall compositional equilibrium.  \nDinucleotide repetition constraints: No dinucleotide (e.g., AA, AT, CG) may appear more than once within any DNA sequence, eliminating repeated motifs that could cause unintended recognition patterns.  \nSelection constraints: Each DNA sequence must be selected from the predefined word list provided in the input data file, ensuring biological feasibility.  \n\n4. Objective Function  \nThe objective is to construct a set of 6 DNA sequences that satisfy all the given constraints. There is no explicit optimization criterion beyond satisfying the constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence formatted as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. For example:  \n```\n[0,1,2,3,0,1,2,3]  \n[3,2,1,0,3,2,1,0]  \n```",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Represent the set of 6 genetic sequences to be designed, where each sequence is composed of exactly 8 bases. Each base in a sequence is selected from the set {0, 1, 2, 3}, corresponding to nucleotides A, T, C, and G, respectively.  \nGC content variables: Binary variables for each base in each sequence, indicating whether the base is either G (3) or C (2).  \nHamming distance variables: Integer variables representing the pairwise Hamming distances between all distinct pairs of sequences and between each sequence and its reverse complement.  \n\n2. Parameters and Input Data  \nWord list: A predefined list of valid genetic sequences, each of length 8, provided in the input file \"data/word.txt\". Each sequence is represented as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.  \nNumber of sequences: The total number of genetic sequences to be designed, fixed at 6.  \nSequence length: The fixed length of each genetic sequence, set to 8 bases.  \nBase set: The set of valid bases, {0, 1, 2, 3}, corresponding to nucleotides A, T, C, and G.  \nGC content target: The GC content for each sequence must be exactly 50%, meaning 4 out of 8 bases in each sequence must be either G (3) or C (2).  \nMinimum Hamming distance: The minimum required Hamming distance between any two distinct sequences and between any sequence and its reverse complement, set to 4.  \nBase composition difference: Across all designed sequences, the difference in the total counts of any two types of bases (A, T, C, G) must not exceed 2.  \nForbidden subsequence: The subsequence ACTG (0, 2, 3, 1) is not allowed to appear in any designed sequence.  \n\n3. Constraints  \nSequence validity constraints: Each designed sequence must be selected from the predefined word list of valid genetic sequences.  \nGC content constraints: Each sequence must contain exactly 4 bases that are either G (3) or C (2), ensuring a GC content of 50%.  \nPairwise Hamming distance constraints: The Hamming distance between any two distinct sequences must be at least 4, ensuring sufficient diversity.  \nReverse complement Hamming distance constraints: The Hamming distance between any sequence and its reverse complement must be at least 4, preventing self-base pairing and secondary structure formation.  \nBase composition balance constraints: Across all 6 designed sequences, the difference in the total counts of any two types of bases (A, T, C, G) must not exceed 2, ensuring compositional equilibrium.  \nForbidden subsequence constraints: None of the designed sequences may contain the subsequence ACTG (0, 2, 3, 1) at any position.  \n\n4. Objective Function  \nThere is no explicit optimization objective in this problem. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid genetic sequences. Each line in the file represents a single sequence as a comma-separated list of integers enclosed in brackets. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[1, 0, 3, 2, 1, 0, 3, 2]  \n...",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nSequence variables: Binary decision variables representing the inclusion of specific DNA sequences from the predefined word list. Each variable corresponds to one candidate sequence.  \nBase assignment variables: For each position in each selected DNA sequence, integer variables representing the nucleotide base (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nNumber of sequences: A total of 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nWord list: A predefined list of valid DNA sequences, each represented as a sequence of integers corresponding to nucleotide bases.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nBase composition balance: Across all designed DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2.  \nSubsequence exclusion: The subsequence ACTG must not appear in any designed DNA sequence.  \n\n3. Constraints  \nSequence selection constraints: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraints: For each DNA sequence, the total number of guanine (G) and cytosine (C) bases must equal half the sequence length (4 bases for an 8-base sequence).  \nHamming distance constraints: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient sequence diversity and avoiding cross-hybridization.  \nReverse complement constraints: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and folding structure formation.  \nBase composition constraints: Across all selected DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2, ensuring compositional equilibrium.  \nSubsequence exclusion constraints: None of the selected DNA sequences may contain the subsequence ACTG, avoiding specific functional motifs.  \n\n4. Objective Function  \nMaximize the diversity of the selected DNA sequences, measured as the sum of pairwise Hamming distances between all selected sequences.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list. Each line represents a valid DNA sequence formatted as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Represent the nucleotide composition of each DNA sequence, where each sequence is a fixed-length array of integers corresponding to nucleotide bases (0=A, 1=T, 2=C, 3=G).  \nSequence selection variables: Binary decision variables indicating whether a specific valid DNA sequence from the predefined word list is selected as part of the solution.  \n\n2. Parameters and Input Data  \nNumber of DNA sequences: The total number of DNA sequences to be designed, fixed at 6.  \nSequence length: Each DNA sequence must consist of exactly 8 nucleotide bases.  \nValid nucleotide combinations: A predefined word list containing all biologically feasible DNA sequences, provided as input data.  \nGC content requirement: Each DNA sequence must have exactly 50% guanine (G) and cytosine (C) bases, ensuring thermodynamic stability.  \nHamming distance threshold: The minimum required Hamming distance between any two distinct DNA sequences is 4.  \nReverse complement constraint: The minimum required Hamming distance between any DNA sequence and its reverse complement is 4.  \nBase composition equilibrium: Across all selected DNA sequences, the difference in the total count of any two types of bases (A, T, C, G) must not exceed 2.  \nSubsequence exclusion: The subsequence ACTG must not appear in any designed DNA sequence.  \n\n3. Constraints  \nSequence selection constraint: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraint: Each DNA sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined, representing 50% of the sequence length.  \nInter-sequence Hamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient diversity and avoiding cross-hybridization.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure interference.  \nBase composition equilibrium constraint: Across all selected DNA sequences, the difference in the total count of any two nucleotide bases (A, T, C, G) must not exceed 2, maintaining compositional balance.  \nSubsequence exclusion constraint: None of the selected DNA sequences may contain the subsequence ACTG, ensuring exclusion of this specific tetranucleotide motif.  \n\n4. Objective Function  \nMaximize the diversity of the selected DNA sequences, defined as the sum of pairwise Hamming distances between all selected sequences and their reverse complements.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" follows this format:  \nEach line represents a valid DNA sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for sequence selection: For each valid genetic sequence in the predefined word list, a binary variable indicates whether the sequence is selected (1) or not (0).  \nSequence composition variables: For each position in each selected genetic sequence, a variable represents the nucleotide base at that position, encoded as integers (0=A, 1=T, 2=C, 3=G).  \n\n2. Parameters and Input Data  \nNumber of sequences to design: 6 genetic sequences are required.  \nSequence length: Each genetic sequence must be exactly 8 bases in length.  \nPredefined word list: A list of valid nucleotide combinations that can be used to construct the sequences. Each word is an 8-base sequence encoded as integers (0=A, 1=T, 2=C, 3=G).  \nGC content threshold: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nHamming distance threshold: The Hamming distance between any two different sequences must be at least 4.  \nReverse complement threshold: The Hamming distance between any sequence and its reverse complement must be at least 4.  \nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in a sequence.  \nForbidden subsequence: None of the sequences may contain the subsequence ACTG.  \n\n3. Constraints  \nSequence selection constraints: Exactly 6 sequences must be selected from the predefined word list.  \nSequence length constraints: Each selected sequence must consist of exactly 8 bases.  \nGC content constraints: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%, meaning each sequence must contain exactly 4 guanine (G) and cytosine (C) bases combined.  \nHamming distance constraints: The Hamming distance between any two distinct selected sequences must be at least 4, ensuring sufficient diversity between sequences.  \nReverse complement constraints: The Hamming distance between any selected sequence and its reverse complement must be at least 4, preventing self-base pairing and secondary structure formation.  \nDinucleotide repetition constraints: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in a sequence, avoiding repeated dinucleotide motifs.  \nForbidden subsequence constraints: None of the selected sequences may contain the subsequence ACTG.  \n\n4. Objective Function  \nThe objective is to successfully construct 6 genetic sequences that simultaneously satisfy all the biochemical and structural constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list, formatted as follows:  \nEach line represents a valid genetic sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary decision variables for sequence selection: For each candidate DNA sequence in the predefined word list, a binary variable indicates whether the sequence is included in the final solution set (1 if selected, 0 otherwise).  \nSequence composition variables: For each position in each selected DNA sequence, a variable represents the nucleotide at that position, where 0 = A, 1 = T, 2 = C, and 3 = G.  \n\n2. Parameters and Input Data  \nNumber of sequences to design: A fixed set of 6 DNA sequences must be generated.  \nSequence length: Each DNA sequence must consist of exactly 8 nucleotides.  \nPredefined word list: A list of valid DNA sequences provided in the input file \"word.txt\", where each sequence is encoded as a comma-separated list of integers representing nucleotides.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each DNA sequence must be exactly 50%, meaning 4 out of 8 positions in each sequence must be either G or C.  \nHamming distance requirement: The Hamming distance between any two selected DNA sequences must be at least 4. Additionally, the Hamming distance between any selected DNA sequence and its reverse complement must also be at least 4.  \nDinucleotide repetition restriction: No dinucleotide (any two consecutive nucleotides) may appear more than once across all positions in all selected sequences.  \nForbidden subsequence: None of the selected DNA sequences may contain the subsequence ACTG.  \n\n3. Constraints  \nSequence selection constraints: Exactly 6 DNA sequences must be selected from the predefined word list.  \nGC content constraints: Each selected DNA sequence must have exactly 4 guanine (G) or cytosine (C) bases, ensuring a GC content of 50%.  \nHamming distance constraints: The Hamming distance between any two selected DNA sequences must be at least 4. This ensures sufficient diversity between sequences to avoid cross-hybridization.  \nReverse complement constraints: The Hamming distance between any selected DNA sequence and its reverse complement must be at least 4. This prevents self-hybridization and folding structures.  \nDinucleotide repetition constraints: No dinucleotide (a pair of consecutive nucleotides) may appear more than once across all positions in all selected sequences.  \nForbidden subsequence constraints: None of the selected DNA sequences may contain the subsequence ACTG at any position.  \n\n4. Objective Function  \nNo optimization objective is required for this problem. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" follows this format:  \nEach line represents a valid DNA sequence as a comma-separated list of integers enclosed in brackets, where 0 = A, 1 = T, 2 = C, and 3 = G. For example:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[0, 0, 1, 1, 2, 2, 3, 3]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 sequences, each consisting of 8 positions, where each position can take one of four values representing the nucleotides A, T, C, and G. These are represented as integers: 0 (A), 1 (T), 2 (C), and 3 (G).  \n\n2. Parameters and Input Data  \nLength of each sequence: 8 bases.  \nNumber of sequences to design: 6.  \nValid nucleotide combinations: A predefined word list containing biologically feasible DNA sequences. Each sequence in the word list is represented as a vector of 8 integers, where each integer corresponds to a nucleotide (0=A, 1=T, 2=C, 3=G).  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nMinimum Hamming distance: The Hamming distance between any two sequences and between any sequence and its reverse complement must be at least 4.  \nProhibited dinucleotide motifs: Any base sequence of length 2 (dinucleotide) must not appear more than once across all positions in any sequence.  \nProhibited tetranucleotide motif: The subsequence ACTG must not appear in any sequence.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have exactly 4 guanine (G) or cytosine (C) bases out of 8 positions, ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any pair of distinct DNA sequences must be at least 4, ensuring sufficient diversity. Additionally, the Hamming distance between any DNA sequence and its reverse complement must also be at least 4 to prevent self-hybridization. The reverse complement of a sequence is obtained by reversing the sequence and replacing each nucleotide with its complement (AT, CG).  \nDinucleotide repetition constraint: Any dinucleotide (sequence of 2 consecutive bases) must not occur more than once within any DNA sequence, eliminating repeated motifs.  \nProhibited subsequence constraint: The specific tetranucleotide sequence ACTG must not appear in any position within any DNA sequence.  \n\n4. Objective Function  \nThere is no explicit optimization objective for this problem. The goal is to find a feasible set of 6 DNA sequences that satisfies all the constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets. For example:  \n[0,1,2,3,0,1,2,3]  \n[3,2,1,0,3,2,1,0]  \nEach sequence in the file corresponds to an 8-base DNA sequence, where 0=A, 1=T, 2=C, and 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]\nreverse_map = list(range(8))[::-1]\n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]\n        y_rev = [words[j][reverse_map[k]] for k in range(8)]\n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nforbidden_pattern = [0, 2, 1, 3]\npattern_len = len(forbidden_pattern)\nfor i in range(n_words):\n    for j in range(8 - pattern_len + 1):\n        window_vars = [words[i][k] for k in range(j, j + pattern_len)]\n        model.add(model.sum(window_vars[k] != forbidden_pattern[k] for k in range(pattern_len)) >= 1)\n\nsolution = model.solve(TimeLimit=100, Workers=4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))\n        print(f\"{i + 1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nSequence variables: Each sequence variable represents a genetic sequence composed of 8 bases, chosen from the valid nucleotide combinations.\nBase assignment: Each position in the sequence is assigned one of the four nucleotide bases (A, T, C, G) based on the predefined word list.\n\n2. Parameters and Input Data\nNumber of sequences: A total of 6 genetic sequences need to be designed.\nSequence length: Each genetic sequence is precisely 8 bases long.\nValid nucleotide combinations: A predefined word list containing valid sequences, ensuring biological feasibility.\nBase encoding: Integer encoding for nucleotide bases where 0=A, 1=T, 2=C, 3=G.\n\n3. Constraints\nGC content constraint: Each sequence must have exactly 50% GC content, ensuring optimal thermodynamic stability.\nMinimum Hamming distance between sequences: The Hamming distance between any two different sequences must be at least 4, ensuring sequence diversity.\nMinimum Hamming distance from reverse complement: The Hamming distance between a sequence and its reverse complement must be at least 4, preventing self-base pairing.\nTerminal base constraint: The end base of each sequence must be either C or G, enhancing terminal binding stability.\nBase compositional equilibrium constraint: Across all sequences, the difference in the total number of any two types of bases shall not exceed 2, ensuring compositional balance.\nDinucleotide repetition constraint: No dinucleotide sequence (length 2) may appear more than once in any sequence, eliminating repeated motifs.\n\n4. Objective Function\nDesign a set of 6 genetic sequences that simultaneously satisfies all biochemical and structural constraints.\n\n5. Data Specification\nThe input file \"data/word.txt\" contains a list of valid genetic sequences. Each line represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: A set of 6 decision variables, each representing a DNA sequence of exactly 8 bases in length. Each base in a sequence is represented as an integer, where 0=A, 1=T, 2=C, and 3=G.  \nBase assignment variables: For each position in each DNA sequence, a variable determines the nucleotide (0, 1, 2, or 3) assigned to that position.  \n\n2. Parameters and Input Data  \nNumber of sequences: 6 DNA sequences must be designed.  \nSequence length: Each DNA sequence must be exactly 8 bases long.  \nValid word list: A predefined list of valid DNA sequences, provided in the input file, contains nucleotide combinations that meet biological feasibility requirements.  \nGC content requirement: Each DNA sequence must have exactly 50% GC content, meaning exactly 4 of the 8 bases in each sequence must be either G or C.  \nHamming distance threshold: The minimum Hamming distance between any two distinct DNA sequences must be at least 4.  \nReverse complement Hamming distance threshold: The minimum Hamming distance between any DNA sequence and its reverse complement must be at least 4.  \nTerminal base requirement: The final base of each DNA sequence must be either C (2) or G (3).  \nBase composition balance: Across all 6 DNA sequences, the total number of bases of any two types (A, T, C, or G) must differ by no more than 2.  \nDinucleotide repetition prohibition: Any sequence of two consecutive bases (dinucleotide) must not appear more than once across any single DNA sequence.  \n\n3. Constraints  \nGC content constraint: Each DNA sequence must have exactly 4 bases that are G (3) or C (2), ensuring a GC content of 50%.  \nHamming distance constraint: The Hamming distance between any two distinct DNA sequences must be at least 4, ensuring sufficient diversity between sequences.  \nReverse complement Hamming distance constraint: The Hamming distance between any DNA sequence and its reverse complement must be at least 4, preventing self-hybridization and secondary structure formation.  \nTerminal base constraint: The last base of each DNA sequence must be either C (2) or G (3), ensuring enhanced terminal stability.  \nBase composition balance constraint: Across all 6 DNA sequences, the total count of any two types of bases (A, T, C, or G) must differ by no more than 2, maintaining compositional equilibrium.  \nDinucleotide repetition constraint: Any dinucleotide (e.g., AA, AT, CG, etc.) must not appear more than once within a single DNA sequence, eliminating repeated motifs that could cause unintended recognition patterns.  \nWord list constraint: Each DNA sequence must be selected from the predefined list of valid DNA sequences provided in the input file, ensuring biological feasibility.  \n\n4. Objective Function  \nNo explicit optimization objective is specified. The goal is to find any feasible solution that satisfies all constraints.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, and 3=G. For example:  \n`[0,3,2,1,0,3,2,2]`  \nEach sequence in the file is 8 bases long and adheres to biological feasibility requirements.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nDNA sequence variables: Define 6 DNA sequences, each of length 8, where each position in a sequence can take one of four values (0=A, 1=T, 2=C, 3=G). Each sequence is represented as a vector of 8 integer decision variables.  \nGC content variables: Binary variables for each position in each sequence, indicating whether the nucleotide at that position is guanine (G) or cytosine (C).  \nReverse complement variables: For each DNA sequence, define its reverse complement as a corresponding sequence of 8 integer decision variables derived from the reverse order of the sequence with complementary bases (AT, CG).  \n\n2. Parameters and Input Data  \nPredefined word list: A finite set of valid DNA sequences, each of length 8, represented as vectors of integers (0=A, 1=T, 2=C, 3=G). This list ensures all generated sequences are biologically feasible.  \nNumber of sequences: 6 DNA sequences must be designed.  \nSequence length: Each sequence is exactly 8 bases long.  \nHamming distance threshold: A minimum Hamming distance of 4 is required between any two distinct sequences and between any sequence and its reverse complement.  \nGC content requirement: The proportion of guanine (G) and cytosine (C) bases in each sequence must be exactly 50%.  \nTerminal base requirement: The final base in each sequence must be either cytosine (C) or guanine (G).  \nBase type balance threshold: Across all sequences, the total number of any two base types (A, T, C, G) must differ by at most 2.  \nDinucleotide repetition limit: No dinucleotide (pair of consecutive bases) may appear more than once across any sequence.  \n\n3. Constraints  \nSequence validity constraints: Each DNA sequence must be selected from the predefined word list of valid DNA sequences.  \nGC content constraints: For each DNA sequence, the number of guanine (G) and cytosine (C) bases must sum to exactly 4, ensuring a GC content of 50%.  \nHamming distance constraints:  \n- The Hamming distance between any two distinct DNA sequences must be at least 4.  \n- The Hamming distance between any DNA sequence and its reverse complement must also be at least 4.  \nTerminal base constraints: The last base of each DNA sequence must be either cytosine (C) or guanine (G).  \nBase type balance constraints: Across all generated DNA sequences, the total count of any two types of bases (A, T, C, G) must differ by at most 2.  \nDinucleotide repetition constraints: No dinucleotide (pair of consecutive bases) may occur more than once within any DNA sequence.  \n\n4. Objective Function  \nThe objective is to construct 6 DNA sequences that simultaneously satisfy all biochemical and structural constraints. No optimization criterion is provided beyond feasibility.  \n\n5. Data Specification  \nThe input file \"data/word.txt\" contains the predefined word list of valid DNA sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G. Example format:  \n[0, 1, 2, 3, 0, 1, 2, 3]  \n[3, 2, 1, 0, 3, 2, 1, 0]  \n[1, 0, 3, 2, 1, 0, 3, 2]",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\ncomplement_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(complement_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables\nSelection variables for genetic sequences: Binary variables indicating whether each sequence from the predefined word list is selected as part of the final set of genetic sequences.\nSequence composition variables: Integer variables representing the count of each nucleotide type (A, T, C, G) in each selected genetic sequence.\nHamming distance variables: Integer variables representing the Hamming distance between any two selected genetic sequences and between each sequence and its reverse complement.\n\n2. Parameters and Input Data\nNumber of sequences: The total number of genetic sequences to be designed, specified as 6.\nSequence length: Each genetic sequence must be precisely 8 bases long.\nPredefined word list: A list of valid nucleotide combinations, read from the input file \"word.txt\", representing biologically feasible sequences.\nNucleotide mapping: Integers 0, 1, 2, 3 correspond to nucleotides A, T, C, and G respectively.\n\n3. Constraints\nGC content constraint: Each genetic sequence must have exactly 50% GC content, ensuring optimal thermodynamic stability.\nHamming distance constraint: The Hamming distance between any two different genetic sequences must be at least 4, ensuring sufficient sequence diversity.\nReverse complement constraint: The Hamming distance between any genetic sequence and its reverse complement must be at least 4, preventing self-base pairing.\nTerminal base constraint: The last base of each genetic sequence must be either C or G, enhancing terminal binding stability.\nBase count equilibrium constraint: Across all generated genetic sequences, the difference in the total number of any two types of bases shall not exceed 2, maintaining compositional equilibrium.\nDinucleotide repetition constraint: Any base sequence of length 2 (dinucleotide) is prohibited from appearing more than once in each genetic sequence, avoiding repeated motifs.\n\n4. Objective Function\nDesign a set of 6 genetic sequences that satisfies all biochemical and structural constraints, ensuring feasible and diverse genetic sequence composition.\n\n5. Data Specification\nThe input file \"word.txt\" located in the data subdirectory contains a list of valid genetic sequences. Each line in the file represents a sequence as a comma-separated list of integers enclosed in brackets, where 0=A, 1=T, 2=C, 3=G.",
    "input": "",
    "output": "from docplex.cp.model import CpoModel\n\nwith open(\"data/word.txt\", \"r\") as file:\n    word_list = [list(map(int, line.strip()[1:-1].split(\",\"))) for line in file]\n\npair_map = [1, 0, 3, 2]  \nreverse_map = list(range(8))[::-1] \n\nmodel = CpoModel()\n\nn_words = 6\n\nwords = [[model.integer_var(0, 3, f\"w_{i}_{j}\") for j in range(8)] for i in range(n_words)]\n\nfor i in range(n_words):\n    model.add(model.allowed_assignments([words[i][j] for j in range(8)], word_list))\n\nfor i in range(n_words):\n    model.add(model.count([words[i][j] for j in range(8)], 2) + model.count([words[i][j] for j in range(8)], 3) == 4)\n\nfor i in range(n_words):\n    for j in range(i + 1, n_words):\n        model.add(model.sum(words[i][k] != words[j][k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    for j in range(n_words):\n        x_comp = [model.element(pair_map, words[i][k]) for k in range(8)]  \n        y_rev = [words[j][reverse_map[k]] for k in range(8)]  \n        model.add(model.sum(x_comp[k] != y_rev[k] for k in range(8)) >= 4)\n\nfor i in range(n_words):\n    model.add((words[i][0] == 2) | (words[i][0] == 3))\n    model.add((words[i][7] == 2) | (words[i][7] == 3))\n\nall_bases = [words[i][j] for i in range(n_words) for j in range(8)]\nfor base_value in range(4):\n    model.add(model.count(all_bases, base_value) >= n_words * 8 // 4 - 2)\n    model.add(model.count(all_bases, base_value) <= n_words * 8 // 4 + 2)\n\nfor i in range(n_words):\n    for j in range(8 - 3):\n        model.add(model.logical_or(words[i][j] != words[i][j+2], words[i][j+1] != words[i][j+3]))\n\nsolution = model.solve(TimeLimit = 100, Workers = 4)\n\nif solution:\n    print(\"Found solutions:\")\n    for i in range(n_words):\n        dna_seq = \"\".join(\"ATCG\"[solution[words[i][j]]] for j in range(8))  \n        print(f\"{i+1}: {dna_seq}\")\nelse:\n    print(\"No solution found.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total voltage output of the system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series column.  \nNumber of series columns: Total number of series-connected columns in the battery matrix configuration.  \nNumber of time periods: Total number of discrete time intervals for the systems operation.  \nCell nominal voltage: Nominal voltage of each individual battery module.  \nMaximum current per module: Maximum allowable current through each battery module to ensure safety and prevent overheating.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module during each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module during each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage characteristics of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system during each time period must strictly remain within the preset safe range to prevent damage to connected loads.  \nCurrent safety constraint: The current flowing through any activated battery module during each time period must not exceed its maximum allowable threshold to avoid overheating and degradation.  \nParallel consistency constraint: At any given moment, the number of parallel-connected battery modules in all series columns must be strictly consistent to ensure balanced load distribution.  \nActivation-deactivation constraint: A battery module can only contribute to the systems voltage and current if it is activated during the respective time period.  \nCapacity utilization constraint: The energy drawn from each battery module during activation must not exceed its capacity as defined in the capacity matrix for the corresponding time period.  \nInternal resistance constraint: The energy loss due to internal resistance must be calculated based on the resistance matrix and the current flow variables for each activated module.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This includes both losses due to internal resistance during activation and the electrochemical recovery effects during deactivation, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS]. Each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage variables: Continuous variables representing the total output voltage of the system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: The total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: The total number of series-connected branches in the matrix configuration.  \nNumber of time periods: The total number of discrete time periods over which the system operates.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any individual battery module.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module in ampere-hours during each time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module in ohms during each time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system at each time period must remain within a predefined safe range to prevent damage to connected loads. The total output voltage is computed as the sum of the voltages of all series branches, where the voltage of each branch is determined by the voltage of its activated modules.  \n\nCurrent safety constraint: The current flowing through any activated battery module during any time period must not exceed its specified maximum current threshold to prevent overheating and degradation.  \n\nParallel consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be consistent across all branches to ensure balanced load distribution.  \n\nEnergy conservation constraint: The total energy consumed by the activated battery modules in each time period must account for internal resistance losses and electrochemical recovery effects, ensuring that energy is neither created nor destroyed.  \n\nActivation-deactivation constraint: A battery module can only contribute to the system's output voltage and current during a time period if it is activated.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods. This includes internal resistance losses during activation periods and accounts for electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floats representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened 3D matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nVoltage variables for series branches: Continuous variables representing the total output voltage of each series branch during each time period.  \nCurrent variables for battery modules: Continuous variables representing the current flowing through each activated battery module during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series column.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: The total number of discrete time intervals over which the system operation is optimized.  \nCell nominal voltage: The nominal voltage of each battery module, assumed constant across all modules.  \nMaximum current per module: The maximum allowable current for each battery module to prevent overheating and degradation.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the output voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system across all series branches must remain within the preset safe power supply range at all time periods.  \nCurrent safety constraints: The current flowing through any activated battery module must not exceed its maximum allowable threshold during any time period.  \nLoad balancing constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nActivation constraints: Each battery module can either be activated or deactivated during each time period, and its contribution to the system voltage and current depends on its activation state.  \nEnergy flow constraints: The output voltage and current of each series branch must be consistent with the activation states and electrical characteristics of the battery modules in that branch during each time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary variables indicating whether each battery module is activated (1) or deactivated (0) in each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module in each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the battery system in each time period.  \nEnergy loss variables: Continuous variables representing the energy loss for each battery module in each time period due to internal resistance and recovery effects.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods for which the system configuration is optimized.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any single battery module to ensure safe operation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage output constraint: The total output voltage of the battery system in each time period must remain within the predefined safe operating range. This ensures the system can safely supply power to the connected load without damage.  \nCurrent flow constraint: The current flowing through any activated battery module in any time period must not exceed the maximum current per module. This prevents overheating and degradation of the modules.  \nParallel module consistency constraint: At any given moment, the number of parallel-connected battery modules in all series branches must be strictly consistent. This ensures balanced load distribution across the system.  \nEnergy loss calculation constraint: The energy loss for each battery module in each time period is determined by both the internal resistance losses during activation and the recovery effects during deactivation.  \nActivation-deactivation consistency constraint: A battery module can only have current flow and contribute to the system's voltage output if it is activated in the corresponding time period.  \nCapacity constraint: The total capacity of each battery module in each time period must be sufficient to support the current flow and voltage output required by the system.  \n\n4. Objective Function  \nMinimize the total net energy loss across all battery modules and time periods. This includes internal resistance losses during activation and recovery effects during deactivation, aiming to maximize the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers and floats representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row. Each matrix entry is a floating-point number.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the entire battery pack system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series branches in the battery pack system.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: The nominal voltage of a single battery module.  \nMaximum current per module: The maximum allowable current flow through any individual battery module to ensure safe operation.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the capacity of a specific battery module during a specific time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific battery module during a specific time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage of a specific battery module during a specific time period.  \n\n3. Constraints  \nVoltage output constraints: The total output voltage of the battery pack system at any time period must remain within the safe power supply range defined by the system. The output voltage is calculated as the sum of the nominal voltages of all activated modules in each series column.  \nCurrent flow constraints: The current flowing through any activated battery module at any time period must not exceed the maximum allowable current per module.  \nParallel module consistency constraints: At any given time period, the number of activated modules in all parallel connections across all series branches must be strictly equal to ensure balanced load distribution.  \nActivation-deactivation constraints: If a module is deactivated during a time period, it cannot carry any current or contribute to the total output voltage during that period. Conversely, only activated modules can carry current or contribute to the total output voltage.  \nEnergy loss constraints: The energy loss in each activated module is determined by its internal resistance and the square of the current flowing through it, while the recovery effects during deactivation are based on specific electrochemical dynamics. These losses and recoveries are accounted for in the total net energy loss.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated modules over all time periods, which includes losses due to internal resistance during activation and recovery effects during deactivation.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, the number of series columns, the number of time periods, the cell nominal voltage, and the maximum current per module.  \n- Subsequent lines: Three 3D matrices (C, R, and V) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row. Each matrix entry corresponds to a specific battery module's capacity, resistance, or voltage at a given time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables for each module and time period: Binary variables indicating whether a specific battery module is activated (1) or deactivated (0) during a given time period.  \nCurrent flow variables for each module and time period: Continuous variables representing the current flowing through each activated battery module during a given time period.  \nVoltage variables for each series column and time period: Continuous variables representing the total output voltage of each series column during a given time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series column.  \nNumber of series columns: Total number of series-connected columns in the battery pack.  \nNumber of time periods: Total number of discrete time periods for which the system is optimized.  \nCell nominal voltage: Voltage of a single battery module under standard operating conditions.  \nMaximum current per module: Maximum allowable current for each battery module to prevent overheating and degradation.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the capacity (in ampere-hours) of a specific battery module during a specific time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance (in ohms) of a specific battery module during a specific time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage (in volts) of a specific battery module during a specific time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system, computed as the sum of voltages across all series columns, must remain within the predefined safe power supply range during each time period.  \nCurrent safety constraints: The current flowing through any activated battery module must not exceed the maximum allowable current during any time period.  \nParallel module balance constraints: At any given time period, the number of activated battery modules in all series columns must be equal to ensure balanced load distribution across the system.  \nActivation-deactivation constraints: A battery module can only carry current if it is activated during the corresponding time period.  \nEnergy conservation constraints: The energy loss in each module during activation periods must account for internal resistance losses, and energy recovery effects during deactivation periods must be modeled based on the provided capacity and resistance matrices.  \n\n4. Objective Function  \nMinimize the total net energy loss of the system over all time periods. This includes minimizing internal resistance losses during activation periods and maximizing electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, the number of series columns, the number of time periods, the cell nominal voltage, and the maximum current per module.  \n- Subsequent lines: Three 3D matrices (C for capacity, R for resistance, and V for voltage) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], with each matrix flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables for each battery module in the matrix configuration, indicating whether a module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the system for each time period.  \nUsage count variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: The total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: The total number of series-connected branches in the matrix configuration.  \nNumber of time periods: The total number of time periods for which the system configuration must be optimized.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum permissible current that can flow through any battery module.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the capacity of each battery module (in ampere-hours) for each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance (in ohms) of each battery module for each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the voltage of each battery module (in volts) for each time period.  \n\n3. Constraints  \nVoltage output range constraint: The total output voltage of the system across all series columns and parallel modules during any time period must remain within a predefined safe range.  \nMaximum current constraint: The current flowing through any activated battery module during any time period must not exceed the module's maximum permissible current.  \nParallel module consistency constraint: At any given time period, the number of activated parallel-connected battery modules must be identical across all series branches to ensure balanced load distribution.  \nWear-leveling constraint: The total number of activations for any two battery modules across all time periods must differ by no more than 2, promoting uniform degradation and extending system lifespan.  \nEnergy balance constraint: The current flowing through each activated battery module must be consistent with the system's electrical requirements, accounting for internal resistance and voltage characteristics.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the energy storage system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floats representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row, representing capacity, resistance, and voltage values for each battery module at each time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated or deactivated during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total count of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time intervals over which the battery system operates.  \nCell nominal voltage: Voltage rating of each battery module under standard operating conditions.  \nMaximum current per module: Maximum allowable current flow through each battery module to prevent overheating and degradation.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the energy storage capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the output voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery system across all series columns must strictly remain within the preset safe power supply range during each time period.  \nCurrent safety constraints: The current flowing through any activated battery module must not exceed its maximum allowable threshold during any time period.  \nParallel connection consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nWear-leveling constraints: The total number of activations of any two battery modules across all time periods shall differ by no more than 2, ensuring equitable utilization and uniform degradation of all modules.  \nActivation constraints: A battery module can only contribute to the system's output voltage and current if it is activated during the corresponding time period.  \nEnergy balance constraints: The energy output of each module, considering its activation status, must align with the system's requirements for each time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules, which includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five parameters (number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module).  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], listed row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each battery module: Binary decision variables indicating whether a specific battery module is activated (1) or deactivated (0) during a given time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module in each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the system for each time period.  \nWear-leveling counters: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods for scheduling the battery system operations.  \nCell nominal voltage: The nominal voltage of each battery module when activated.  \nMaximum current per module: The maximum allowable current that can flow through any activated battery module to ensure safe operation.  \n\nInput matrices:  \n- Capacity matrix (C): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the capacity of each battery module in each time period.  \n- Resistance matrix (R): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each battery module in each time period.  \n- Voltage matrix (V): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage of each battery module in each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system in each time period must remain strictly within the preset safe power supply range. This ensures connected loads are not damaged due to overvoltage or undervoltage.  \n\nCurrent flow constraints: The current flowing through any activated battery module in each time period must not exceed its maximum safety threshold, preventing overheating and degradation of the module.  \n\nParallel module consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution across the system.  \n\nWear-leveling constraints: The total number of activations of any two battery modules across all time periods must differ by no more than 2, promoting uniform degradation and extending the lifespan of the battery pack system.  \n\nActivation constraints: Each battery module can only be activated or deactivated during a given time period, represented by binary decision variables.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules. This incorporates both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five parameters (number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module).  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether a specific battery module in the matrix configuration is activated during a given time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series column.  \nNumber of series columns: Total number of series-connected columns in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods for which the system configuration is optimized.  \nCell nominal voltage: Voltage rating of each individual battery module.  \nMaximum current per module: Maximum allowable current for each battery module to ensure safe operation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the actual voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system, calculated as the sum of activated module voltages across all series columns, must remain strictly within the safe power supply range defined by the system's specifications.  \nCurrent safety constraints: The current flowing through any activated battery module during any time period must not exceed its maximum allowable threshold to prevent overheating and degradation.  \nParallel connection consistency constraints: At any given time period, the number of parallel-connected battery modules in all series columns must be strictly consistent to ensure balanced load distribution across the system.  \nWear-leveling constraint: The cumulative number of activations across all time periods for any two battery modules must differ by no more than 2, ensuring equitable utilization and uniform degradation of all modules.  \nActivation flow constraints: A battery module can only allow current flow if it is activated during the corresponding time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods. This includes both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether a specific battery module is activated (1) or deactivated (0) during a given time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module in each time period.  \nParallel module count variables: Integer variables representing the number of parallel-connected battery modules in each series column during each time period.  \nWear-leveling variables: Integer variables tracking the cumulative usage count of each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules that can be connected in parallel in each series column.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: Nominal output voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any single battery module without exceeding its safety threshold.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the actual output voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system, calculated as the sum of the voltages of all series-connected branches, must remain within a predefined safe power supply range at all time periods.  \nCurrent safety constraints: The current flowing through any activated battery module must not exceed its maximum allowable current to prevent overheating and degradation.  \nParallel module consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be equal to ensure balanced load distribution across the system.  \nWear-leveling constraints: The total number of activations of any two battery modules across all time periods must differ by no more than 2, ensuring equitable utilization of all modules and promoting uniform battery degradation.  \nContinuity constraints: For each series column and time period, the current flowing through each activated battery module must ensure continuity of current across the parallel and series connections.  \nActivation constraints: A battery module can only contribute to the system's output if it is activated during the corresponding time period.  \nEnergy balance constraints: The energy loss of each battery module, calculated as a function of its internal resistance and current flow, must be accounted for in the total energy loss calculation.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This energy loss includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods. The goal is to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage), each with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) in each time period.  \nParallel connection variables: Integer decision variables specifying the number of parallel-connected modules in each series column for every time period.  \nWear-leveling variables: Integer decision variables representing the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules available for parallel connections in the matrix configuration.  \nNumber of series columns: Total count of series-connected columns in the matrix configuration.  \nNumber of time periods: Total number of discrete time intervals over which the battery system operates.  \nCell nominal voltage: Voltage output of each battery module under nominal conditions.  \nMaximum current per module: Safety threshold for the current that can flow through an activated battery module.  \nCapacity matrix (C): A three-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the capacity of each battery module in each time period.  \nResistance matrix (R): A three-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the internal resistance of each battery module in each time period.  \nVoltage matrix (V): A three-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the voltage output of each battery module in each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack, calculated as the sum of the voltages of all activated modules across all series columns, must strictly remain within the preset safe power supply range for every time period.  \nCurrent safety constraint: The current flowing through any activated battery module must not exceed its maximum safety threshold in any time period, ensuring safe operation and preventing overheating.  \nParallel connection consistency constraint: At any given moment, the number of parallel-connected battery modules in all series columns must be strictly consistent to ensure balanced load distribution across the matrix configuration.  \nWear-leveling constraint: The cumulative number of activations for any two battery modules across all time periods shall differ by no more than 2, promoting equitable utilization and uniform degradation of all modules.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods, which includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods. The objective is to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation state variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module at each time period.  \nSwitch state change variables: Binary variables indicating whether the activation state of a battery module changes between consecutive time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total count of series-connected branches in the battery pack.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: Nominal voltage of each individual battery module.  \nMaximum current per module: Maximum allowable current that can flow through any single battery module.  \nCapacity matrix (C): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each battery module at each time period.  \nResistance matrix (R): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system, determined by the sum of voltages across all series columns, must remain within the predefined safe power supply range at all time periods.  \nCurrent safety constraint: The current flowing through any activated battery module must not exceed its maximum allowable current at any time period.  \nParallel module consistency constraint: At any time period, the number of parallel-connected battery modules in all series branches must be equal to ensure balanced load distribution.  \nSwitching limit constraint: The total number of switch state changes (from activated to deactivated or vice versa) across all battery modules between consecutive time periods must not exceed 6.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods. This includes losses due to internal resistance during activation periods and recovery effects during deactivation periods, aiming to maximize the energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floats representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened 3-dimensional matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation state variables for each battery module: Binary variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitch state change variables: Binary variables representing whether the activation state of a module changes between consecutive time periods.  \nOutput voltage variables: Continuous variables representing the total output voltage of the battery pack at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: The total number of battery modules connected in parallel within each series column.  \nNumber of series columns: The total number of series-connected branches in the matrix configuration.  \nNumber of time periods: The number of discrete time intervals over which the battery system operates.  \nCell nominal voltage: The nominal voltage of each battery module.  \nMaximum current per module: The maximum allowable current through each battery module to ensure safe operation.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack at each time period must remain within the predefined safe range to prevent damage to connected loads.  \nCurrent limit constraints: The current flowing through any activated battery module at any time period must not exceed its maximum allowable threshold to prevent overheating and degradation.  \nParallel consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly equal to ensure balanced load distribution.  \nSwitching constraints: The maximum number of switches allowed to change state between consecutive time periods is limited to 6, ensuring operational stability and minimizing mechanical stress on switching components.  \nActivation constraints: A module can only contribute to the total output voltage and current if it is activated during the corresponding time period.  \nEnergy flow constraints: The energy loss of activated modules, caused by internal resistance and electrochemical effects, must be accounted for based on their activation state and corresponding operational parameters.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods, which includes internal resistance losses during activation and electrochemical recovery effects during deactivation. Maximizing the overall energy efficiency of the battery pack system is the ultimate goal.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitch state variables: Binary decision variables representing the state of each switching component (on or off) at each time period.  \nVoltage and current variables: Continuous variables representing the output voltage and current of each series column and parallel branch at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules arranged in parallel within each series column.  \nNumber of series columns: Total number of series columns in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system configuration is optimized.  \nCell nominal voltage: Voltage provided by each individual battery module when activated.  \nMaximum current per module: The upper limit of current that can safely flow through each activated battery module.  \nCapacity matrix (C): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the capacity of a specific battery module at a given time period.  \nResistance matrix (R): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific battery module at a given time period.  \nVoltage matrix (V): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage characteristics of a specific battery module at a given time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system at any time period must strictly remain within the predefined safe power supply range. This ensures the connected load is neither damaged nor underpowered.  \nCurrent safety constraints: The current flowing through any activated battery module must not exceed its maximum allowable threshold at any time period to prevent overheating and degradation.  \nParallel consistency constraints: At any given moment, the number of parallel-connected battery modules in all series columns must be strictly consistent to ensure balanced load distribution across the system.  \nSwitching constraints: The maximum number of switching components allowed to change state between consecutive time periods is limited to 6, enforcing operational stability and reducing mechanical stress.  \nActivation-deactivation constraints: A battery module can only contribute to the systems voltage and current if it is activated, and its internal resistance and recovery effects are considered based on its activation or deactivation state.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over the entire time horizon. This includes losses due to internal resistance during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened 3D matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables for each battery module, indicating whether the module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery matrix.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any single battery module.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module at each time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery system during each time period must remain within a predefined safe range to prevent damage to connected loads.  \nCurrent limit constraints: The current flowing through any activated battery module during each time period must not exceed the module's maximum allowable current.  \nParallel consistency constraints: At any given time period, the number of activated battery modules in all parallel branches of the system must be equal across all series columns to ensure balanced load distribution.  \nThermal distribution constraints: For any 2x2 submatrix of battery modules within the system, no more than 2 modules can be activated simultaneously during any time period to prevent localized thermal hotspots and ensure efficient heat dissipation.  \nActivation and deactivation constraints: Modules can only be activated or deactivated within the bounds of their operational characteristics as specified in the input matrices (C, R, and V).  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. This includes losses due to internal resistance during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three 3D matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nVoltage output variables: Continuous decision variables representing the total voltage output of the battery system at each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within the system.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: Voltage rating for each individual battery module.  \nMaximum current per module: Maximum allowable current flow through any activated battery module to ensure safe operation.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each battery module during each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each battery module during each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the voltage output of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraints: The total voltage output of the battery system at any time period must lie within the preset safe power supply range to avoid damage to connected loads.  \nCurrent limit constraints: The current flowing through any activated battery module during each time period must not exceed the maximum allowable current per module.  \nParallel module consistency constraint: At any given time period, the number of activated parallel-connected modules in all series branches must be identical to ensure balanced load distribution.  \nSpatial activation constraints: Within any 2x2 module matrix region, no more than two modules can be activated simultaneously during any time period to prevent localized thermal hotspots and ensure efficient thermal management.  \nEnergy flow constraints: The energy drawn from each activated module must account for its internal resistance losses and electrochemical recovery effects during deactivation periods, ensuring accurate representation of net energy loss.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated modules over all time periods, incorporating both internal resistance losses during activation and electrochemical recovery effects during deactivation, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the battery pack during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack configuration.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: Voltage of each individual battery module when activated.  \nMaximum current per module: Maximum allowable current that can flow through an activated battery module.  \nCapacity matrix (C): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module during each time period.  \nResistance matrix (R): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module during each time period.  \nVoltage matrix (V): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the actual voltage of each battery module during each time period.\n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack during each time period must remain within a predefined safe range. This is computed as the sum of the voltages of all activated modules in each series branch.  \nMaximum current constraint: The current flowing through any activated battery module during any time period must not exceed the module's maximum allowable current.  \nParallel consistency constraint: At any given time period, the number of activated modules in parallel across all series branches must be identical to ensure balanced load distribution.  \nSpatial activation constraint: Within any 2x2 submatrix of battery modules (spanning two parallel rows and two series columns), no more than two modules can be activated simultaneously during any time period to prevent localized thermal hotspots.  \nEnergy conservation constraint: The energy consumed by each activated battery module during each time period must not exceed its available capacity as specified in the capacity matrix.  \nThermal management constraint: The system must ensure an even distribution of active modules across the battery pack to enhance thermal management efficiency, adhering to the spatial activation constraints.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation and accounts for electrochemical recovery effects during deactivation, thereby maximizing the overall energy efficiency of the battery pack system.\n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \n- Subsequent lines: Three 3-dimensional matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module in the matrix configuration is activated during each time period.  \nVoltage variables: Continuous variables representing the total output voltage of the system for each time period.  \nCurrent variables: Continuous variables representing the current flowing through each activated battery module for each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules arranged in parallel within each series branch.  \nNumber of series columns: Total count of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods in the scheduling horizon.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any single battery module without exceeding safety thresholds.  \nCapacity matrix (C): A 3-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the capacity of each module during each time period.  \nResistance matrix (R): A 3-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each module during each time period.  \nVoltage matrix (V): A 3-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage of each module during each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system during each time period must remain within a predefined safe range to prevent damage to connected loads.  \n\\[ V_{\\text{min}} \\leq \\sum_{\\text{activated modules}} \\text{voltage contributions} \\leq V_{\\text{max}} \\]  \n\nCurrent safety constraints: The current flowing through any activated battery module during each time period must not exceed its maximum allowable value.  \n\\[ I_{m,t} \\leq I_{\\text{max}}, \\quad \\forall m \\in \\text{activated modules}, \\forall t \\in \\text{time periods} \\]  \n\nParallel consistency constraints: At any given time period, the number of parallel-connected modules in all series branches must be equal to ensure balanced load distribution.  \n\\[ \\sum_{\\text{parallel modules in branch } i} \\text{activation state} = \\sum_{\\text{parallel modules in branch } j} \\text{activation state}, \\quad \\forall i, j \\in \\text{series branches}, \\forall t \\in \\text{time periods} \\]  \n\nSpatial activation constraints: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously during any time period to prevent localized thermal hotspots.  \n\\[ \\sum_{\\text{modules in 2x2 region}} \\text{activation state} \\leq 2, \\quad \\forall 2x2 \\text{ regions}, \\forall t \\in \\text{time periods} \\]  \n\nEnergy balance constraints: The energy loss of each activated module during each time period must account for both internal resistance losses and electrochemical recovery effects.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. The energy loss includes contributions from internal resistance losses during activation and recovery effects during deactivation, thereby maximizing the overall energy efficiency of the energy storage system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three 3-dimensional matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated module at each time period.  \nVoltage output variables: Continuous decision variables for the total output voltage of the battery pack at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack.  \nNumber of time periods: Total number of discrete time periods during which the battery pack operates.  \nCell nominal voltage: Voltage rating of each individual battery module.  \nMaximum current per module: Safety threshold for the maximum allowable current through each battery module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the energy storage capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage output of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack at each time period must remain within the preset safe power supply range, defined as [V_min, V_max].  \nCurrent safety constraints: The current flowing through any activated battery module at any time period must not exceed its maximum safety threshold to prevent overheating and degradation.  \nLoad balancing constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution across the battery pack.  \nThermal management constraints: Within any 2x2 module matrix region, no more than two modules can be activated simultaneously at any time period, ensuring efficient heat distribution and preventing localized thermal hotspots.  \nActivation and deactivation rules: Binary activation variables must ensure modules transition between activated and deactivated states subject to electrochemical recovery effects and operational requirements.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes losses due to internal resistance during activation periods and recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack.  \nNumber of time periods: Total number of discrete time periods for which the scheduling problem is defined.  \nCell nominal voltage: Nominal voltage of each individual battery module.  \nMaximum current per module: Maximum allowable current for each battery module to ensure safe operation.  \nCapacity matrix (C): A three-dimensional matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry specifies the energy capacity of a battery module at a specific time period.  \nResistance matrix (R): A three-dimensional matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry specifies the internal resistance of a battery module at a specific time period.  \nVoltage matrix (V): A three-dimensional matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry specifies the voltage of a battery module at a specific time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack, determined by the sum of voltages across all series columns, must remain within a predefined safe range during each time period.  \nCurrent safety constraint: The current flowing through any activated battery module must not exceed the maximum allowable current during any time period.  \nParallel consistency constraint: At each time period, the number of activated modules in all series branches must be the same, ensuring balanced load distribution across the battery pack.  \nSpatial activation constraint: Within any 2x2 submatrix of battery modules (spanning two parallel modules and two series columns), no more than two modules can be activated simultaneously during any time period to prevent localized thermal hotspots.  \nEnergy conservation constraint: The energy consumed by each activated module during a time period must not exceed its available capacity as defined in the capacity matrix for that period.  \nThermal recovery constraint: Modules that are deactivated for a specified recovery period regain a portion of their capacity, as determined by a predefined electrochemical recovery function.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. The energy loss includes internal resistance losses during activation periods and accounts for electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three three-dimensional matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided in a flattened row-by-row format.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time intervals for the operational schedule.  \nCell nominal voltage: Voltage rating of each individual battery module.  \nMaximum current per module: The maximum allowable current that can flow through any activated battery module.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the capacity of each battery module at each time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the voltage output of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system during each time period must remain strictly within the safe power supply range defined by the nominal voltage of the modules and system design limits.  \nCurrent safety constraints: The current flowing through any activated battery module during any time period must not exceed the modules maximum allowable current to prevent overheating and degradation.  \nParallel module consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution across the system.  \nFault module constraint: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated during any time period.  \nEnergy flow constraints: The current and voltage variables must satisfy the physical laws governing energy flow in the system, including Ohms law and power conservation principles.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over the entire operational schedule. The energy loss includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C, R, and V) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row. Each matrix entry corresponds to the respective parameter (capacity, resistance, or voltage) for a specific module at a specific time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_voltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of parallel battery modules in the system.  \nNumber of series columns: Total number of series-connected columns in the battery matrix.  \nNumber of time periods: Total number of discrete time intervals during which the system operates.  \nCell nominal voltage: Voltage rating of each individual battery module.  \nMaximum current per module: Upper limit on the current flow through any activated battery module to ensure safety.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage output of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system during each time period must strictly remain within a predefined safe range to prevent damage to connected loads.  \nCurrent safety constraint: The current flowing through any activated battery module during each time period must not exceed its maximum safety threshold to avoid overheating and degradation.  \nParallel connection consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nFault condition constraint: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated during any time period.  \nActivation-deactivation transition constraints: Ensure that transitions between activation and deactivation states for each battery module are feasible and account for electrochemical recovery effects.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery losses during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened three-dimensional matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], listed row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_cellVoltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total voltage output of the system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total count of series-connected branches in the matrix configuration.  \nNumber of time periods: Total duration of the operational schedule divided into discrete time periods.  \nCell nominal voltage: Voltage generated by each individual battery module under standard operating conditions.  \nMaximum current per module: Safety threshold for the current flowing through any activated battery module to prevent overheating and degradation.  \nCapacity matrix (C): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the energy capacity of each battery module at each time period.  \nResistance matrix (R): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage characteristics of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system during each time period must strictly remain within the preset safe power supply range to prevent damage to connected loads.  \nCurrent limit constraint: The current flowing through any activated battery module during each time period must not exceed its maximum safety threshold.  \nParallel consistency constraint: At any given moment, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nFault condition constraint: The battery module located at the first row and first column position is permanently malfunctioned and cannot be activated throughout the entire operational period.  \nEnergy balance constraint: The energy consumed during activation periods and recovered during deactivation periods must align with the electrochemical properties defined in the capacity matrix (C).  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods, which encompasses internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five parameters specifying the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_voltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each module: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the battery system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: The total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: The total number of series branches in the matrix configuration.  \nNumber of time periods: The total number of discrete time periods over which the system operates.  \nCell nominal voltage: The nominal voltage of an individual battery cell when activated.  \nMaximum current per module: The maximum allowable current that can flow through an individual battery module without exceeding its safety threshold.  \nCapacity matrix (C): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the energy capacity of a specific battery module during a given time period.  \nResistance matrix (R): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific battery module during a given time period.  \nVoltage matrix (V): A 3D matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage of a specific battery module during a given time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system during each time period must remain within a predefined safe range to prevent damage to connected loads.  \nCurrent safety constraint: The current flowing through each activated battery module during any time period must not exceed its maximum allowable value.  \nParallel connection consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nFault condition constraint: The battery module located at the first row and first column position is permanently non-functional and cannot be activated during any time period.  \nEnergy conservation constraint: The energy loss due to internal resistance during activation periods and electrochemical recovery effects during deactivation periods must be accurately accounted for in the system's energy balance.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods, accounting for both internal resistance losses during activation and electrochemical recovery effects during deactivation, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three 3D matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_voltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each battery module: Binary variables indicating whether a specific battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the battery pack system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack system.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The upper safety limit on the current that can flow through any activated battery module.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the energy storage capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the actual voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack system during each time period must remain strictly within a predefined safe range. This range is determined by the operational requirements of the connected load.  \nCurrent limit constraints: The current flowing through any activated battery module during each time period must not exceed the module's specified maximum current threshold.  \nParallel consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly equal to ensure balanced load distribution across the system.  \nFault exclusion constraint: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated during any time period.  \nEnergy flow constraints: For each activated battery module, the current flow, voltage, and resistance must satisfy Ohm's Law, ensuring consistency between electrical parameters.  \nEnergy conservation constraints: The total energy loss of each activated battery module, including losses due to internal resistance, must be accurately accounted for during each time period.  \nActivation-deactivation constraints: Electrochemical recovery effects must be modeled, ensuring that deactivated modules recover energy efficiency over time, while activated modules incur efficiency losses.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over all time periods. This includes losses due to internal resistance during activation periods and the recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS]. Each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_cellVoltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery pack system during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods in the scheduling horizon.  \nNominal cell voltage: Voltage of each individual battery module when operating under standard conditions.  \nMaximum current per module: Upper limit on the current that can safely flow through any individual battery module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module in ampere-hours during each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module in ohms during each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the actual voltage of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack system during each time period must remain within a predefined safe operating range.  \nCurrent limit constraint: The current flowing through any activated battery module during each time period must not exceed the modules maximum allowable current.  \nParallel balance constraint: At any given time period, the number of activated battery modules in all parallel branches within each series column must be consistent to ensure balanced load distribution.  \nFault exclusion constraint: The battery module located at the first row and first column position is permanently deactivated and cannot be activated during any time period.  \nEnergy conservation constraint: For each activated battery module, the energy consumed during activation must account for internal resistance losses based on the current flow and resistance values.  \nElectrochemical recovery constraint: For each deactivated battery module, the recovery effect must be modeled to reflect the restoration of energy efficiency during idle periods.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules over the scheduling horizon. This includes minimizing the internal resistance losses during activation periods and maximizing the recovery effects during deactivation periods to achieve optimal energy efficiency.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal cell voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row. Each matrix entry corresponds to a specific time period, parallel module, and series column combination.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    total_voltage_contribution = model.sum(V[k,i,j] * s[k,i,j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS))\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nnet_loss_matrix = C + R\ns_vars_flat = [s[key] for key in s_keys]\nnet_loss_flat = [net_loss_matrix[k, i, j] for k, i, j in s_keys]\n\ntotal_net_loss_objective = model.scal_prod(s_vars_flat, net_loss_flat)\nmodel.add(model.minimize(total_net_loss_objective))\n\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module at each time period.  \nSwitch state change variables: Binary variables representing whether the state (activated or deactivated) of each battery module changes between consecutive time periods.  \nWear-leveling variables: Integer variables representing the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system configuration is optimized.  \nCell nominal voltage: Voltage of each individual battery module under standard operating conditions.  \nMaximum current per module: The maximum allowable current that can flow through any single battery module without exceeding its safety threshold.  \nCapacity matrix (C): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the energy capacity of a specific battery module at a specific time period.  \nResistance matrix (R): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific battery module at a specific time period.  \nVoltage matrix (V): A 3D matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the output voltage of a specific battery module at a specific time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery system, calculated as the sum of the voltages of all series-connected branches, must remain within a predefined safe range at all time periods.  \nCurrent safety constraint: The current flowing through any activated battery module must not exceed the maximum allowable current at any time period.  \nParallel module consistency constraint: For each series branch, the number of parallel-connected modules must be identical across all series columns at each time period to ensure balanced load distribution.  \nWear-leveling constraint: The total number of activations of any two battery modules across all time periods must differ by no more than 2 to ensure equitable utilization and uniform battery degradation.  \nSwitching stability constraint: The total number of state changes (activations or deactivations) across all battery modules between any two consecutive time periods must not exceed 6 to minimize mechanical stress and reduce reconfiguration complexity.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three 3D matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \nSwitching state variables: Binary decision variables indicating whether a module's activation state changes between consecutive time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel in each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack.  \nNumber of time periods: Total number of discrete time periods for which the system configuration is optimized.  \nCell nominal voltage: Nominal voltage of each battery module.  \nMaximum current per module: Maximum allowable current through any single battery module.  \nCapacity matrix (C): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each element specifies the capacity of the corresponding module during a specific time period.  \nResistance matrix (R): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each element specifies the internal resistance of the corresponding module during a specific time period.  \nVoltage matrix (V): A 3-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each element specifies the voltage of the corresponding module during a specific time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack, determined by summing the voltages of all activated modules in series, must remain within a predefined safe range for all time periods.  \nCurrent safety constraint: The current flowing through any activated battery module must not exceed its maximum allowable current during any time period.  \nParallel consistency constraint: At any given time period, the number of parallel-connected modules in all series branches must be equal to ensure balanced load distribution.  \nWear-leveling constraint: The total number of activations of any two modules across all time periods must differ by no more than 2, ensuring uniform utilization of all modules.  \nOperational stability constraint: The number of modules whose activation state changes between two consecutive time periods must not exceed 6, limiting the frequency of reconfiguration to reduce mechanical and electrical stress.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. The energy loss includes internal resistance losses during activation periods and recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three 3-dimensional matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation state variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) in each time period.  \nParallel configuration variables: Binary variables representing the parallel connection state of battery modules within each series column for each time period.  \nSeries configuration variables: Binary variables representing the series connection state of battery modules across columns for each time period.  \nSwitching variables: Integer variables representing the number of state changes (activation/deactivation or connection reconfiguration) for each module between consecutive time periods.  \nUsage count variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules that can be connected in parallel within each series column.  \nNumber of series columns: Total count of columns in the matrix configuration, where modules in each column are connected in series.  \nNumber of time periods: Total number of discrete time intervals during which the system configuration is dynamically adjusted.  \nCell nominal voltage: Voltage output of each individual battery module when activated.  \nMaximum current per module: Safety threshold for the current flowing through any activated battery module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module in each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module in each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage output of each battery module in each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack system, calculated as the sum of the series-connected voltages across all columns, must remain strictly within the safe power supply range defined by the system's nominal voltage limits.  \nCurrent threshold constraint: The current flowing through any activated battery module must not exceed its maximum safety threshold, ensuring protection against overheating and degradation.  \nParallel consistency constraint: At any given time period, the number of parallel-connected battery modules in all series columns must be strictly consistent to ensure balanced load distribution across the system.  \nWear-leveling constraint: The total number of activations of any two battery modules across all time periods must differ by no more than 2, ensuring equitable utilization and promoting uniform degradation of all modules.  \nSwitching stability constraint: The maximum number of state changes (activation/deactivation or connection reconfiguration) allowed between consecutive time periods must not exceed 6, minimizing mechanical stress on switching components and reducing system complexity.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This loss includes both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: A binary decision variable for each battery module in each time period, indicating whether the module is activated (1) or deactivated (0).  \nSwitching variables: A binary decision variable for each battery module in each time period, indicating whether the module's activation state has changed compared to the previous time period.  \nParallel configuration variables: An integer variable for each series column in each time period, representing the number of parallel-connected battery modules in that column.  \nWear-leveling variables: An integer variable for each battery module representing the total number of activations across all time periods.\n\n2. Parameters and Input Data  \nSystem configuration:  \n- Number of parallel modules (NUM_PARALLEL_MODULES).  \n- Number of series columns (NUM_SERIES_COLUMNS).  \n- Number of time periods (NUM_PERIODS).  \n- Cell nominal voltage (NOMINAL_VOLTAGE).  \n- Maximum current per module (MAX_CURRENT).  \n\nBattery properties:  \n- Capacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix, where C[t][p][s] represents the capacity of the module at position (p, s) during time period t.  \n- Resistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix, where R[t][p][s] represents the internal resistance of the module at position (p, s) during time period t.  \n- Voltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix, where V[t][p][s] represents the voltage of the module at position (p, s) during time period t.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system in each time period must remain within the preset safe range, calculated as the sum of the nominal voltages of all activated modules in each series column.  \n\nCurrent constraint: The current flowing through any activated battery module in any time period must not exceed its maximum safety threshold (MAX_CURRENT).  \n\nParallel configuration constraint: At any given time period, the number of parallel-connected battery modules in all series columns must be strictly consistent across the system.  \n\nWear-leveling constraint: The total number of activations for any two battery modules across all time periods must differ by no more than 2, ensuring equitable utilization of all modules.  \n\nOperational stability constraint: The maximum number of modules allowed to change their activation state (from active to inactive or vice versa) between consecutive time periods must not exceed 6.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. This includes:  \n- Internal resistance losses during activation periods, calculated as a function of the module's resistance and current.  \n- Electrochemical recovery effects during deactivation periods, which reduce energy efficiency.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), number of time periods (NUM_PERIODS), cell nominal voltage (NOMINAL_VOLTAGE), and maximum current per module (MAX_CURRENT).  \n- Subsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nSwitching state variables: Binary variables representing whether the activation state of a battery module changes between consecutive time periods.  \nUsage count variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack matrix.  \nNumber of time periods: Total number of discrete time periods over which the system is optimized.  \nNominal cell voltage: The nominal voltage of each battery module when activated.  \nMaximum current per module: The upper limit of current that can safely flow through any activated battery module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module during each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module during each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack, calculated as the sum of voltages across all series columns, must remain within the safe operating range for all time periods.  \nCurrent limit constraint: The current flowing through any activated battery module must not exceed its maximum allowable value during any time period.  \nParallel consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be equal to ensure balanced load distribution.  \nWear-leveling constraint: The total number of activations (usage count) for any two battery modules across all time periods must differ by no more than 2.  \nOperational stability constraint: The number of switching state changes (activations or deactivations) across all battery modules between consecutive time periods must not exceed 6.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules, which includes:  \n- Internal resistance losses, calculated as the square of the current flowing through each module multiplied by its internal resistance during activation periods.  \n- Electrochemical recovery effects, which reduce energy efficiency during deactivation periods.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal cell voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nSwitching state variables: Binary decision variables representing whether the activation status of a battery module changes between consecutive time periods.  \nWear-leveling variables: Integer variables representing the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series column.  \nNumber of series columns: Total number of series-connected branches in the battery matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the scheduling problem is considered.  \nCell nominal voltage: Nominal voltage of each battery module, used to calculate the system's total output voltage.  \nMaximum current per module: Maximum allowable current that can flow through any single battery module to prevent overheating.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the available capacity of each battery module in each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module in each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage of each battery module in each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system, calculated as the sum of the voltages of all series-connected branches, must remain within a predefined safe range during each time period.  \nCurrent limit constraint: The current flowing through any activated battery module must not exceed its maximum allowable current during any time period.  \nParallel consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be identical to ensure balanced load distribution.  \nWear-leveling constraint: The cumulative number of activations of any two battery modules across all time periods must differ by no more than 2, ensuring equitable utilization of all modules.  \nSwitching stability constraint: The total number of modules that change their activation status between two consecutive time periods must not exceed 6, limiting the frequency of reconfiguration.  \nEnergy balance constraint: For each activated battery module, the energy loss due to internal resistance during activation periods must be accounted for, and electrochemical recovery effects during deactivation periods must be modeled to calculate net energy loss.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This includes energy losses due to internal resistance during activation periods and accounts for recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \n- Subsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module at each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the system at each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel across each series column.  \nNumber of series columns: Total count of series-connected columns in the matrix configuration.  \nNumber of time periods: Total number of discrete time intervals over which the system operates.  \nCell nominal voltage: The standard voltage output of each battery module when activated.  \nMaximum current per module: The upper safety threshold for current flow through each activated module.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the energy storage capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage output of each battery module at each time period when activated.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system at each time period must remain strictly within the safe power supply range defined by the system's operational limits.  \nCurrent safety constraints: The current flowing through any activated battery module at any time period must not exceed its maximum current threshold to prevent overheating and degradation.  \nParallel connection consistency constraints: At any given time period, the number of parallel-connected battery modules in all series columns must be strictly consistent, ensuring balanced load distribution.  \nWear-leveling constraints: The cumulative number of activations across all time periods for any two battery modules must differ by no more than 2, promoting equitable utilization and uniform degradation across the system.  \nSpatial activation constraints: Within any 2x2 matrix region of battery modules, no more than 2 modules can be activated simultaneously at any time period, ensuring efficient heat dissipation and preventing localized thermal hotspots.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the energy storage system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nParallel connection variables: Binary decision variables indicating whether a specific set of battery modules is connected in parallel within each series branch at each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within the system.  \nNumber of series columns: Total number of series branches in the battery pack configuration.  \nNumber of time periods: Total number of discrete time intervals for which the battery pack operation is scheduled.  \nCell nominal voltage: Voltage output of each individual battery module under nominal conditions.  \nMaximum current per module: Upper limit on the current that can safely flow through each battery module during activation.  \nCapacity matrix (C): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], specifying the voltage output of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of all series branches at any time period must strictly remain within the safe power supply range defined by the system.  \nCurrent limits: The current flowing through any activated battery module at any time period must not exceed its maximum safety threshold, ensuring safe operation and avoiding overheating.  \nParallel connection consistency: At any given time period, the number of parallel-connected battery modules across all series branches must be strictly consistent to ensure balanced load distribution.  \nWear-leveling constraints: The cumulative number of activations for any two battery modules across all time periods must differ by no more than 2 times, promoting uniform utilization and extending the system lifespan.  \nThermal management constraints: Within any 2x2 module matrix region at any time period, no more than 2 battery modules can be activated simultaneously, preventing localized thermal hotspots and ensuring efficient heat distribution.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This encompasses internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five numerical parameters representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C, R, and V) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary variables indicating whether a specific battery module is activated (1) or deactivated (0) at each time period.  \nParallel consistency variables: Binary variables ensuring the number of parallel-connected modules in each series branch is consistent across all branches at each time period.  \nWear-leveling variables: Integer variables representing the total number of activations for each module over all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack.  \nNumber of time periods: Total number of discrete time periods over which the system is optimized.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current for each battery module to ensure safe operation.  \nCapacity matrix (C): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry specifies the capacity of a module at a given time period.  \nResistance matrix (R): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry specifies the internal resistance of a module at a given time period.  \nVoltage matrix (V): A three-dimensional matrix of size [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry specifies the voltage of a module at a given time period.  \n\n3. Constraints  \nVoltage constraints: The total output voltage of the battery pack, determined by the sum of the voltages of activated modules in each series column, must remain within a predefined safe range for all time periods.  \nCurrent constraints: The current flowing through any activated battery module must not exceed the modules maximum allowable current, ensuring safe operation and preventing overheating.  \nParallel consistency constraints: The number of parallel-connected modules in all series branches must be identical at each time period to ensure balanced load distribution.  \nWear-leveling constraints: The total number of activations for any two modules across all time periods must differ by no more than 2, promoting equitable utilization and extending the lifespan of the battery pack.  \nSpatial activation constraints: Within any 2x2 matrix region of battery modules, no more than 2 modules can be activated simultaneously during any time period, ensuring efficient thermal management and preventing localized hotspots.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. The energy loss includes internal resistance losses during activation periods and recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C, R, V) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module at each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nSystem configuration: Number of parallel modules, number of series columns, and number of time periods in the scheduling horizon.  \nElectrical properties: Nominal voltage of each module and maximum allowable current per module.  \nPhysical characteristics: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], describing the capacity, resistance, and voltage of each battery module over time.  \nFault conditions: The battery module located at position (1,1) in the matrix is permanently malfunctioning and cannot be activated during any time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system, calculated as the sum of the voltages of all activated modules in each series column, must strictly remain within the safe power supply range at all time periods.  \nCurrent limit constraint: The current flowing through any activated battery module at any time period must not exceed the maximum allowable current for that module.  \nParallel module consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution across the system.  \nWear-leveling constraint: The cumulative number of activations for any two battery modules across all time periods shall differ by no more than 2 activations, promoting uniform utilization and minimizing degradation.  \nFault exclusion constraint: The battery module located at position (1,1) in the matrix is permanently excluded from activation and must remain deactivated throughout all time periods.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. Energy loss includes both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, aiming to maximize overall energy efficiency.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal voltage, and maximum current per module.  \n- Subsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the system during each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module over all time periods.\n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the scheduling problem is defined.  \nCell nominal voltage: The nominal voltage of each battery module when activated.  \nMaximum current per module: The maximum allowable current that can flow through any single module to prevent overheating and degradation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the actual voltage of each battery module at each time period.  \nFaulty module position: The specific battery module (row 1, column 1) that is permanently malfunctioning and cannot be activated.\n\n3. Constraints  \nVoltage output constraints: The total output voltage of the system at each time period must remain within a predefined safe range to prevent damage to connected loads. It is computed as the sum of the voltage contributions from all activated modules in the matrix.  \nCurrent limit constraints: The current flowing through any activated battery module during each time period must not exceed the module's maximum allowable current.  \nParallel consistency constraints: At any given time period, the number of parallel-connected modules in all series branches must be consistent to ensure balanced load distribution.  \nWear-leveling constraints: Over all time periods, the total number of activations for any two battery modules must differ by no more than 2 to promote uniform degradation and extend system lifespan.  \nFaulty module constraint: The battery module located at the first row and first column position must remain deactivated for all time periods due to a permanent malfunction.  \nActivation-deactivation constraints: A module can only contribute to the voltage output and current flow if it is activated during the respective time period.  \nEnergy flow constraints: The current flow through each activated module must respect the relationship defined by its capacity, resistance, and voltage characteristics at each time period.\n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over the entire scheduling horizon. The energy loss includes internal resistance losses during activation periods and recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the battery pack system.\n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables: Binary decision variables for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module at each time period.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery pack system at each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative usage count of each battery module across all time periods.  \n\n2. Parameters and Input Data  \nSystem configuration: The number of parallel-connected modules, the number of series columns, and the total number of time periods.  \nBattery module properties: Nominal voltage, maximum current per module, and matrices for capacity (C), resistance (R), and voltage (V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS].  \nFault condition: The battery module located at the first row and first column position is permanently disabled and cannot be activated in any time period.  \nSafe operating range: Preset minimum and maximum voltage levels defining the acceptable range for the system's total output voltage.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack system at each time period must strictly remain within the preset safe operating range.  \nCurrent threshold constraint: The current flowing through any activated battery module at any time period must not exceed its maximum allowable current to prevent overheating and degradation.  \nParallel consistency constraint: At any given time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nWear-leveling constraint: The total number of activations of any two battery modules across all time periods must differ by no more than 2, promoting uniform degradation and extending the system lifespan.  \nFault handling constraint: The battery module located at the first row and first column position is permanently disabled and cannot be activated throughout the entire operational period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This encompasses both internal resistance losses incurred during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, the number of series columns, the number of time periods, the nominal voltage per module, and the maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage), each with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nBinary activation variables for each module: A binary variable for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nCurrent flow variables for each module: A continuous variable for each activated module at each time period, representing the current flowing through the module.  \nVoltage output variables for each series branch: A continuous variable for each series branch at each time period, representing the total voltage of the branch.  \n\n2. Parameters and Input Data  \nNumber of parallel modules (NUM_PARALLEL_MODULES): Total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns (NUM_SERIES_COLUMNS): Total number of series-connected branches in the matrix configuration.  \nNumber of time periods (NUM_PERIODS): Total number of discrete time periods over which the system operates.  \nCell nominal voltage (V_nominal): Nominal voltage of each individual battery module.  \nMaximum current per module (I_max): Maximum allowable current that can flow through any individual battery module.  \nCapacity matrix (C): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the capacity of a specific module at a given time period.  \nResistance matrix (R): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the internal resistance of a specific module at a given time period.  \nVoltage matrix (V): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each entry represents the voltage of a specific module at a given time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system at each time period must remain within a predefined safe range to prevent damage to connected loads. This is computed as the sum of the voltages of all activated modules in each series branch.  \n\nCurrent limit constraint: The current flowing through any activated battery module at any time period must not exceed its maximum allowable current (I_max).  \n\nParallel consistency constraint: At any given time period, the number of parallel-connected modules in all series branches must be identical to ensure balanced load distribution across the system.  \n\nWear-leveling constraint: The total number of activations of any two battery modules across all time periods must differ by no more than 2 to ensure uniform degradation and extend the overall system lifespan.  \n\nFault-tolerance constraint: The battery module located at the first row and first column position (module [0,0]) is permanently malfunctioning and cannot be activated during any time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation periods and recovery effects during deactivation periods. The objective is to maximize the overall energy efficiency of the battery system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floating-point values representing NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS, NUM_PERIODS, V_nominal, and I_max.  \nSubsequent lines: Three 3D matrices (C, R, V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row. Each matrix is provided in sequence, with entries separated by spaces or line breaks.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module in the matrix is activated (1) or deactivated (0) during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period, constrained by the module's maximum current capacity.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the system during each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nMatrix configuration: The battery pack consists of a matrix with a given number of parallel modules (rows) and series columns (columns).  \nTime periods: The system operates over a specified number of discrete time periods.  \nNominal voltage and maximum current: Each module has a nominal voltage and a maximum allowable current.  \nFault conditions: The module at the first row and first column is permanently malfunctioning and cannot be activated during any time period.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the capacity of each module during each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance of each module during each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the voltage of each module during each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system during each time period must remain within a predefined safe range to avoid damage to connected loads.  \nCurrent limit constraints: The current flowing through any activated battery module during any time period must not exceed its maximum allowable current to prevent overheating and degradation.  \nParallel consistency constraints: At any given time period, the number of activated modules in each parallel branch (row) must be the same across all series branches (columns) to ensure balanced load distribution.  \nWear-leveling constraints: The total number of activations for any two battery modules across all time periods must differ by no more than 2, ensuring equitable utilization of all modules.  \nFault condition constraints: The module located at the first row and first column is permanently deactivated and cannot be activated during any time period.  \nActivation consistency constraints: A module can only carry current and contribute to the system's output voltage if it is activated during the corresponding time period.  \nEnergy balance constraints: The total energy loss for each module, considering internal resistance losses during activation and recovery effects during deactivation, must be accounted for in the system's energy efficiency calculation.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes internal resistance losses during activation and recovery effects during deactivation, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal voltage of each module, and maximum allowable current per module.  \nSubsequent lines: Three matrices (C, R, V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row. Each matrix specifies the capacity, resistance, and voltage of each module for every time period, respectively.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nParallel configuration variables: Integer variables representing the number of parallel-connected modules in each series column for each time period.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of modules available in parallel configuration.  \nNumber of series columns: Total number of columns in the matrix configuration for series connections.  \nNumber of time periods: The total operational time horizon during which the battery system is scheduled.  \nCell nominal voltage: The nominal voltage of each battery module when activated.  \nMaximum current per module: The maximum allowable current flow through each activated module.  \nCapacity matrix (C): A three-dimensional matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the capacity of each module at each time period.  \nResistance matrix (R): A three-dimensional matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each module at each time period.  \nVoltage matrix (V): A three-dimensional matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage output of each module at each time period.  \n\n3. Constraints  \nActivation constraints: Each battery module may either be activated or deactivated during any given time period, with binary decision variables governing this state.  \nOutput voltage constraints: The total output voltage of the system, calculated as the sum of the voltages across all series columns, must remain within the predefined safe range at all time periods.  \nCurrent flow constraints: The current flowing through any activated module must not exceed its maximum allowable threshold to prevent overheating and degradation.  \nParallel configuration constraints: At any time period, the number of parallel-connected modules in all series columns must remain strictly consistent across the matrix to ensure balanced load distribution.  \nWear-leveling constraints: The cumulative number of activations for any two modules across all time periods must differ by no more than 2, ensuring equitable utilization and uniform degradation.  \nFault constraints: The battery module located at the first row and first column position is permanently malfunctioned and cannot be activated during any time period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods. This includes losses due to internal resistance during activation periods and accounts for electrochemical recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 2\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module in the matrix is activated (1) or deactivated (0) during each time period.  \nSwitching state variables: Binary decision variables representing whether the activation state of a module changes (1) or remains the same (0) between consecutive time periods.  \nVoltage output variables: Continuous decision variables representing the total output voltage of the battery system during each time period.  \nCurrent flow variables: Continuous decision variables representing the current flowing through each activated battery module during each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches forming the matrix configuration.  \nNumber of time periods: Total discrete operational time periods for which the system configuration is optimized.  \nCell nominal voltage: Nominal voltage of each individual battery module.  \nMaximum current per module: Maximum allowable current for each battery module to prevent overheating and degradation.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each battery module during each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each battery module during each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the voltage of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery system during each time period must strictly remain within the specified safe power supply range.  \nCurrent limit constraint: The current flowing through any activated battery module during each time period must not exceed the maximum allowable current.  \nParallel consistency constraint: The number of activated battery modules connected in parallel within all series branches must be strictly consistent at any given time period to ensure balanced load distribution.  \nSwitching limit constraint: The maximum number of battery modules allowed to change activation state between consecutive time periods is limited to 6, preventing excessive reconfiguration frequency.  \nSpatial activation constraint: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously during any time period to prevent localized thermal hotspots and ensure efficient heat dissipation.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated battery modules over the entire scheduling horizon, accounting for internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five parameters (number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module).  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module in the matrix is activated (1) or deactivated (0) at each time period.  \nSwitching variables: Binary decision variables representing whether the activation state of a battery module changes (0 to 1 or 1 to 0) between consecutive time periods.  \nOutput voltage variables: Continuous variables representing the total output voltage of the battery pack at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series branches in the battery matrix configuration.  \nNumber of time periods: Total number of discrete time periods for which the system is analyzed.  \nCell nominal voltage: Nominal voltage of each individual battery module.  \nMaximum current per module: Maximum allowable current for each battery module to ensure safety.  \nCapacity matrix (C): A three-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the capacity of each battery module at each time period.  \nResistance matrix (R): A three-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A three-dimensional matrix with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack at each time period must remain within the predefined safe range to prevent damage to connected loads.  \n\\[ V_{\\text{min}} \\leq \\text{Total Voltage}(t) \\leq V_{\\text{max}}, \\, \\forall t \\in \\text{Time Periods} \\]  \n\nCurrent safety constraints: The current flowing through any activated battery module at each time period must not exceed the maximum allowable current.  \n\\[ \\text{Current}(i,j,t) \\leq I_{\\text{max}}, \\, \\forall i \\in \\text{Parallel Modules}, \\, \\forall j \\in \\text{Series Columns}, \\, \\forall t \\in \\text{Time Periods} \\]  \n\nParallel consistency constraints: At each time period, the number of activated parallel battery modules must be consistent across all series branches to ensure balanced load distribution.  \n\\[ \\text{Activated Modules}(j_1, t) = \\text{Activated Modules}(j_2, t), \\, \\forall j_1, j_2 \\in \\text{Series Columns}, \\, \\forall t \\in \\text{Time Periods} \\]  \n\nSwitching constraints: The total number of modules that change their activation state between consecutive time periods must not exceed the maximum allowed number of state changes.  \n\\[ \\sum_{i,j} \\text{Switching}(i,j,t) \\leq S_{\\text{max}}, \\, \\forall t \\in \\text{Time Periods} \\setminus \\{\\text{first period}\\} \\]  \n\nSpatial activation constraints: Within any 2x2 submatrix of battery modules, no more than 2 modules may be activated simultaneously at any time period to prevent localized thermal hotspots.  \n\\[ \\sum_{(i',j') \\in \\text{2x2 Submatrix}(i,j)} \\text{Activation}(i',j',t) \\leq 2, \\, \\forall (i,j) \\in \\text{Parallel Modules} \\times \\text{Series Columns}, \\, \\forall t \\in \\text{Time Periods} \\]  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. The energy loss includes internal resistance losses during activation and electrochemical recovery effects during deactivation.  \n\\[ \\text{Minimize} \\, \\sum_{t} \\sum_{i,j} \\left( R(i,j,t) \\cdot \\text{Current}(i,j,t)^2 + \\text{Recovery Loss}(i,j,t) \\right) \\]  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floats representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided in row-major order. Each matrix is listed sequentially in the file.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation state variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitch state change variables: Binary variables representing whether the activation state of a battery module changes between consecutive time periods.  \nOutput voltage variables: Continuous variables representing the total output voltage of the battery pack at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series column.  \nNumber of series columns: Total number of series-connected columns in the battery pack.  \nNumber of time periods: Total number of discrete time periods for which the system configuration must be determined.  \nCell nominal voltage: The nominal voltage of each individual battery module.  \nMaximum current per module: The maximum allowable current flow through any battery module to prevent overheating and degradation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack at each time period must remain within a predefined safe range to ensure proper operation of connected loads.  \n\\[ V_{\\text{min}} \\leq \\sum_{\\text{series columns}} \\sum_{\\text{parallel modules}} \\text{(activation state)} \\times \\text{(cell voltage)} \\leq V_{\\text{max}} \\]  \n\nCurrent safety constraints: The current flowing through any activated battery module at any time period must not exceed the module's maximum allowable current.  \n\\[ \\text{current flow} \\leq \\text{maximum current per module} \\]  \n\nParallel connection consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be equal to ensure balanced load distribution.  \n\\[ \\text{number of active modules per series column (at time t)} \\text{ is constant across all columns} \\]  \n\nSwitching limit constraints: The number of battery modules that change their activation state between consecutive time periods must not exceed 6 to limit mechanical stress on switching components.  \n\\[ \\sum_{\\text{modules}} \\text{(switch state change)} \\leq 6 \\]  \n\nThermal management constraints: Within any 2x2 region of the module matrix, no more than 2 modules may be activated simultaneously during any time period to prevent localized thermal hotspots and ensure efficient heat distribution.  \n\\[ \\sum_{\\text{modules in 2x2 region}} \\text{(activation state)} \\leq 2 \\]  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over the entire time horizon. The energy loss includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods.  \n\\[ \\text{Minimize } \\sum_{\\text{time periods}} \\sum_{\\text{modules}} \\text{(activation state)} \\times \\text{(internal resistance loss)} + \\text{(recovery loss)} \\]  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three flattened matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each module: Binary decision variables indicating whether a specific battery module is activated (1) or deactivated (0) at each time period.  \nSwitching state variables: Binary decision variables representing whether a module changes its state (activation or deactivation) between consecutive time periods.  \nOutput voltage variables: Continuous decision variables representing the total output voltage of the system at each time period.  \nOutput current variables: Continuous decision variables representing the total output current of the system at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules, series columns, and time periods: The problem involves a grid of battery modules defined by the number of parallel-connected modules, series-connected columns, and discrete time periods.  \nCell nominal voltage and maximum current: The nominal voltage of each battery module and its maximum allowable current to ensure safe operation.  \nCapacity matrix (C): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each module during each time period.  \nResistance matrix (R): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each module during each time period.  \nVoltage matrix (V): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the voltage of each module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system at any time period must remain within a predefined safe range to prevent damage to connected loads.  \nCurrent safety constraint: The current flowing through any activated battery module at any time period must not exceed its maximum allowable current to avoid overheating and degradation.  \nParallel module consistency constraint: At every time period, the number of parallel-connected modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nSwitching limit constraint: The total number of modules that change their activation state (from 0 to 1 or 1 to 0) between consecutive time periods must not exceed 6, limiting reconfiguration frequency and reducing mechanical stress on switching components.  \nSpatial activation constraint: Within any 2x2 submatrix of battery modules at any time period, no more than 2 modules can be activated simultaneously, ensuring heat dissipation and preventing localized thermal hotspots.  \nOutput voltage calculation: The total output voltage at any time period is determined by the sum of the voltages of all activated modules in each series column.  \nOutput current calculation: The total output current at any time period is determined by the sum of currents through all parallel-connected modules, considering their activation states and resistances.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated modules over the entire time horizon. This includes both internal resistance losses during activation periods and energy recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, nominal voltage per module, and maximum allowable current per module.  \n- Subsequent lines: Three matrices (C, R, and V) of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], provided in a flattened row-by-row format.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each module: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitch state change variables: Binary decision variables representing whether the activation state of each module changes between consecutive time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time intervals over which the system operates.  \nCell nominal voltage: Voltage rating of each individual battery module.  \nMaximum current per module: Safety threshold for the current flowing through any activated battery module.  \nCapacity matrix (C): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each module at each time period.  \nResistance matrix (R): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each module at each time period.  \nVoltage matrix (V): A 3D matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the output voltage of each module at each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack across all series columns must remain within the preset safe power supply range at all time periods.  \nCurrent safety constraint: The current flowing through any activated battery module must not exceed its maximum safety threshold at any time period.  \nParallel module consistency constraint: At every time period, the number of parallel-connected modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nSwitch operation stability constraint: The maximum number of modules allowed to change activation state between consecutive time periods is limited to 6, preventing excessive reconfiguration frequency.  \nThermal management constraint: Within any 2x2 module matrix region, no more than 2 modules may be activated simultaneously at any time period to prevent localized thermal hotspots and ensure efficient heat distribution.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. This encompasses energy losses due to internal resistance during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five parameters (number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module).  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitching variables: Binary decision variables representing whether each module changes state (activation or deactivation) between consecutive time periods.  \nVoltage output variables: Continuous variables representing the total output voltage of the battery pack at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated module at each time period.\n\n2. Parameters and Input Data  \nMatrix dimensions: Number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), and number of time periods (NUM_PERIODS).  \nModule characteristics: Each module is defined by its nominal voltage (V), capacity (C), and resistance (R), provided as three matrices with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS].  \nVoltage range: Minimum and maximum allowable output voltage for the battery pack system, ensuring safe operation.  \nMaximum current per module: The upper limit of current that can flow through any activated module to prevent overheating and degradation.  \nSwitching limit: Maximum number of modules allowed to change state between consecutive time periods to ensure operational stability.  \nThermal management limit: Maximum number of modules that can be activated simultaneously within any 2x2 module matrix region at any time period to prevent thermal hotspots.\n\n3. Constraints  \nVoltage balance constraints: The total output voltage of the battery pack at each time period must remain within the specified safe voltage range. This is calculated as the sum of voltages of all activated modules in each series column.  \nCurrent flow constraints: The current flowing through any activated module at any time period must not exceed its maximum allowable current.  \nParallel module consistency constraints: At any time period, the number of activated parallel modules in all series branches must be equal to ensure balanced load distribution.  \nSwitching constraints: The number of modules that change state (activation or deactivation) between consecutive time periods must not exceed the specified switching limit.  \nThermal management constraints: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously at any time period to ensure even heat distribution.  \nModule activation constraints: Activation variables must be binary (0 or 1) for all modules and time periods.  \nSwitching variable constraints: Switching variables must correctly represent state changes of activation variables between consecutive time periods.\n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, aiming to maximize overall energy efficiency of the battery pack system.\n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \n- First line: Five integers representing the number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), number of time periods (NUM_PERIODS), nominal voltage of each module (V), and maximum current per module.  \n- Subsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status of each battery module: Binary decision variable for each battery module in the matrix at each time period, indicating whether the module is activated (1) or deactivated (0).  \nCurrent flow through each battery module: Continuous decision variable representing the current flowing through each activated battery module at each time period.  \nSwitch state changes: Binary decision variable indicating whether the activation status of a battery module changes between consecutive time periods.  \n\n2. Parameters and Input Data  \nMatrix configuration: Number of parallel modules (NUM_PARALLEL_MODULES) and number of series columns (NUM_SERIES_COLUMNS) defining the battery module arrangement.  \nTime horizon: Number of discrete time periods (NUM_PERIODS) over which the system operates.  \nElectrical properties:  \n- Cell nominal voltage (V_NOMINAL): Voltage of each battery module when activated.  \n- Maximum current per module (I_MAX): Safety threshold for the current flowing through any activated module.  \nModule-specific properties: Three matricesC (capacity), R (resistance), and V (voltage)with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], providing time-dependent capacity, resistance, and voltage values for each module.  \nFault condition: The battery module located at the first row and first column position is permanently deactivated and cannot be activated during any time period.  \nSwitching limit: Maximum number of module activation state changes allowed between consecutive time periods (SWITCH_LIMIT = 6).  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system at each time period, calculated as the sum of the nominal voltages of all activated modules in each series column, must remain within the safe power supply range.  \nCurrent limit constraint: The current flowing through any activated battery module at any time period must not exceed its maximum safety threshold (I_MAX).  \nParallel module consistency constraint: At each time period, the number of parallel-connected modules in all series branches must be identical to ensure balanced load distribution.  \nSwitching limit constraint: The total number of activation state changes across all modules between consecutive time periods must not exceed the predefined limit (SWITCH_LIMIT).  \nFault condition constraint: The battery module located at the first row and first column position is permanently deactivated and cannot be activated during any time period.  \nEnergy flow constraints: The current flowing through each activated module must respect the module's resistance and voltage characteristics, ensuring realistic energy flow calculations.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated modules over the entire time horizon. The energy loss includes:  \n- Internal resistance losses during activation periods, proportional to the square of the current flowing through each module and its resistance.  \n- Electrochemical recovery effects during deactivation periods, which depend on the module's capacity and usage history.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C, R, V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row. Each matrix entry corresponds to the respective capacity, resistance, or voltage value for a specific module and time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module in the matrix configuration is activated (1) or deactivated (0) at each time period.  \nSwitch state variables: Binary decision variables representing whether the state of each module (activated or deactivated) changes between consecutive time periods.  \nOutput voltage variables: Continuous decision variables representing the total output voltage of the battery pack at each time period.  \nOutput current variables: Continuous decision variables representing the total output current of the battery pack at each time period.  \n\n2. Parameters and Input Data  \nMatrix configuration: Number of parallel modules (NUM_PARALLEL_MODULES) and number of series columns (NUM_SERIES_COLUMNS) in the battery pack.  \nTime periods: Total number of discrete time periods (NUM_PERIODS) during which the system operates.  \nBattery module parameters:  \n- Cell nominal voltage (V_nominal): Voltage of each individual module under nominal conditions.  \n- Maximum current per module (I_max): Safety threshold for the current flowing through each module.  \n- Capacity matrix (C): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the capacity of each module in each time period.  \n- Resistance matrix (R): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the internal resistance of each module in each time period.  \n- Voltage matrix (V): A matrix of dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] representing the voltage of each module in each time period.  \nFault condition: The battery module located at the first row and first column position is permanently inoperable and cannot be activated in any time period.  \nSwitching limit: The maximum number of modules allowed to change their activation state between consecutive time periods is limited to 6.  \nSafe power supply range: The system's total output voltage must remain within a predefined range [V_min, V_max] at all time periods.  \n\n3. Constraints  \nActivation constraints: The binary activation variable for the faulty module at the first row and first column must always be 0 across all time periods.  \nVoltage constraints: The total output voltage of the battery pack at each time period, calculated as the sum of the voltages of all activated modules in the series configuration, must remain within the safe power supply range [V_min, V_max].  \nCurrent constraints: The current flowing through each activated module at each time period, determined by the total output current divided by the number of parallel-connected modules, must not exceed the maximum allowable current (I_max).  \nParallel consistency constraints: At any given time period, the number of parallel-connected modules across all series branches must be consistent to ensure balanced load distribution.  \nSwitching constraints: The number of modules that change their activation state (from activated to deactivated or vice versa) between consecutive time periods must not exceed 6.  \nEnergy flow constraints: The total energy loss of each activated module, calculated based on its internal resistance and current flow during activation, must be correctly modeled. Similarly, recovery effects during deactivation periods must be accounted for in the energy loss calculation.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over the entire operational period. This includes internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, aiming to maximize the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers or floats representing the number of parallel modules (NUM_PARALLEL_MODULES), number of series columns (NUM_SERIES_COLUMNS), number of time periods (NUM_PERIODS), cell nominal voltage (V_nominal), and maximum current per module (I_max).  \nSubsequent lines: Three matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], each flattened row by row. Each matrix entry corresponds to the respective parameter (capacity, resistance, or voltage) for a specific module at a specific time period.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) at each time period.  \nSwitch state change variables: Binary decision variables representing whether the state of a battery module changes (from activated to deactivated or vice versa) between consecutive time periods.  \nOutput voltage variables: Continuous variables representing the total output voltage of the battery pack system at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated battery module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system operates.  \nCell nominal voltage: The nominal voltage of each battery module.  \nMaximum current per module: The maximum allowable current that can flow through each battery module to avoid overheating and degradation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the capacity of each battery module at each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the internal resistance of each battery module at each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the voltage of each battery module at each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the battery pack at each time period must strictly remain within the preset safe power supply range to prevent damage to connected loads.  \nCurrent limit constraint: The current flowing through any activated battery module at any time period must not exceed its maximum safety threshold.  \nParallel module balancing constraint: At each time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nOperational stability constraint: The maximum number of switches allowed to change state (from activated to deactivated or vice versa) between consecutive time periods is limited to 6, preventing excessive reconfiguration frequency.  \nFault exclusion constraint: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated throughout the entire operational period.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules over all time periods, which encompasses both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods. This objective indirectly maximizes the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation status variables: Binary decision variables for each battery module at each time period, indicating whether the module is activated (1) or deactivated (0).  \nCurrent flow variables: Continuous decision variables for the current flowing through each activated battery module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods during which the battery pack operates.  \nCell nominal voltage: Nominal voltage of each battery module.  \nMaximum current per module: Maximum allowable current for each battery module to prevent overheating and degradation.  \nCapacity matrix (C): A three-dimensional matrix representing the capacity of each battery module for each time period, with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS].  \nResistance matrix (R): A three-dimensional matrix representing the internal resistance of each battery module for each time period, with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS].  \nVoltage matrix (V): A three-dimensional matrix representing the actual voltage of each battery module for each time period, with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS].  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system at each time period, calculated as the sum of the nominal voltages of the series-connected branches, must remain strictly within the preset safe power supply range.  \nMaximum current constraints: The current flowing through any activated battery module at any time period must not exceed the module's maximum allowable current.  \nParallel consistency constraints: At any time period, the number of parallel-connected battery modules in all series branches must be strictly consistent to ensure balanced load distribution.  \nSpatial activation constraints: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously at any time period to prevent localized thermal hotspots and ensure heat dissipation efficiency.  \nFault condition constraints: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated at any time period.  \nActivation-deactivation constraints: A module can only conduct current if it is activated, and no current can flow through a deactivated module.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules across all time periods. Energy loss includes internal resistance losses during activation periods and accounts for electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables\nActivation status variables for each battery module: Binary variables indicating whether each module is activated during each time period.\nCurrent flow variables for each module: Continuous variables representing the current flowing through each activated module during each time period.\n\n2. Parameters and Input Data\nNumber of parallel modules and series columns: The matrix configuration of the battery pack, indicating how modules are arranged.\nNumber of time periods: The total number of discrete time intervals over which the system is evaluated.\nCell nominal voltage and maximum current per module: The voltage each module can supply and the maximum current it can handle safely.\nCapacity, resistance, and voltage matrices: Three-dimensional matrices representing the capacity, internal resistance, and voltage characteristics of each module over time, with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS].\n\n3. Constraints\nVoltage constraint: The total output voltage of the system must remain within a predetermined safe range to prevent damage to connected loads.\nCurrent constraint: The current flowing through any activated battery module must not exceed its maximum safety threshold to avoid overheating and degradation.\nParallel consistency constraint: The number of parallel-connected battery modules in all series branches must be consistent at any given moment to ensure balanced load distribution.\nSpatial activation constraint: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously to prevent localized thermal hotspots.\nFault condition constraint: The module located at the first row and first column position is malfunctioned and cannot be activated throughout the entire operational period.\n\n4. Objective Function\nMinimize the total net energy loss of all activated modules, which includes both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.\n\n5. Data Specification\nThe input file \"data/battery_data.txt\" follows this format:\n- First line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.\n- Subsequent lines: Three matrices (Capacity, Resistance, Voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], each matrix flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for each module: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nVoltage output variables: Continuous variables representing the total output voltage of the battery pack at each time period.  \nCurrent flow variables: Continuous variables representing the current flowing through each activated module at each time period.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the battery pack matrix.  \nNumber of time periods: Total number of discrete operational time periods during which the system is optimized.  \nCell nominal voltage: Nominal voltage of each individual battery module when activated.  \nMaximum current per module: The maximum allowable current flow through any single battery module to ensure safe operation.  \nCapacity matrix (C): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the capacity of each module at each time period.  \nResistance matrix (R): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the internal resistance of each module at each time period.  \nVoltage matrix (V): A three-dimensional matrix [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] specifying the actual voltage output of each module at each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the battery pack at each time period must strictly remain within the safe power supply range defined by the system design.  \nCurrent safety constraints: The current flowing through any activated battery module at any time period must not exceed its maximum allowable threshold.  \nParallel consistency constraints: At any given time period, the number of parallel-connected battery modules in all series branches must be consistent across the battery pack to ensure balanced load distribution.  \nSpatial activation constraints: Within any 2x2 module matrix region, no more than 2 modules can be activated simultaneously during any time period, distributing heat generation evenly across the battery pack.  \nFault condition constraints: The battery module located at the first row and first column position is permanently malfunctioning and cannot be activated during any time period.  \n\n4. Objective Function  \nMinimize the total net energy loss across all activated modules over all time periods. This includes losses due to internal resistance during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nFAULTY_MODULE_ROW = 0  \nFAULTY_MODULE_COL = 0 \nfor k in range(NUM_PERIODS):\n    model.add(s[k, FAULTY_MODULE_ROW, FAULTY_MODULE_COL] == 0)\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(f\"FAULT SIMULATION: Module ({FAULTY_MODULE_ROW + 1},{FAULTY_MODULE_COL + 1}) is permanently offline.\")\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables: Binary variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nSwitching variables: Binary variables representing whether the state of a battery module changes (from activated to deactivated or vice versa) between consecutive time periods.  \nWear-leveling variables: Integer variables tracking the cumulative number of activations for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total number of battery modules arranged in parallel within each series branch.  \nNumber of series columns: Total number of series-connected branches in the matrix configuration.  \nNumber of time periods: Total number of discrete time periods over which the system is optimized.  \nCell nominal voltage: Nominal voltage of an individual battery module.  \nMaximum current per module: Maximum allowable current for each battery module to prevent overheating and degradation.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the capacity of each battery module in ampere-hours during each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the internal resistance of each battery module in ohms during each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix representing the voltage of each battery module during each time period.  \n\n3. Constraints  \nVoltage range constraints: The total output voltage of the system (sum of the voltages of all series-connected branches) must remain within a predefined safe range during each time period.  \nCurrent limit constraints: The current flowing through any activated battery module must not exceed its maximum allowable value during any time period.  \nParallel consistency constraints: At any given time period, the number of parallel-connected modules in all series branches must be identical to ensure balanced load distribution.  \nWear-leveling constraints: The total number of activations for any two battery modules across all time periods must differ by no more than 2, ensuring equitable utilization of all modules.  \nSwitching constraints: The total number of battery modules that change their activation state between consecutive time periods must not exceed 6, limiting reconfiguration frequency.  \nSpatial activation constraints: At any given time period, within any 2x2 sub-matrix of battery modules, no more than 2 modules may be activated simultaneously to prevent localized thermal hotspots.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated battery modules, accounting for both internal resistance losses during activation periods and electrochemical recovery effects during deactivation periods.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C, R, and V) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], where each matrix is flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    voltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_voltage_contribution = model.scal_prod(vars_for_period_k, voltages_for_period_k)\n\n    model.add(total_voltage_contribution >= V_lower[k] * p[k])\n    model.add(total_voltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 1\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_current = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_current:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  },
  {
    "instruction": "1. Decision Variables  \nActivation variables for battery modules: Binary decision variables indicating whether each battery module is activated (1) or deactivated (0) during each time period.  \nSwitching state variables: Binary decision variables representing whether the activation state of a module changes between consecutive time periods.  \nLoad distribution variables: Integer decision variables representing the number of parallel-connected modules in each series branch during each time period.  \nWear-leveling variables: Integer decision variables tracking the cumulative activation count for each battery module across all time periods.  \n\n2. Parameters and Input Data  \nNumber of parallel modules: Total count of battery modules connected in parallel within each series branch.  \nNumber of series columns: Total count of series branches in the battery matrix configuration.  \nNumber of time periods: Total number of discrete time intervals during which the system operates and decisions are made.  \nCell nominal voltage: Voltage rating of each individual battery module.  \nMaximum current per module: Safety threshold specifying the maximum allowable current for each activated module.  \nCapacity matrix (C): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the capacity of each module during each time period.  \nResistance matrix (R): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the internal resistance of each module during each time period.  \nVoltage matrix (V): A [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS] matrix specifying the actual voltage output of each module during each time period.  \n\n3. Constraints  \nVoltage range constraint: The total output voltage of the system, computed as the sum of the voltages of activated modules across all series branches, must remain within the predefined safe power supply range during each time period.  \nCurrent limit constraint: The current flowing through any activated module must not exceed its maximum allowable threshold during any time period.  \nParallel connection consistency constraint: The number of parallel-connected modules in all series branches must be strictly consistent during each time period, ensuring balanced load distribution.  \nWear-leveling constraint: The cumulative activation count of any two modules across all time periods shall differ by no more than two, promoting uniform utilization and extending system lifespan.  \nOperational stability constraint: The number of modules whose activation state changes between consecutive time periods must not exceed six, limiting the frequency of reconfiguration and reducing mechanical stress on switching components.  \nSpatial activation constraint: Within any 2x2 submatrix of modules, no more than two modules may be activated simultaneously during any time period, preventing localized thermal hotspots and ensuring effective thermal management.  \n\n4. Objective Function  \nMinimize the total net energy loss of all activated modules across all time periods, which includes losses due to internal resistance during activation periods and electrochemical recovery effects during deactivation periods, thereby maximizing the overall energy efficiency of the battery pack system.  \n\n5. Data Specification  \nThe input file \"data/battery_data.txt\" follows this format:  \nFirst line: Five integers representing the number of parallel modules, number of series columns, number of time periods, cell nominal voltage, and maximum current per module.  \nSubsequent lines: Three matrices (C for capacity, R for resistance, and V for voltage) with dimensions [NUM_PERIODS  NUM_PARALLEL_MODULES  NUM_SERIES_COLUMNS], flattened row by row.",
    "input": "",
    "output": "import numpy as np\nfrom docplex.cp.model import CpoModel\nimport sys\nimport os\n\nfilename = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data/battery_data.txt\")\nwith open(filename, \"r\") as file:\n    lines = [line.strip() for line in file if line.strip() and not line.strip().startswith('#')]\n\nparams = lines[0].split()\nNUM_PARALLEL_MODULES = int(params[0])\nNUM_SERIES_COLUMNS = int(params[1])\nNUM_PERIODS = int(params[2])\nCELL_NOMINAL_VOLTAGE = float(params[3])\nI_MAX_MODULE = int(params[4])\nall_numbers = [float(num) for line in lines[1:] for num in line.split()]\ndata_points_per_matrix = NUM_PERIODS * NUM_PARALLEL_MODULES * NUM_SERIES_COLUMNS\nif len(all_numbers) != 3 * data_points_per_matrix:\n    print(f\"Error: Data size mismatch in '{filename}'.\")\n    print(f\"Expected {3 * data_points_per_matrix} numbers, but found {len(all_numbers)}.\")\n    sys.exit(1)\n\nC = np.array(all_numbers[0 : data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nR = np.array(all_numbers[data_points_per_matrix : 2 * data_points_per_matrix]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\nV = np.array(all_numbers[2 * data_points_per_matrix :]).reshape((NUM_PERIODS, NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS))\n\nNOMINAL_VOLTAGE = NUM_SERIES_COLUMNS * CELL_NOMINAL_VOLTAGE\nI_load = [35] * NUM_PERIODS\nV_lower = [NOMINAL_VOLTAGE * 0.95] * NUM_PERIODS\nV_upper = [NOMINAL_VOLTAGE * 1.05] * NUM_PERIODS\n\nmodel = CpoModel()\n\ns_keys = [(k, i, j) for k in range(NUM_PERIODS)\n          for i in range(NUM_PARALLEL_MODULES)\n          for j in range(NUM_SERIES_COLUMNS)]\ns = model.binary_var_dict(s_keys, name='s')\np = model.integer_var_list(NUM_PERIODS, min=1, max=NUM_PARALLEL_MODULES, name='p')\n\nfor k in range(NUM_PERIODS):\n    for j in range(NUM_SERIES_COLUMNS):\n        model.add(model.sum(s[k, i, j] for i in range(NUM_PARALLEL_MODULES)) == p[k])\n\n    vars_for_period_k = [s[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    cellVoltages_for_period_k = [V[k, i, j] for i in range(NUM_PARALLEL_MODULES) for j in range(NUM_SERIES_COLUMNS)]\n    total_cellVoltage_contribution = model.scal_prod(vars_for_period_k, cellVoltages_for_period_k)\n\n    model.add(total_cellVoltage_contribution >= V_lower[k] * p[k])\n    model.add(total_cellVoltage_contribution <= V_upper[k] * p[k])\n    model.add(I_load[k] <= p[k] * I_MAX_MODULE)\n\nALLOWED_USAGE_DEVIATION = 1\nmodule_usage = [model.sum(s[k, i, j] for k in range(NUM_PERIODS))\n                for i in range(NUM_PARALLEL_MODULES)\n                for j in range(NUM_SERIES_COLUMNS)]\nmodel.add(model.max(module_usage) - model.min(module_usage) <= ALLOWED_USAGE_DEVIATION)\n\nMAX_SWITCH_CHANGES_PER_PERIOD = 6\nfor k in range(1, NUM_PERIODS):\n    num_changes = model.sum(model.abs(s[k, i, j] - s[k - 1, i, j])\n                            for i in range(NUM_PARALLEL_MODULES)\n                            for j in range(NUM_SERIES_COLUMNS))\n    model.add(num_changes <= MAX_SWITCH_CHANGES_PER_PERIOD)\n\nMAX_ACTIVE_IN_2x2_BLOCK = 2\nfor k in range(NUM_PERIODS):\n    for i in range(NUM_PARALLEL_MODULES - 1):\n        for j in range(NUM_SERIES_COLUMNS - 1):\n            block_vars = [s[k, i, j], s[k, i + 1, j], s[k, i, j + 1], s[k, i + 1, j + 1]]\n            model.add(model.sum(block_vars) <= MAX_ACTIVE_IN_2x2_BLOCK)\n\ncost = C + R\ns_vars_flat = [s[key] for key in s_keys]\ncost_flat = [cost[k, i, j] for k, i, j in s_keys]\ntotal_cost_objective = model.scal_prod(s_vars_flat, cost_flat)\nmodel.add(model.minimize(total_cost_objective))\n\nprint(\"Solving model...\")\nsolution = model.solve(TimeLimit=100)\n\nif solution:\n    print(\"Solution found!\")\n    print(f\"Minimized objective function value: {solution.get_objective_value():.4f}\\n\")\n\n    for k in range(NUM_PERIODS):\n        active_modules_count = solution[p[k]]\n        print(\n            f\"--- Period {k + 1} (Load: {I_load[k]} A) Optimal Configuration (Active per column: {active_modules_count}) ---\")\n        config_matrix = np.zeros((NUM_PARALLEL_MODULES, NUM_SERIES_COLUMNS), dtype=int)\n        total_v_calc = 0\n        for j in range(NUM_SERIES_COLUMNS):\n            col_v = 0\n            for i in range(NUM_PARALLEL_MODULES):\n                is_active = solution[s[k, i, j]]\n                config_matrix[i, j] = is_active\n                if is_active:\n                    col_v += V[k, i, j]\n            if active_modules_count > 0:\n                total_v_calc += col_v / active_modules_count\n        print(\"Switch Matrix (1=ON, 0=OFF):\")\n        print(config_matrix)\n        print(f\"  - Calculated Output Voltage: {total_v_calc:.2f} V (Constraint: [{V_lower[k]:.2f}, {V_upper[k]:.2f}])\")\n        if active_modules_count > 0:\n            module_dischargeCurrent = I_load[k] / active_modules_count\n            print(f\"  - Current per active module: {module_dischargeCurrent:.2f} A (Max allowed: {I_MAX_MODULE} A)\\n\")\n        else:\n            print(\"  - No active modules.\\n\")\nelse:\n    print(\"No feasible solution found within the time limit.\")"
  }
]